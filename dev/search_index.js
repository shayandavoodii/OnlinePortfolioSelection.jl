var documenterSearchIndex = {"docs":
[{"location":"PM/#Pattern-matching-algorithms","page":"Pattern-matching","title":"Pattern-matching algorithms","text":"","category":"section"},{"location":"PM/","page":"Pattern-matching","title":"Pattern-matching","text":"Pattern-matching algorithms are one of most popular algorithms in the context of online portfolio selection. The main idea behind these algorithms is to find a pattern in the past price data and use it to predict the future price. These strategies are in consensus with technical analysts perspective. Technical analysts believe that the historical patterns in the price data will repeat in the future. The following pattern-matching algorithms are implemented in this package so far:","category":"page"},{"location":"PM/","page":"Pattern-matching","title":"Pattern-matching","text":"Correlation-driven Nonparametric Learning  1.1. CORN-U  1.2. CORN-K\nDynamic RIsk CORrelation-driven Non-parametric","category":"page"},{"location":"PM/#Correlation-driven-Nonparametric-Learning","page":"Pattern-matching","title":"Correlation-driven Nonparametric Learning","text":"","category":"section"},{"location":"PM/","page":"Pattern-matching","title":"Pattern-matching","text":"Correlation-driven Nonparametric Learning (CORN) is a pattern-matching algorithm proposed by Borodin et al. (2010). CORN utilizes the correlation as the similarity measure between time windows. Additionally, CORN defines several experts to construct portfolios. For each trading day, CORN combines the portfolios of the experts to construct the final portfolio. This is where CORN-K and CORN-U differ. CORN-K uses K best experts (based on their performance on historical data) to construct the final portfolio. On the other hand, CORN-U uses all the experts and uniformly combines their portfolios to construct the final portfolio. See CORN-U and CORN-K. ","category":"page"},{"location":"PM/#Dynamic-RIsk-CORrelation-driven-Non-parametric","page":"Pattern-matching","title":"Dynamic RIsk CORrelation-driven Non-parametric","text":"","category":"section"},{"location":"PM/","page":"Pattern-matching","title":"Pattern-matching","text":"Dynamic RIsk CORrelation-driven Non-parametric (DRICORN) follows the same idea as CORN-K. However, DRICORN considers the beta of portfolio as a measure of risk in the portfolio optimization. Furthermore, they consider the recent trend of market in order to take advantage of positive risks, and avoid negative risks.","category":"page"},{"location":"PM/","page":"Pattern-matching","title":"Pattern-matching","text":"See DRICORN-K.","category":"page"},{"location":"funcs/#API","page":"Functions","title":"API","text":"","category":"section"},{"location":"funcs/","page":"Functions","title":"Functions","text":"Modules = [OPS]\nPrivate = false","category":"page"},{"location":"funcs/#OPS.OPSAlgorithm","page":"Functions","title":"OPS.OPSAlgorithm","text":"OPSAlgorithm{T<:Float64}\n\nA CORN object that contains the weights of the portfolio, Sₙ, and the number of assets.\n\nFields\n\nn_asset::Int: Number of assets in the portfolio.\nb::Matrix{T}: Weights of the created portfolios.\nbudgets::Vector{T}: Budget during the investment horizon.\ntype::String: The type of CORN algorithm. It can be either \"CORN-U\" or \"CORN-K\".\n\nThe formula for calculating the cumulative return of the portfolio is as follows:\n\nS_n = S_0prodlimits_t = 1^T leftlangle b_tx_t rightrangle \n\nwhere S₀ is the initial budget, n is the investment horizon, b_t is the vector of weights of the period t, and x_t is the relative price of the t-th period.\n\n\n\n\n\n","category":"type"},{"location":"funcs/#OPS.OPSMetrics","page":"Functions","title":"OPS.OPSMetrics","text":"OPSMetrics(Sn::Vector{T}, APY::T, Ann_Sharpe::T, MDD::T, Calmar::T) where {T<:Float64}\n\nA struct to store the metrics of the OPS algorithm.\n\nFields\n\nSn::Vector{T}: the cumulative return of investment during the investment period.\nAPY::T: the Annual Percentage Yield (APY) of investment.\nAnn_Std::T: the Annualized Standard Deviation (σₚ) of investment.\nAnn_Sharpe::T: the Annualized Sharpe Ratio (SR) of investment.\nMDD::T: the Maximum Drawdown (MDD) of investment.\nCalmar::T: the Calmar Ratio of investment.\n\n\n\n\n\n","category":"type"},{"location":"funcs/#OPS.OPSMetrics-Union{Tuple{S}, Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where {T<:Float64, S<:Int64}","page":"Functions","title":"OPS.OPSMetrics","text":"OPSMetrics(\n  weights::Matrix{T},\n  rel_pr::Matrix{T};\n  init_inv::T=1.,\n  Rf::T=0.02\n  dpy::S=252\n) where {T<:Float64, S<:Int}\n\nCalculate the metrics of an OPS algorithm.\n\nArguments\n\nweights::Matrix{T}: the weights of the portfolio.\nrel_pr::Matrix{T}: the relative price of the stocks.\ninit_inv::T=1: the initial investment.\nRf::T=0.02: the risk-free rate of return.\ndpy::S=252: the number of days in a year.\n\nwarning: Warning\nThe size of weights and rel_pr must be (n_stocks, n_periods).\n\nnote: Note\nIf size(rel_pr, 2) is greater than size(weights, 2), then the last size(weights, 2) columns of rel_pr will be used.\n\nReturns\n\n::OPSMetrics: the metrics of the OPS algorithm.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OPS.APY-Union{Tuple{S}, Tuple{Float64, S}} where S<:Int64","page":"Functions","title":"OPS.APY","text":"APY(Sn::Float64, n_periods::S; dpy::S=252) where S<:Int\n\nCalculate the Annual Percentage Yield (APY) of investment.\n\nArguments\n\nSn::Float64: the cumulative return of investment.\nn_periods::S: the number investment periods.\ndpy::S=252: the number of days in a year.\n\nReturns\n\n::Float64: the APY of investment.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OPS.Ann_Sharpe-Union{Tuple{T}, Tuple{T, T, T}} where T<:Float64","page":"Functions","title":"OPS.Ann_Sharpe","text":"Ann_Sharpe(APY::T, Rf::T, sigma_prtf::T) where T<:Float64\n\nCalculate the Annualized Sharpe Ratio of investment.\n\nArguments\n\nAPY::T: the APY of investment.\nRf::T: the risk-free rate of return.\nsigmaprtf::T: the standard deviation of the portfolio ``\\sigmap``.\n\nReturns\n\n::Float64: the Annualized Sharpe Ratio of investment.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OPS.CORNK-Union{Tuple{T}, Tuple{Matrix{Float64}, T, T, T, T}} where T<:Int64","page":"Functions","title":"OPS.CORNK","text":"CORNK(\n  adj_close::Matrix{Float64},\n  horizon::T,\n  k::T,\n  w::T,\n  p::T;\n  init_budg=1\n) where T<:Int\n\nRun CORN-K algorithm.\n\nArguments\n\nadj_close::Matrix{Float64}: Adjusted close prices of assets.\nhorizon::T: The number of periods to invest.\nk::T: The number of top experts to be selected.\nw::T: maximum length of time window to be examined.\np::T: maximum number of correlation coefficient thresholds.\ninit_budg=1: The initial budget for investment.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, budgets, alg): An object of type OPSAlgorithm.\n\nReference\n\n[1] CORN: Correlation-driven nonparametric learning approach for portfolio selection\n\nExamples\n\njulia> using OPS\n\njulia> adj_close = rand(5, 100);\n\njulia> model = CORNK(adj_close, 10, 3, 5, 3);\n\njulia> model.budgets\n11-element Vector{Float64}:\n    1.0\n    0.9245593797606169\n    1.2661989745602595\n    1.9287471593384662\n   13.920366533737552\n   34.95772014332745\n   37.275738278098444\n  151.14402066138192\n  186.3883800018429\n  208.7067031619314\n 8593.328131580158\n\njulia> model.type\n\"CORN-K\"\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OPS.CORNU-Union{Tuple{M}, Tuple{T}, Tuple{Matrix{T}, M, M}} where {T<:Float64, M<:Int64}","page":"Functions","title":"OPS.CORNU","text":"CORNU(\n  adj_close::Matrix{T},\n  horizon::M,\n  w::M,\n  rho::T;\n  init_budg=1\n) where {T<:Float64, M<:Int}\n\nRun CORN-U algorithm.\n\nArguments\n\nadj_close::Matrix{T}: Adjusted close prices of assets.\nhorizon::M: The number of periods to invest.\nw::M: maximum length of time window to be examined.\nrho::T: The correlation coefficient threshold.\ninit_budg=1: The initial budget for investment.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, budgets, alg): An object of type OPSAlgorithm.\n\nReference\n\n[1] CORN: Correlation-driven nonparametric learning approach for portfolio selection\n\nExamples\n\njulia> using OPS\n\njulia> adj_close = rand(5, 100);\n\njulia> model = CORNU(adj_close, 10, 5, 0.5);\n\njulia> model.budgets\n11-element Vector{Float64}:\n   1.0\n   2.712148607094074\n   3.9049548118405513\n   9.079571226009149\n  15.550023500498401\n  60.15172309699462\n  32.32354281989587\n 110.76798827023994\n 148.34814522333753\n 206.383234246206\n 463.69154027959627\n\njulia> model.type\n\"CORN-U\"\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OPS.CRP-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Float64","page":"Functions","title":"OPS.CRP","text":"CRP(adj_close::Matrix{T}, init_budg=1) where T<:Float64\n\nRun Constant Rebalanced Portfolio (CRP) algorithm.\n\nArguments\n\nadj_close::Matrix{Float64}: adjusted close prices\ninit_budg::Float64: initial budget\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, budgets, alg): OPSAlgorithm object\n\nReferences\n\n[1] Universal Portfolios\n\nExample\n\njulia> typeof(adj_close), size(adj_close)\n(Matrix{Float64}, (3, 10))\n\njulia> crp = CRP(adj_close);\n\njulia> crp.b\n3×10 Matrix{Float64}:\n 0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333\n 0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333\n 0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333\n\njulia> sum(crp.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OPS.Calmar-Union{Tuple{T}, Tuple{T, T}} where T<:Float64","page":"Functions","title":"OPS.Calmar","text":"Calmar(APY::T, MDD::T) where T<:Float64\n\nCalculate the Calmar Ratio of investment.\n\nArguments\n\nAPY::T: the APY of investment.\nMDD::T: the MDD of investment.\n\nReturns\n\n::Float64: the Calmar Ratio of investment.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OPS.DRICORNK-Union{Tuple{M}, Tuple{T}, Tuple{Matrix{T}, Vector{T}, M, M, M, M}} where {T<:Float64, M<:Int64}","page":"Functions","title":"OPS.DRICORNK","text":"DRICORNK(\n  adj_close::Matrix{T},\n  adj_close_market::Vector{T},\n  horizon::M,\n  k::M,\n  w::M,\n  p::M;\n  lambda::T=1e-3,\n  init_budg=1\n) where {T<:Float64, M<:Int}\n\nRun the DRICORNK algorithm.\n\nArguments\n\nadj_close::Matrix{T}: A matrix of adjusted close prices of the assets.\nadj_close_market::Vector{T}: A vector of adjusted close prices of the market in the same period.\nhorizon::M: The investment horizon.\nk::M: The number of experts.\nw::M: maximum length of time window to be examined.\np::M: maximum number of correlation coefficient thresholds.\nlambda::T=1e-3: The regularization parameter.\ninit_budg=1: The initial budget for investment.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, budgets, alg): An object of type OPSAlgorithm.\n\nReference\n\n[1] DRICORN-K: A Dynamic RIsk CORrelation-driven Non-parametric Algorithm for Online Portfolio Selection\n\nExample\n\njulia> using OPS\n\njulia> stocks_adj, market_adj = rand(10, 100), rand(100);\n\njulia> dricornk = DRICORNK(stocks_adj, market_adj, 5, 2, 4, 3);\n\njulia> dricornk.budgets\n6-element Vector{Float64}:\n   1.0\n   3.473117165390519\n   5.68035943256069\n  16.98710435236131\n 108.58630004976507\n 323.6896116088503\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OPS.EG-Tuple{Matrix{Float64}}","page":"Functions","title":"OPS.EG","text":"EG(adj_close::Matrix{Float64}, init_budg=1., eta=0.05)\n\nExponential Gradient (EG) algorithm.\n\nCalculate the Exponential Gradient (EG) weights and budgets using the given historical prices and parameters and return an EG object.\n\nArguments\n\nadj_close::Matrix{Float64}: Historical adjusted close prices.\ninit_budg=1.: Initial budget.\neta=0.05: Learning rate.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, budgets, alg): OPSAlgorithm object.\n\nReferences\n\n[1] On-Line Portfolio Selection Using Multiplicative Updates](https://onlinelibrary.wiley.com/doi/10.1111/1467-9965.00058)\n\nExamples\n\njulia> typeof(adj_close), size(adj_close)\n(Matrix{Float64}, (3, 10))\n\njulia> eg = EG(adj_close);\n\njulia> eg.b\n3×10 Matrix{Float64}:\n 0.333333  0.333119  0.333296  0.333232  0.33327   0.333276  0.333201  0.333171  0.332832  0.332789\n 0.333333  0.333436  0.333274  0.333485  0.333481  0.333359  0.333564  0.333477  0.333669  0.333835\n 0.333333  0.333445  0.33343   0.333283  0.333249  0.333365  0.333234  0.333353  0.333499  0.333377\n\njulia> sum(eg.b, dims=1) .|> isapprox(1.0) |> all\ntrue\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OPS.MDD-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Float64","page":"Functions","title":"OPS.MDD","text":"MDD(Sn::Vector{T}) where T<:Float64\n\nCalculate the Maximum Drawdown (MDD) of investment.\n\nArguments\n\nSn::Vector{T}: the cumulative return of investment during the investment period.\n\nReturns\n\n::Float64: the MDD of investment.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OPS.RPRT-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Float64","page":"Functions","title":"OPS.RPRT","text":"RPRT(\n  adj_close::Matrix{T};\n  w::Int64=5,\n  init_budg::Int=1.,\n  theta::T=0.8,\n  epsilon=50\n) where T<:Float64\n\nRun RPRT algorithm.\n\nArguments\n\nadj_close::Matrix{T}: Adjusted close prices of assets.\nw::Int64=5: maximum length of time window to be examined.\ninit_budg::Int=1.: The initial budget for investment.\ntheta::T=0.8: The threshold for the relative price.\nepsilon=50: The threshold for the condition of the portfolio.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, budgets, alg): An object of type OPSAlgorithm.\n\nReference\n\n[1] Reweighted Price Relative Tracking System for Automatic Portfolio Optimization\n\nExamples\n\njulia> using OPS\n\njulia> typeof(adj_close), size(adj_close)\n(Matrix{Float64}, (3, 10))\n\njulia> rprt = RPRT(adj_close);\n\njulia> rprt.b\n3×10 Matrix{Float64}:\n 0.333333  0.333333  0.333333  0.333333  0.0       0.0369806  0.315476  0.382559  0.942964   0.678569\n 0.333333  0.333333  0.333333  0.333333  0.464174  0.694045   0.137325  0.392694  0.0313677  0.0\n 0.333333  0.333333  0.333333  0.333333  0.535826  0.268975   0.547199  0.224747  0.0256685  0.321431\n\njulia> sum(rprt.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OPS.Sn-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, Any}} where T<:Float64","page":"Functions","title":"OPS.Sn","text":"Sn(\n  rel_pr::AbstractMatrix{T},\n  w::AbstractMatrix{T},\n  init_budg\n) where T<:Float64\n\nCalculate the cumulative return of portfolio.\n\nArguments\n\nrel_pr::AbstractMatrix{T}: The relative prices of the assets in each period.\nw::AbstractMatrix{T}: The weights of the assets in each period.\ninit_budg: The initial budget.\n\nwarning: Beware!\nrel_pr and w should be a matrix of size n_assets × n_periods.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OPS.Sn-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T<:Float64","page":"Functions","title":"OPS.Sn","text":"Sn(weights::Matrix{T}, rel_pr::Matrix{T}; init_inv::T=1.) where T<:Float64\n\nCalculate the cumulative return of investment during a period of time.\n\nArguments\n\nweights::Matrix{T}: the weights of the portfolio.\nrel_pr::Matrix{T}: the relative price of the stocks.\ninit_inv::T=1: the initial investment.\n\nwarning: Warning\nThe size of weights and rel_pr must be (n_stocks, n_periods).\n\nnote: Note\nIf size(rel_pr, 2) is greater than size(weights, 2), then the last size(weights, 2) columns of rel_pr will be used.\n\nReturns\n\nall_sn::Vector{T}: the cumulative return of investment during the investment period.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OPS.UP-Tuple{Matrix{Float64}}","page":"Functions","title":"OPS.UP","text":"UP(\n  adj_close::Matrix{Float64};\n  init_budg=1.,\n  eval_points::Int=10^4,\n  leverage=1.,\n  frequency::Int=1,\n  min_history::Int=0\n)\n\nUniversal Portfolio (UP) algorithm.\n\nCalculate the Universal Portfolio (UP) weights and budgets using the given historical prices and parameters.\n\nArguments\n\nadj_close::Matrix{Float64}: Historical adjusted close prices.\ninit_budg=1.: Initial budget.\neval_points::Int=10^4: Number of evaluation points.\nleverage=1.: Leverage value.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, budgets, alg): OPSAlgorithm object.\n\nReferences\n\n[1] Universal Portfolios\n\nExamples\n\njulia> typeof(adj_close), size(adj_close)\n(Matrix{Float64}, (3, 30))\n\njulia> up = UP(adj_close);\n\njulia> up.b\n3×30 Matrix{Float64}:\n 0.333333  0.331149  0.33204   0.331716  …  0.326788  0.325788  0.325829  0.326222\n 0.333333  0.336058  0.335239  0.336304     0.343405  0.342161  0.342283  0.340693\n 0.333333  0.332793  0.33272   0.331981     0.329807  0.332051  0.331888  0.333086\n\njulia> sum(up.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\n\n\n\n\n","category":"method"},{"location":"FL/#Follow-the-Loser-(FL)","page":"Follow the Loser","title":"Follow the Loser (FL)","text":"","category":"section"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"follow the loser has been introduced by Borodin and Vincent (2004) in which, the investment weight is transferred from a stock provided a better performance in the past to a stock with unfavorable performance, since the approach considers that a stock with an undesirable performance in the past is able to provide a desirable return in the future. In this package, the following FL strategie is implemented so far:","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Reweighted Price Relative Tracking System for Automatic Portfolio Optimization","category":"page"},{"location":"FL/#Reweighted-Price-Relative-Tracking-System-for-Automatic-Portfolio-Optimization-(RPRT)","page":"Follow the Loser","title":"Reweighted Price Relative Tracking System for Automatic Portfolio Optimization (RPRT)","text":"","category":"section"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"RPRT is a FL strategy proposed by Lai et al. (2018). In the price prediction stage, it automatically assigns separate weights to the price relative predictions according to each asset’s performance, and these weights will also be automatically updated. In the portfolio optimizing stage, a novel tracking system with a generalized increasing factor is proposed to maximize the future wealth of next period. An efficient algorithm is designed to solve the portfolio optimization objective, which is applicable to large-scale and time-limited situations. Extensive experiments on six benchmark datasets from real financial markets with diverse assets and different time spans are conducted. There are claims that RPRT outperforms other state-of-the-art systems in cumulative wealth, mean excess return, annual percentage yield, and some typical risk metrics. Moreover, it can withstand considerable transaction costs and runs fast. It indicates that RPRT is an effective and efficient online portfolio selection system.","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"See RPRT.","category":"page"},{"location":"FW/#Follow-the-Winner-(FW)","page":"Follow the Winner","title":"Follow the Winner (FW)","text":"","category":"section"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Follow the Winner (FW) strategies believe that the best performing asset in the past will continue to perform well in the future. The following FW strategies are implemented in this package so far:","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Universal Portfolio (UP)\nExponential Gradient (EG)","category":"page"},{"location":"FW/#Universal-Portfolio","page":"Follow the Winner","title":"Universal Portfolio","text":"","category":"section"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Universal Portfolio (UP) is a FW strategy proposed by Cover (1991). UP aims to maximize the cumulative reurn of the portfolio during the investment horizon.","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"See UP.","category":"page"},{"location":"FW/#Exponential-Gradient","page":"Follow the Winner","title":"Exponential Gradient","text":"","category":"section"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Exponential Gradient (EG) is a FW strategy proposed by Helmbold et al. (1998). Authors claim that EG can achieve almost the same wealth as the best constantrebalanced portfolio (BCRP) determined in hindsight from the actual market outcomes.","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"See EG.","category":"page"},{"location":"benchmark/#Benchmark-Strategies","page":"Benchmark","title":"Benchmark Strategies","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Some strategies in the context of online portfolio selection are considered as benchmark strategies. The simplest benchmark strategy is the Buy and Hold (BH) strategy which is called as the market strategy. The BAH model invests equally in m assets at the beginning and remains unchanged during the next periods, thus the weights of assets change passively with their price variations. A special BAH model, the Best-Stock (BS), invests all the capital into the best asset over the periods which is an optimal BAH in hindsight. Overall, the Benchmark portfolio selection models are quite simple because they do not adopt complex or sophisticated techniques via statistics and machine learning to explore the patterns within the data. Thus they are often taken as the baselines for performance comparison with new designed models. Another benchmark strategy is the Constant Rebalanced Portfolio (CRP) which assigns a fixed weight to each asset throughout a given period.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"See CRP.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = OPS DocTestSetup  = quote     using OPS end","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n# Introduction\nOnline Portfolio Selection (OPS) strategies are trading algorithms that sequentially allocate capital among a group of assets to maximize the final returns of the investment. It is a fundamental problem in computational finance that has been extensively studied across several research communities, including finance, statistics, artificial intelligence, machine learning, and data mining. From an online machine learning perspective, it is formulated as a sequential decision problem and there are a variety of state-of-the-art approaches that have been developed to solve it. These approaches are grouped into several major categories, including benchmarks, “Follow-the-Winner” approaches, “Follow-the-Loser” approaches, “Pattern-Matching” based approaches, and \"Meta-Learning\" Algorithms[1](https://arxiv.org/abs/1212.2129).\nThis package provides an efficient implementation of OPS algorithms. The algorithms are implemented in Julia in a fully type-stable manner. All the algorithms return an object of type `OPSAlgorithm` which can be used to query the portfolio weights, number of assets,  cumulative return of portfolio, and the name of the algorithm. Seven algorithms are implemented so far and more will be added in the future. The available algorithms are:\n1. Constant Rebalanced Portfolio (CRP)\n2. Exponential Gradient (EG)\n3. Universal Portfolio (UP)\n4. Correlation-driven Nonparametric Learning\n    4.1. CORN-U\n    4.2. CORN-K\n5. Dynamic RIsk CORrelation-driven Non-parametric\n\n# Installation\nThe dev version of the package can be installed by running the following command in the Julia REPL after pressing `]`:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia pkg> add https://github.com/shayandavoodii/OPS.jl.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n# Quick Start\nThe package can be imported by running the following command in the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia julia> using OPS","category":"page"},{"location":"","page":"Home","title":"Home","text":"One can perform several strategies on a given dataset and analyse and compare the results. The following code snippet shows how to perform the strategies on a given dataset and compare the results:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia","category":"page"},{"location":"#read-adjusted-close-prices","page":"Home","title":"read adjusted close prices","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> pr = CSV.read(\"data\\sp500.csv\", DataFrame) |> Matrix |> permutedims;","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> pr = pr[2:end, :];","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> market_pr = pr[1, :];","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> size(pr) (24, 1276)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The dataset contains the adjusted close prices of 24 stocks in the S&P 500 within 1276 trading days. Now, suppose we want to perform the strategies on the last 50 days of the dataset with default arguments:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia julia> crp = CRP(pr[:, end-50:end]);","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> eg = EG(pr[:, end-50:end]);","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> up = UP(pr[:, end-50:end]);","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> rprt = RPRT(pr[:, end-50:end]);","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> corn_u = CORNU(pr, 50, 3);","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> corn_k = CORNK(pr, 50, 3, 2, 2);","category":"page"},{"location":"","page":"Home","title":"Home","text":"juila> drcornk = DRICORNK(pr, marketpr, 50, 3, 2, 2);","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now, let's plot the trend of daily cumulative budgets of each algorithm:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia julia> using Plots","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> plot(             [crp.budgets, eg.budgets, up.budgets, rprt.budgets,             cornu.budgets, cornk.budgets, drcorn_k.budgets],              label = [\"CRP\" \"EG\" \"UP\" \"RPRT\" \"CORN-U\" \"CORN-K\" \"DRICORN-K\"],              xlabel = \"Day\", ylabel = \"Cumulative return\", legend = :topleft        )","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"@raw html <img src=\"assets/cumulative_budgets.png\" width=\"70%\">","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nThe plot shows that the cumulative return of CORN-K outperforms the other algorithms almost all the time. Note that the initial investment for all of the algorithms is set to 1 (this can be modified by setting the keyword argument `init_budg` for each algorithm).Now, let's investigate the performance of the algorithms in terms of some of prominent performance metrics:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia julia> rel_pr = pr[:, 2:end] ./ pr[:, 1:end-1];","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> allmetrics = OPSMetrics.([crp.b, eg.b, up.b, rprt.b, cornu.b, cornk.b, drcornk.b], Ref(rel_pr));","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now, one can embed the metrics in a DataFrame and compare the performance of the algorithms with respect to each other:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia julia> using DataFrames","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> nmodels = length(all_metrics);","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> compalgs = DataFrame(            Algorithm = [\"CRP\", \"EG\", \"UP\", \"RPRT\", \"CORN-U\", \"CORN-K\", \"DRICORN-K\"],            APY = [allmetrics[i].APY for i = 1:nmodels],            AnnSharpe = [allmetrics[i].AnnSharpe for i = 1:nmodels],            AnnStd = [allmetrics[i].AnnStd for i = 1:nmodels],            Calmar = [allmetrics[i].Calmar for i = 1:nmodels],            MDD = [allmetrics[i].MDD for i = 1:nmodels],        ) 7×6 DataFrame  Row │ Algorithm  APY        AnnSharpe  AnnStd   Calmar    MDD             │ String     Float64    Float64     Float64   Float64   Float64    ─────┼─────────────────────────────────────────────────────────────────    1 │ CRP        -0.289228   -1.41586   0.218403  -2.96123  0.0976717    2 │ EG         -0.287809   -1.409     0.218459  -2.95441  0.0974169    3 │ UP         -0.288415   -1.41139   0.218519  -2.95588  0.0975733    4 │ RPRT       -0.996266   -4.70081   0.21619   -1.4582   0.683216    5 │ CORN-U     -0.126009   -0.505762  0.288691  -1.25383  0.100499    6 │ CORN-K      0.826495    2.48378   0.324705  17.688    0.0467263    7 │ DRICORN-K  -0.248369   -1.20917   0.221946  -2.54495  0.0975929 ``Thecomp_algs` shows that CORN-K outperforms the other algorithms in terms of annualizeed percentage yield (APY), annualized Sharpe ratio, Calmar ratio, and maximum drawdown (MDD). However, the annualized standard deviation of CORN-K is higher than the other algorithms in this dataset.","category":"page"}]
}
