var documenterSearchIndex = {"docs":
[{"location":"PM/#Pattern-matching-algorithms","page":"Pattern-Matching","title":"Pattern-matching algorithms","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Pattern-matching algorithms are one of most popular algorithms in the context of online portfolio selection. The main idea behind these algorithms is to find a pattern in the past price data and use it to predict the future price. These strategies are in consensus with technical analysts perspective. Technical analysts believe that the historical patterns in the price data will repeat in the future. The following pattern-matching algorithms are implemented in this package so far:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Correlation-driven Nonparametric Learning  1.1. CORN-U  1.2. CORN-K\nDynamic RIsk CORrelation-driven Non-parametric","category":"page"},{"location":"PM/#Correlation-driven-Nonparametric-Learning","page":"Pattern-Matching","title":"Correlation-driven Nonparametric Learning","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Correlation-driven Nonparametric Learning (CORN) is a pattern-matching algorithm proposed by Borodin et al. (2010). CORN utilizes the correlation as the similarity measure between time windows. Additionally, CORN defines several experts to construct portfolios. For each trading day, CORN combines the portfolios of the experts to construct the final portfolio. This is where CORN-K and CORN-U differ. CORN-K uses K best experts (based on their performance on historical data) to construct the final portfolio. On the other hand, CORN-U uses all the experts and uniformly combines their portfolios to construct the final portfolio. See cornu and cornk. ","category":"page"},{"location":"PM/#Dynamic-RIsk-CORrelation-driven-Non-parametric","page":"Pattern-Matching","title":"Dynamic RIsk CORrelation-driven Non-parametric","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Dynamic RIsk CORrelation-driven Non-parametric (DRICORN) follows the same idea as CORN-K. However, DRICORN considers the beta of portfolio as a measure of risk in the portfolio optimization. Furthermore, they consider the recent trend of market in order to take advantage of positive risks, and avoid negative risks.","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"See dricornk.","category":"page"},{"location":"fetchdata/#Fetch-Data","page":"Fetch Financial Data","title":"Fetch Data","text":"","category":"section"},{"location":"fetchdata/","page":"Fetch Financial Data","title":"Fetch Financial Data","text":"For fetching the data, one can use the YFinance.jl package:","category":"page"},{"location":"fetchdata/","page":"Fetch Financial Data","title":"Fetch Financial Data","text":"julia> using YFinance, DataFrames\n\njulia> tickers = [\"MMM\", \"CSCO\", \"IBM\", \"INTC\", \"XOM\"];\n\njulia> startdt, enddt = \"2023-04-01\", \"2023-04-27\";\n\njulia> querry = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"adjclose\"] for ticker in tickers];\n\njulia> prices = reduce(hcat, querry);\n\n# Let's make a DataFrame out of it for better visualization of the data\njulia> df = DataFrame(prices, tickers);\n\njulia> first(df, 3)\n3×5 DataFrame\n Row │ MMM      CSCO     IBM      INTC     XOM     \n     │ Float64  Float64  Float64  Float64  Float64 \n─────┼─────────────────────────────────────────────\n   1 │  104.57    51.92   132.06    32.89   116.13 \n   2 │  102.25    51.82   131.6     33.1    115.02 \n   3 │  102.29    51.82   132.14    32.83   116.99 ","category":"page"},{"location":"fetchdata/","page":"Fetch Financial Data","title":"Fetch Financial Data","text":"The given data in each example throughout this documentation has been collected using the above code. ","category":"page"},{"location":"funcs/#API","page":"Functions","title":"API","text":"","category":"section"},{"location":"funcs/","page":"Functions","title":"Functions","text":"Modules = [OnlinePortfolioSelection]\nPrivate = false\nOrder   = [:function, :type]","category":"page"},{"location":"funcs/#OnlinePortfolioSelection.ann_sharpe-Union{Tuple{T}, Tuple{T, T, T}} where T<:Float64","page":"Functions","title":"OnlinePortfolioSelection.ann_sharpe","text":"ann_sharpe(APY::T, Rf::T, sigma_prtf::T) where T<:Float64\n\nCalculate the Annualized Sharpe Ratio of investment.\n\nArguments\n\nAPY::T: the APY of investment.\nRf::T: the risk-free rate of return.\nsigmaprtf::T: the standard deviation of the portfolio ``\\sigmap``.\n\nReturns\n\n::Float64: the Annualized Sharpe Ratio of investment.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.ann_std-Tuple{Vector{Float64}}","page":"Functions","title":"OnlinePortfolioSelection.ann_std","text":"ann_std(cum_ret::Vector{Float64}; dpy)\n\nCalculate the Annualized Standard Deviation (σₚ) of portfolio.\n\nArguments\n\ncum_ret::Vector{Float64}: the cumulative return of investment during the investment period.\ndpy: the number of days in a year.\n\nReturns\n\n::Float64: the Annualized Standard Deviation (σₚ) of portfolio.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.apy-Union{Tuple{S}, Tuple{Float64, S}} where S<:Int64","page":"Functions","title":"OnlinePortfolioSelection.apy","text":"apy(Sn::Float64, n_periods::S; dpy::S=252) where S<:Int\n\nCalculate the Annual Percentage Yield (APY) of investment.\n\nArguments\n\nSn::Float64: the cumulative return of investment.\nn_periods::S: the number investment periods.\ndpy::S=252: the number of days in a year.\n\nReturns\n\n::Float64: the APY of investment.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.calmar-Union{Tuple{T}, Tuple{T, T}} where T<:Float64","page":"Functions","title":"OnlinePortfolioSelection.calmar","text":"calmar(APY::T, MDD::T) where T<:Float64\n\nCalculate the Calmar Ratio of investment.\n\nArguments\n\nAPY::T: the APY of investment.\nMDD::T: the MDD of investment.\n\nReturns\n\n::Float64: the Calmar Ratio of investment.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.cornk-Union{Tuple{T}, Tuple{Matrix{Float64}, T, T, T, T}} where T<:Int64","page":"Functions","title":"OnlinePortfolioSelection.cornk","text":"cornk(\n  adj_close::Matrix{Float64},\n  horizon::T,\n  k::T,\n  w::T,\n  p::T;\n  init_budg=1\n) where T<:Int\n\nRun CORN-K algorithm.\n\nArguments\n\nadj_close::Matrix{Float64}: Adjusted close prices of assets.\nhorizon::T: The number of periods to invest.\nk::T: The number of top experts to be selected.\nw::T: maximum length of time window to be examined.\np::T: maximum number of correlation coefficient thresholds.\ninit_budg=1: The initial budget for investment.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): An object of type OPSAlgorithm.\n\nReference\n\n[1] CORN: Correlation-driven nonparametric learning approach for portfolio selection\n\nExamples\n\njulia> using OPS\n\njulia> adj_close = rand(5, 100);\n\njulia> model = cornk(adj_close, 10, 3, 5, 3);\n\njulia> model.type\n\"CORN-K\"\n\njulia> sum(model.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.cornu-Union{Tuple{M}, Tuple{T}, Tuple{Matrix{T}, M, M}} where {T<:Float64, M<:Int64}","page":"Functions","title":"OnlinePortfolioSelection.cornu","text":"cornu(\n  adj_close::Matrix{T},\n  horizon::M,\n  w::M;\n  rho::T,\n  init_budg=1\n) where {T<:Float64, M<:Int}\n\nRun CORN-U algorithm.\n\nArguments\n\nadj_close::Matrix{T}: Adjusted close prices of assets.\nhorizon::M: The number of periods to invest.\nw::M: maximum length of time window to be examined.\nrho::T=0.2: The correlation coefficient threshold.\ninit_budg=1: The initial budget for investment.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): An object of type OPSAlgorithm.\n\nReference\n\n[1] CORN: Correlation-driven nonparametric learning approach for portfolio selection\n\nExamples\n\njulia> using OnlinePortfolioSelection\n\njulia> adj_close = rand(5, 100);\n\njulia> model = cornu(adj_close, 10, 5, 0.5);\n\njulia> model.type\n\"CORN-U\"\n\njulia> sum(model.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.crp-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Float64","page":"Functions","title":"OnlinePortfolioSelection.crp","text":"crp(adj_close::Matrix{T}, init_budg=1) where T<:Float64\n\nRun Constant Rebalanced Portfolio (CRP) algorithm.\n\nArguments\n\nadj_close::Matrix{Float64}: adjusted close prices\ninit_budg::Float64: initial budget\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): OPSAlgorithm object\n\nReferences\n\n[1] Universal Portfolios\n\nExample\n\njulia> using OnlinePortfolioSelection\n\njulia> typeof(adj_close), size(adj_close)\n(Matrix{Float64}, (3, 10))\n\njulia> m_crp = crp(adj_close);\n\njulia> m_crp.b\n3×10 Matrix{Float64}:\n 0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333\n 0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333\n 0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333\n\njulia> sum(m_crp.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.dricornk-Union{Tuple{M}, Tuple{T}, Tuple{Matrix{T}, Vector{T}, M, M, M, M}} where {T<:Float64, M<:Int64}","page":"Functions","title":"OnlinePortfolioSelection.dricornk","text":"dricornk(\n  adj_close::Matrix{T},\n  adj_close_market::Vector{T},\n  horizon::M,\n  k::M,\n  w::M,\n  p::M;\n  lambda::T=1e-3,\n  init_budg=1\n) where {T<:Float64, M<:Int}\n\nRun the DRICORNK algorithm.\n\nArguments\n\nadj_close::Matrix{T}: A matrix of adjusted close prices of the assets.\nadj_close_market::Vector{T}: A vector of adjusted close prices of the market in the same period.\nhorizon::M: The investment horizon.\nk::M: The number of experts.\nw::M: maximum length of time window to be examined.\np::M: maximum number of correlation coefficient thresholds.\nlambda::T=1e-3: The regularization parameter.\ninit_budg=1: The initial budget for investment.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): An object of type OPSAlgorithm.\n\nReference\n\n[1] DRICORN-K: A Dynamic RIsk CORrelation-driven Non-parametric Algorithm for Online Portfolio Selection\n\nExample\n\njulia> using OnlinePortfolioSelection\n\njulia> stocks_adj, market_adj = rand(10, 100), rand(100);\n\njulia> m_dricornk = dricornk(stocks_adj, market_adj, 5, 2, 4, 3);\n\njulia> sum(m_dricornk.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.eg-Tuple{Matrix{Float64}}","page":"Functions","title":"OnlinePortfolioSelection.eg","text":"eg(adj_close::Matrix{Float64}, init_budg=1., eta=0.05)\n\nExponential Gradient (EG) algorithm.\n\nCalculate the Exponential Gradient (EG) weights and budgets using the given historical prices and parameters and return an EG object.\n\nArguments\n\nadj_close::Matrix{Float64}: Historical adjusted close prices.\ninit_budg=1.: Initial budget.\neta=0.05: Learning rate.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): OPSAlgorithm object.\n\nReferences\n\n[1] On-Line Portfolio Selection Using Multiplicative Updates](https://onlinelibrary.wiley.com/doi/10.1111/1467-9965.00058)\n\nExamples\n\njulia> using OnlinePortfolioSelection\n\njulia> typeof(adj_close), size(adj_close)\n(Matrix{Float64}, (3, 10))\n\njulia> m_eg = eg(adj_close);\n\njulia> m_eg.b\n3×10 Matrix{Float64}:\n 0.333333  0.333119  0.333296  0.333232  0.33327   0.333276  0.333201  0.333171  0.332832  0.332789\n 0.333333  0.333436  0.333274  0.333485  0.333481  0.333359  0.333564  0.333477  0.333669  0.333835\n 0.333333  0.333445  0.33343   0.333283  0.333249  0.333365  0.333234  0.333353  0.333499  0.333377\n\njulia> sum(m_eg.b, dims=1) .|> isapprox(1.0) |> all\ntrue\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.mdd-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Float64","page":"Functions","title":"OnlinePortfolioSelection.mdd","text":"mdd(Sn::Vector{T}) where T<:Float64\n\nCalculate the Maximum Drawdown (MDD) of investment.\n\nArguments\n\nSn::Vector{T}: the cumulative return of investment during the investment period.\n\nReturns\n\n::Float64: the MDD of investment.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.sn-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T<:Float64","page":"Functions","title":"OnlinePortfolioSelection.sn","text":"sn(weights::Matrix{T}, rel_pr::Matrix{T}; init_inv::T=1.) where T<:Float64\n\nCalculate the cumulative return of investment during a period of time.\n\nArguments\n\nweights::Matrix{T}: the weights of the portfolio.\nrel_pr::Matrix{T}: the relative price of the stocks.\ninit_inv::T=1: the initial investment.\n\nwarning: Warning\nThe size of weights and rel_pr must be (n_stocks, n_periods).\n\nnote: Note\nIf size(rel_pr, 2) is greater than size(weights, 2), then the last size(weights, 2) columns of rel_pr will be used.\n\nReturns\n\nall_sn::Vector{T}: the cumulative return of investment during the investment period.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.up-Tuple{Matrix{Float64}}","page":"Functions","title":"OnlinePortfolioSelection.up","text":"up(\n  adj_close::Matrix{Float64};\n  init_budg=1.,\n  eval_points::Int=10^4,\n  leverage=1.,\n  frequency::Int=1,\n  min_history::Int=0\n)\n\nUniversal Portfolio (UP) algorithm.\n\nCalculate the Universal Portfolio (UP) weights and budgets using the given historical prices and parameters.\n\nArguments\n\nadj_close::Matrix{Float64}: Historical adjusted close prices.\ninit_budg=1.: Initial budget.\neval_points::Int=10^4: Number of evaluation points.\nleverage=1.: Leverage value.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): OPSAlgorithm object.\n\nReferences\n\n[1] Universal Portfolios\n\nExamples\n\njulia> using OnlinePortfolioSelection\n\njulia> typeof(adj_close), size(adj_close)\n(Matrix{Float64}, (3, 30))\n\njulia> m_up = up(adj_close);\n\njulia> m_up.b\n3×30 Matrix{Float64}:\n 0.333333  0.331149  0.33204   0.331716  …  0.326788  0.325788  0.325829  0.326222\n 0.333333  0.336058  0.335239  0.336304     0.343405  0.342161  0.342283  0.340693\n 0.333333  0.332793  0.33272   0.331981     0.329807  0.332051  0.331888  0.333086\n\njulia> sum(m_up.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.OPSAlgorithm","page":"Functions","title":"OnlinePortfolioSelection.OPSAlgorithm","text":"OPSAlgorithm{T<:Float64}\n\nA OPSAlgorithm object that contains the result of running the algorithm.\n\nFields\n\nn_asset::Int: Number of assets in the portfolio.\nb::Matrix{T}: Weights of the created portfolios.\nalg::String: Name of the algorithm.\n\nThe formula for calculating the cumulative return of the portfolio is as follows:\n\nS_n = S_0prodlimits_t = 1^T leftlangle b_tx_t rightrangle \n\nwhere S₀ is the initial budget, n is the investment horizon, b_t is the vector of weights of the period t, and x_t is the relative price of the t-th period.\n\n\n\n\n\n","category":"type"},{"location":"funcs/#OnlinePortfolioSelection.OPSMetrics","page":"Functions","title":"OnlinePortfolioSelection.OPSMetrics","text":"OPSMetrics(Sn::Vector{T}, APY::T, Ann_Sharpe::T, MDD::T, Calmar::T) where {T<:Float64}\n\nA struct to store the metrics of the OPS algorithm.\n\nFields\n\nSn::Vector{T}: the cumulative return of investment during the investment period.\nAPY::T: the Annual Percentage Yield (APY) of investment.\nAnn_Std::T: the Annualized Standard Deviation (σₚ) of investment.\nAnn_Sharpe::T: the Annualized Sharpe Ratio (SR) of investment.\nMDD::T: the Maximum Drawdown (MDD) of investment.\nCalmar::T: the Calmar Ratio of investment.\n\n\n\n\n\n","category":"type"},{"location":"funcs/#OnlinePortfolioSelection.OPSMetrics-Union{Tuple{S}, Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where {T<:Float64, S<:Int64}","page":"Functions","title":"OnlinePortfolioSelection.OPSMetrics","text":"OPSMetrics(\n  weights::Matrix{T},\n  rel_pr::Matrix{T};\n  init_inv::T=1.,\n  Rf::T=0.02\n  dpy::S=252\n) where {T<:Float64, S<:Int}\n\nCalculate the metrics of an OPS algorithm.\n\nArguments\n\nweights::Matrix{T}: the weights of the portfolio.\nrel_pr::Matrix{T}: the relative price of the stocks.\ninit_inv::T=1: the initial investment.\nRf::T=0.02: the risk-free rate of return.\ndpy::S=252: the number of days in a year.\n\nwarning: Warning\nThe size of weights and rel_pr must be (n_stocks, n_periods).\n\nnote: Note\nIf size(rel_pr, 2) is greater than size(weights, 2), then the last size(weights, 2) columns of rel_pr will be used.\n\nReturns\n\n::OPSMetrics: the metrics of the OPS algorithm.\n\n\n\n\n\n","category":"method"},{"location":"FL/#Follow-the-Loser-(FL)","page":"Follow the Loser (FL)","title":"Follow the Loser (FL)","text":"","category":"section"},{"location":"FL/","page":"Follow the Loser (FL)","title":"Follow the Loser (FL)","text":"follow the loser has been introduced by Borodin and Vincent (2004) in which, the investment weight is transferred from a stock provided a better performance in the past to a stock with unfavorable performance, since the approach considers that a stock with an undesirable performance in the past is able to provide a desirable return in the future. In this package, the following FL strategie is implemented so far:","category":"page"},{"location":"FL/","page":"Follow the Loser (FL)","title":"Follow the Loser (FL)","text":"Reweighted Price Relative Tracking System for Automatic Portfolio Optimization","category":"page"},{"location":"FL/#Reweighted-Price-Relative-Tracking-System-for-Automatic-Portfolio-Optimization-(RPRT)","page":"Follow the Loser (FL)","title":"Reweighted Price Relative Tracking System for Automatic Portfolio Optimization (RPRT)","text":"","category":"section"},{"location":"FL/","page":"Follow the Loser (FL)","title":"Follow the Loser (FL)","text":"RPRT is a FL strategy proposed by Lai et al. (2018). In the price prediction stage, it automatically assigns separate weights to the price relative predictions according to each asset’s performance, and these weights will also be automatically updated. In the portfolio optimizing stage, a novel tracking system with a generalized increasing factor is proposed to maximize the future wealth of next period. An efficient algorithm is designed to solve the portfolio optimization objective, which is applicable to large-scale and time-limited situations. Extensive experiments on six benchmark datasets from real financial markets with diverse assets and different time spans are conducted. There are claims that RPRT outperforms other state-of-the-art systems in cumulative wealth, mean excess return, annual percentage yield, and some typical risk metrics. Moreover, it can withstand considerable transaction costs and runs fast. It indicates that RPRT is an effective and efficient online portfolio selection system.","category":"page"},{"location":"FL/","page":"Follow the Loser (FL)","title":"Follow the Loser (FL)","text":"See RPRT.","category":"page"},{"location":"FW/#Follow-the-Winner-(FW)","page":"Follow the Winner","title":"Follow the Winner (FW)","text":"","category":"section"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Follow the Winner (FW) strategies believe that the best performing asset in the past will continue to perform well in the future. The following FW strategies are implemented in this package so far:","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Universal Portfolio (UP)\nExponential Gradient (EG)","category":"page"},{"location":"FW/#Universal-Portfolio","page":"Follow the Winner","title":"Universal Portfolio","text":"","category":"section"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Universal Portfolio (UP) is a FW strategy proposed by Cover (1991). The Universal Portfolio algorithm is a portfolio selection algorithm from the field of machine learning and information theory. UP aims to maximize the cumulative reurn of the portfolio during the investment horizon. The algorithm is based on the performance of the stock market on each day and the proportion of wealth invested in each stock. ","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"See up.","category":"page"},{"location":"FW/#Run-UP","page":"Follow the Winner","title":"Run UP","text":"","category":"section"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Note: This package is meant to be used by researchers NOT FOR MARKET PRACTITIONERS. Let's run the algorithm on the real market data. The data is collected as noted in the \"Fetch-Data\" section.","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Let's run the algorithm on the given data (named as prices):","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"juila> using OnlinePortfolioSelection\n\njulia> size(prices)\n(17, 5)\n\n# OnlinePortfolioSelection suppose that the data is in the form of a matrix\n# where each row is the price vector of the assets at a specific time period.\njulia> prices = prices |> permutedims;\n\n# Let's run the algorithm on the last 5 days of the data.\njulia> m_up = up(prices[:, end-4:end], eval_points=100);\n\njuila> m_up.b\n5×5 Matrix{Float64}:\n 0.2  0.216518  0.216638  0.21681   0.216542\n 0.2  0.203395  0.203615  0.203754  0.203528\n 0.2  0.191899  0.191793  0.192316  0.192473\n 0.2  0.193023  0.192302  0.191687  0.19208\n 0.2  0.195164  0.195652  0.195433  0.195377","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"One can calculate the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(m_up.b, rel_price)\n6-element Vector{Float64}:\n 1.0\n 0.9879822623031318\n 0.9856240412854884\n 0.9874863498385578\n 0.9778277061434468\n 0.9718529924971879","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"The result indicates that if we had invested in the given period, we would have lost ~2.8% of our wealth. Note that sn automatically takes the last 5 relative prices in this case. Now, let's investiagte the performance of the algorithm according to some of the prominent metrics:","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"julia> results = OPSMetrics(m_up.b, rel_price)\n\n            Cumulative Return: 0.972\n                          APY: -0.763\nAnnualized Standard Deviation: 0.088\n      Annualized Sharpe Ratio: -8.857\n             Maximum Drawdown: 0.028\n                 Calmar Ratio: -27.101\n\njulia> results.\nAPY         Ann_Sharpe  Ann_Std     Calmar      MDD         Sn\n\njulia> results.MDD\n0.02814700750281207","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"It is worht mentioning that each metric can be accessed individually by writing results. and pressing Tab key. Note that one can individually investigate the performance of the algorithm regarding each metric. See sn, ann_std, apy, ann_sharpe, mdd, and calmar.","category":"page"},{"location":"FW/#Exponential-Gradient","page":"Follow the Winner","title":"Exponential Gradient","text":"","category":"section"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Exponential Gradient (EG) is a FW strategy proposed by Helmbold et al. (1998). Authors claim that EG can achieve almost the same wealth as the best constantrebalanced portfolio (BCRP) determined in hindsight from the actual market outcomes. the algorithm is very simple to implement and requires only constant storage and computing time per stock in each trading period.","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"See EG.","category":"page"},{"location":"FW/#Run-EG","page":"Follow the Winner","title":"Run EG","text":"","category":"section"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Let's run the algorithm on the real market data. The data is collected as noted in the \"Fetch-Data\" section.","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"juila> using OnlinePortfolioSelection\n\njulia> size(prices)\n(17, 5)\n\n# OnlinePortfolioSelection suppose that the data is in the form of a matrix\n# where each row is the price vector of the assets at a specific time period.\njulia> prices = prices |> permutedims;\n\n# Let's run the algorithm on the last 5 days of the data.\njulia> m_eg = eg(prices[:, end-4:end], eta=0.02);\n\njuila> m_eg.b\n5×5 Matrix{Float64}:\n 0.2  0.200001  0.200016  0.20003   0.199997\n 0.2  0.200049  0.200073  0.200087  0.200064\n 0.2  0.19999   0.199973  0.200029  0.200051\n 0.2  0.199937  0.199846  0.19978   0.199827\n 0.2  0.200023  0.200092  0.200074  0.200061 ","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"One can calculate the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(m_eg.b, rel_price)\n6-element Vector{Float64}:\n 1.0\n 0.9879822623031318\n 0.9854825989102248\n 0.98713136445759\n 0.9773624367829401\n 0.9716549466747438","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"The result indicates that if we had invested in the given period, we would have lost ~2.8% of our wealth. Note that sn automatically takes the last 5 relative prices in this case. Now, let's investiagte the performance of the algorithm according to some of the prominent metrics:","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"julia> results = OPSMetrics(m_eg.b, rel_price)\n\n            Cumulative Return: 0.972\n                          APY: -0.765\nAnnualized Standard Deviation: 0.087\n      Annualized Sharpe Ratio: -9.005\n             Maximum Drawdown: 0.028\n                 Calmar Ratio: -26.9\n\njulia> results.\nAPY         Ann_Sharpe  Ann_Std     Calmar      MDD         Sn\n\njulia> results.MDD\n0.028345053325256164","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"It is worht mentioning that each metric can be accessed individually by writing results. and pressing Tab key. Note that one can individually investigate the performance of the algorithm regarding each metric. See sn, ann_std, apy, ann_sharpe, mdd, and calmar.","category":"page"},{"location":"benchmark/#Benchmark-Strategies","page":"Benchmark","title":"Benchmark Strategies","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Some strategies in the context of online portfolio selection are considered as benchmark strategies. The simplest benchmark strategy is the Buy and Hold (BH) strategy which is called as the market strategy. The BAH model invests equally in m assets at the beginning and remains unchanged during the next periods, thus the weights of assets change passively with their price variations. A special BAH model, the Best-Stock (BS), invests all the capital into the best asset over the periods which is an optimal BAH in hindsight. Overall, the Benchmark portfolio selection models are quite simple because they do not adopt complex or sophisticated techniques via statistics and machine learning to explore the patterns within the data. Thus they are often taken as the baselines for performance comparison with new designed models. Another benchmark strategy is the Constant Rebalanced Portfolio (CRP) which assigns a fixed weight to each asset throughout a given period.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"See crp.","category":"page"},{"location":"benchmark/#Run-CRP","page":"Benchmark","title":"Run CRP","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Let's run the algorithm on the real market data. Assume the data (named as prices) is collected as noted in the \"Fetch-Data\" section.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"juila> using OnlinePortfolioSelection\n\njulia> size(prices)\n(17, 5)\n\n# OnlinePortfolioSelection suppose that the data is in the form of a matrix\n# where each row is the price vector of the assets at a specific time period.\njulia> prices = prices |> permutedims;\n\n# Let's run the algorithm on the last 5 days of the data.\njulia> m_crp = crp(prices[:, end-4:end]);\n\njuila> m_crp.b\n5×5 Matrix{Float64}:\n 0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"One can calculate the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(m_crp.b, rel_price)\n6-element Vector{Float64}:\n 1.0\n 0.9879822623031318\n 0.9854808899164217\n 0.9871240426268018\n 0.977351149446221\n 0.9716459683279461","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"The result indicates that if we had invested in the given period, we would have lost ~2.8% of our capital. Note that sn automatically takes the last 5 relative prices in this case. Now, let's investiagte the performance of the algorithm according to some of the prominent metrics:","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"julia> results = OPSMetrics(m_crp.b, rel_price)\n\n            Cumulative Return: 0.972\n                          APY: -0.765\nAnnualized Standard Deviation: 0.087\n      Annualized Sharpe Ratio: -9.008\n             Maximum Drawdown: 0.028\n                 Calmar Ratio: -26.993\n\njulia> results.\nAPY         Ann_Sharpe  Ann_Std     Calmar      MDD         Sn\n\njulia> results.MDD\n0.02835403167205386","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"It is worht mentioning that each metric can be accessed individually by writing results. and pressing Tab key. Note that one can individually investigate the performance of the algorithm regarding each metric. See sn, ann_std, apy, ann_sharpe, mdd, and calmar.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = quote\n    using OnlinePortfolioSelection\nend","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Online Portfolio Selection (OPS) strategies are trading algorithms that sequentially allocate capital among a group of assets to maximize the final returns of the investment. It is a fundamental problem in computational finance that has been extensively studied across several research communities, including finance, statistics, artificial intelligence, machine learning, and data mining. From an online machine learning perspective, it is formulated as a sequential decision problem and there are a variety of state-of-the-art approaches that have been developed to solve it. These approaches are grouped into several major categories, including benchmarks, “Follow-the-Winner” approaches, “Follow-the-Loser” approaches, “Pattern-Matching” based approaches, and \"Meta-Learning\" Algorithms1. This package provides an efficient implementation of OPS algorithms. The algorithms are implemented in Julia in a fully type-stable manner. All the algorithms return an object of type OPSAlgorithm which can be used to query the portfolio weights, number of assets, and the name of the algorithm. Seven algorithms are implemented so far and more will be added in the future. The available algorithms are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Constant Rebalanced Portfolio (CRP)\nExponential Gradient (EG)\nUniversal Portfolio (UP)\nCorrelation-driven Nonparametric Learning  4.1. CORN-U  4.2. CORN-K\nDynamic RIsk CORrelation-driven Non-parametric","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The latest stable version of the package can be installed by running the following command in the Julia REPL after pressing ]:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add OnlinePortfolioSelection","category":"page"},{"location":"","page":"Home","title":"Home","text":"The dev version can be installed usint the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/shayandavoodii/OnlinePortfolioSelection.jl.git","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be imported by running the following command in the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using OnlinePortfolioSelection","category":"page"},{"location":"","page":"Home","title":"Home","text":"One can perform several strategies on a given dataset and analyse and compare the results. The following code snippet shows how to perform the strategies on a given dataset and compare the results:","category":"page"},{"location":"","page":"Home","title":"Home","text":"juila> using CSV, DataFrames\n\n# read adjusted close prices\njulia> pr = CSV.read(\"data\\\\sp500.csv\", DataFrame) |> Matrix |> permutedims;\n\njulia> pr = pr[2:end, :];\n\njulia> market_pr = pr[1, :];\n\njulia> size(pr)\n(24, 1276)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The dataset contains the adjusted close prices of 24 stocks in the S&P 500 within 1276 trading days. Now, suppose we want to perform the strategies on the last 50 days of the dataset with default arguments:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> m_corn_u = cornu(pr, 50, 3);\n\njulia> m_corn_k = cornk(pr, 50, 3, 2, 2);\n\njuila> m_drcorn_k = dricornk(pr, market_pr, 50, 5, 5, 5);","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now, let's plot the trend of daily cumulative budgets of each algorithm. For this, we have to calculate it using the achieved portfolio weights and relative prices in the same time period:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# calculate the relative prices\njulia> rel_pr = pr[:, 2:end] ./ pr[:, 1:end-1];\n\njulia> models = [m_corn_u, m_corn_k, m_drcorn_k];\n\n# calculate the cumulative budgets\njulia> budgets = [sn(model.b, rel_pr[:, end-49:end]) for model in models];\n\njulia> using Plots\n\njulia> plot(\n            budgets, \n            label = [\"CORN-U\" \"CORN-K\" \"DRICORN-K\"], \n            xlabel = \"Day\", ylabel = \"Cumulative return\", legend = :bottomleft,\n       )","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"assets/cumulative_budgets.png\" width=\"100%\">","category":"page"},{"location":"","page":"Home","title":"Home","text":"The plot shows that the cumulative return of CORN-K outperforms the other algorithms almost all the time. Note that the initial investment for all of the algorithms is set to 1 (this can be modified by setting the keyword argument init_budg for each algorithm).Now, let's investigate the performance of the algorithms in terms of some of prominent performance metrics:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> all_metrics = OPSMetrics.([m_corn_u.b, m_corn_k.b, m_drcorn_k.b], Ref(rel_pr));","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now, one can embed the metrics in a DataFrame and compare the performance of the algorithms with respect to each other:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using DataFrames\n\njulia> nmodels = length(all_metrics);\n\njulia> comp_algs = DataFrame(\n           Algorithm = [\"CORN-U\", \"CORN-K\", \"DRICORN-K\"],\n           APY = [all_metrics[i].APY for i = 1:nmodels],\n           Ann_Sharpe = [all_metrics[i].Ann_Sharpe for i = 1:nmodels],\n           Ann_Std = [all_metrics[i].Ann_Std for i = 1:nmodels],\n           Calmar = [all_metrics[i].Calmar for i = 1:nmodels],\n           MDD = [all_metrics[i].MDD for i = 1:nmodels],\n       )\n3×6 DataFrame\n Row │ Algorithm  APY        Ann_Sharpe  Ann_Std   Calmar    MDD       \n     │ String     Float64    Float64     Float64   Float64   Float64   \n─────┼─────────────────────────────────────────────────────────────────\n   1 │ CORN-U     -0.126009   -0.505762  0.288691  -1.25383  0.100499\n   2 │ CORN-K      0.826495    2.48378   0.324705  17.688    0.0467263\n   3 │ DRICORN-K  -0.248393   -1.20933   0.221934  -2.54505  0.0975985","category":"page"},{"location":"","page":"Home","title":"Home","text":"The comp_algs shows that CORN-K outperforms the other algorithms in terms of annualizeed percentage yield (APY), annualized Sharpe ratio, Calmar ratio, and maximum drawdown (MDD). However, the annualized standard deviation of CORN-K is higher than the other algorithms in this dataset. Note that these metrics can be calculated individually by calling the corresponding sn, apy, ann_sharpe, ann_std, calmar, and mdd functions.","category":"page"}]
}
