var documenterSearchIndex = {"docs":
[{"location":"performance_eval/#Performance-evaluation","page":"Performance Evaluation","title":"Performance evaluation","text":"","category":"section"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"This package provides a set metrics to evaluate the performance of the algorithms. The metrics are prominent in the literature and are used to compare the performance of different algorithms. Currently, the following metrics are supported:","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"Cumulative Return (CR, Also known as S_n)","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"This metric calculates the cumulative return of the algorithm during the investment period. The cumulative return is defined as:","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"beginaligned\nS_n = S_0prodlimits_t = 1^T leftlangle b_tx_t rightrangle \nendaligned","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"where S_0 is the initial capital, b_t is the portfolio vector at time t and x_t is the relative price vector at time t.   This metric can be calculated by using the sn function.","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"Mean excess return (MER)","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"MER is used to measure the average excess returns of an OPS method that outperforms the benchmark market strategy. MER is defined as:","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"MER = 1 over nsumnolimits_t = 1^n R_t -  1 over nsumnolimits_t = 1^n R_t^*","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"where R and R_t^* are the daily returns of a portfolio and the market strategy at the 𝑡th trading day, respectively. For a given OPS method, considering the transaction costs, R_t is calculated by R_t = left( mathbfx_tmathbfb_t right) times left( 1 - nu  over 2 times sumnolimits_i = 1^d left b_ti - tilde b_ti right  right) - 1. The market strategy allocates the capital equally to all the assets at the beginning and remains unchanged. R_t^* is defined as: R_t^* = mathbfx_t cdot mathbfb^* - 1 and mathbfb^* = left( 1 over d1 over d ldots 1 over d right)^ top , where d is the number of assets, and n is the number of trading days. This metric can be calculated by using the mer function. (see [1] for more details.)","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"Annualized Return (APY)","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"This metric calculates the annualized return of the algorithm during the investment period. The annualized return is defined as:","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"beginaligned\nAPY = left( S_n right)^frac1y - 1\nendaligned","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"where y is the number of years in the investment period. This metric can be calculated by using the apy function.","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"Annualized Standard Deviation (sigma_p)","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"Another measurement used to examine the risk is the annual standard deviation of returns of the portfolio. The daily standard deviation is calculated to compute the annual standard deviation and then it is multiplied by sqrt252 (it is assumed that there are 252 days of each year). However, users can change the number of days in a year by setting the dpy keyword argument. This metric can be calculated by using the ann_std function.","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"Annualized Sharpe Ratio (SR)","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"The Sharpe ratio is a measure of risk-adjusted return. It is defined as:","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"beginaligned\nSR = APY - R_f over sigma _p\nendaligned","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"where R_f is the risk-free rate which is considered to be equal to the treasury bill rate at the time of investment. This metric can be calculated by using the ann_sharpe function.","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"Maximum Drawdown (MDD)","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"The maximum drawdown is the maximum loss from a peak to a trough of a portfolio, before a new peak is attained. Calculation of MDDis based on the capital break value. Capital break can be considered as one of the most important criteria to evaluate the capitalmarket which is equal to the upper bound of decline from the peak of portfolio cumulative function. Capital break is defined as:","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"beginaligned\nDDleft( T right) = sup left 0sup _i in left( 0t right)S_i - S_t right\nendaligned","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"where S_t is the portfolio cumulative function at time t. The maximum capital break can be used for measuring the risk thatcan be defined as:","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"beginaligned\nMDDleft( n right) = sup _t in left( 0n right)left DDleft( t right) right\nendaligned","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"This metric can be calculated by using the mdd function.","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"Calmar Ratio (CR)","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"The Calmar ratio is a measurement of risk-adjusted return based on maximum drawdown. It is defined as:  ","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"beginaligned\nCR = APY over MDD\nendaligned","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"This metric can be calculated by using the calmar function.   It is worth mentioning that these metrics can be calculated as a whole rather than calculating them one by one. This can be doneby using the OPSMetrics function. This function returns an object of type OPSMetrics which contains all the metricsmentioned above.","category":"page"},{"location":"fetchdata/#Fetch-Data","page":"Fetch Financial Data","title":"Fetch Data","text":"","category":"section"},{"location":"fetchdata/","page":"Fetch Financial Data","title":"Fetch Financial Data","text":"For fetching the data, one can use the YFinance.jl package:","category":"page"},{"location":"fetchdata/","page":"Fetch Financial Data","title":"Fetch Financial Data","text":"julia> using YFinance, DataFrames\n\njulia> tickers = [\"MMM\", \"CSCO\", \"IBM\", \"INTC\", \"XOM\"];\n\njulia> startdt, enddt = \"2023-04-01\", \"2023-04-27\";\n\njulia> querry = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"adjclose\"] for ticker in tickers];\n\n# In the Julia 1.9.0 and above, the following line can be replaced with `prices = stack(querry)`\njulia> prices = reduce(hcat, querry);\n\n# Let's make a DataFrame out of it for better visualization of the data\njulia> df = DataFrame(prices, tickers);\n\njulia> first(df, 3)\n3×5 DataFrame\n Row │ MMM      CSCO     IBM      INTC     XOM     \n     │ Float64  Float64  Float64  Float64  Float64 \n─────┼─────────────────────────────────────────────\n   1 │  104.57    51.92   132.06    32.89   116.13 \n   2 │  102.25    51.82   131.6     33.1    115.02 \n   3 │  102.29    51.82   132.14    32.83   116.99 ","category":"page"},{"location":"fetchdata/","page":"Fetch Financial Data","title":"Fetch Financial Data","text":"The given data in each example throughout this documentation has been collected using the above code. ","category":"page"},{"location":"FL/#Follow-the-Loser-(FL)","page":"Follow the Loser","title":"Follow the Loser (FL)","text":"","category":"section"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"follow the loser has been introduced by Borodin and Vincent (2004) in which, the investment weight is transferred from a stock provided a better performance in the past to a stock with unfavorable performance, since the approach considers that a stock with an undesirable performance in the past is able to provide a desirable return in the future. In this package, the following FL strategy is implemented so far:","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Reweighted Price Relative Tracking System for Automatic Portfolio Optimization\nAnti-Correlation (Anticor)\nOnline Moving Average Reversion (OLMAR)","category":"page"},{"location":"FL/#Reweighted-Price-Relative-Tracking-System-for-Automatic-Portfolio-Optimization-(RPRT)","page":"Follow the Loser","title":"Reweighted Price Relative Tracking System for Automatic Portfolio Optimization (RPRT)","text":"","category":"section"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"RPRT is a FL strategy proposed by Lai et al. (2018). In the price prediction stage, it automatically assigns separate weights to the price relative predictions according to each asset’s performance, and these weights will also be automatically updated. In the portfolio optimizing stage, they proposed a novel tracking system with a generalized increasing factor to maximize the future wealth of next period. Through their study, an efficient algorithm is designed to solve the portfolio optimization objective, which is applicable to large-scale and time-limited situations. According to their extensive experiments on six benchmark datasets from real financial markets with diverse assets and different time spans, RPRT outperforms other state-of-the-art systems in cumulative wealth, mean excess return, annual percentage yield, and some typical risk metrics. Moreover, it can withstand considerable transaction costs and runs fast. It indicates that RPRT is an effective and efficient online portfolio selection system.","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"See rprt.","category":"page"},{"location":"FL/#Run-RPRT","page":"Follow the Loser","title":"Run RPRT","text":"","category":"section"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Note: This package is meant to be used by researchers NOT FOR MARKET PRACTITIONERS. Let's run the algorithm on the real market data. In this case, the data is collected as noted in the Fetch Data section.","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Let's run the algorithm on the given data (named as prices):","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"juila> using OnlinePortfolioSelection\n\njulia> size(prices)\n(17, 5)\n\n# OnlinePortfolioSelection suppose that the data is in the form of a matrix\n# where each row is the price vector of the assets at a specific time period.\njulia> prices = prices |> permutedims;\n\njulia> window_length, threshold, epsilon = 2, 0.6, 40;\n\n# Let's run the algorithm for the last 5 days of the data.\njulia> prices = prices[:, end-4:end];\n\njulia> m_rprt = rprt(prices, w=window_length, theta=threshold, epsilon=epsilon);\n\n# Get the weights of the assets for each day\njuila> m_rprt.b\n5×5 Matrix{Float64}:\n 0.2  0.2  0.0  0.0  0.0\n 0.2  0.2  0.0  0.0  0.0\n 0.2  0.2  0.0  0.0  0.0\n 0.2  0.2  1.0  1.0  1.0\n 0.2  0.2  0.0  0.0  0.0","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"One can calculate the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(m_rprt.b, rel_price)\n6-element Vector{Float64}:\n 1.0\n 0.9879822800308067\n 0.985480892911241\n 0.9646654456994471\n 0.9392966194100733\n 0.9448257537201438","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"The result indicates that if we had invested in the given period, we would have lost ~6.3% of our wealth. Note that sn automatically takes the last 5 relative prices in this case. Now, let's investiagte the performance of the algorithm according to some of the prominent metrics:","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"julia> results = OPSMetrics(m_rprt.b, rel_price)\n\n            Cumulative Return: 0.945\n                          APY: -0.943\nAnnualized Standard Deviation: 0.202\n      Annualized Sharpe Ratio: -4.760\n             Maximum Drawdown: 0.061\n                 Calmar Ratio: -15.531\n\njulia> results.\nAPY         Ann_Sharpe  Ann_Std     Calmar      MDD         Sn\n\njulia> results.MDD\n0.06070338058992675","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"It is worht mentioning that each metric can be accessed individually by writing results. and pressing the Tab key. Note that one can individually investigate the performance of the algorithm regarding each metric. See sn, ann_std, apy, ann_sharpe, mdd, and calmar. See Performance evaluation section for more information.","category":"page"},{"location":"FL/#Anti-Correlation-(Anticor)","page":"Follow the Loser","title":"Anti-Correlation (Anticor)","text":"","category":"section"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Anticor is a FL strategy proposed by Borodin and El-Yaniv (2004). The idea of Anticor is to exploit the mean-reversion property of asset prices. Based on two consecutive market windows of size w wealth is transferred from asset i to asset j if the growth rate of asset i is greater than the growth rate of asset j in the most recent window. Additionally, the correlation between asset i in the second last window and asset j in the last window must to be positive. The amount of wealth transferred from asset i to j depends on the strength of correlation between the assets and the strength of \"self-anti-correlations\" between each asset i. [1]","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"See anticor.","category":"page"},{"location":"FL/#Run-Anticor","page":"Follow the Loser","title":"Run Anticor","text":"","category":"section"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Note: This package is meant to be used by researchers NOT FOR MARKET PRACTITIONERS. Let's run the algorithm on the real market data. In this case, the data is collected as noted in the Fetch Data section.","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Let's run the algorithm on the given data (named as prices):","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"juila> using OnlinePortfolioSelection\n\njulia> size(prices)\n(17, 5)\n\n# OnlinePortfolioSelection suppose that the data is in the form of a matrix\n# where each row is the price vector of the assets at a specific time period.\njulia> prices = prices |> permutedims;\n\njulia> window_size = 2;\n\n# Let's run the algorithm for the last 15 days of the data.\njulia> m_anticor = anticor(prices[:, end-14:end], window_size);\n\n# Get the weights of the assets for each day\njuila> m_anticor.b\n5×15 Matrix{Float64}:\n 0.2  0.2  0.2  0.2  0.266667   0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0   \n 0.2  0.2  0.2  0.2  0.0333333  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0   \n 0.2  0.2  0.2  0.2  0.0        0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0   \n 0.2  0.2  0.2  0.2  0.433333   1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 0.2  0.2  0.2  0.2  0.266667   0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"One can calculate the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(m_anticor.b, rel_price)\n16-element Vector{Float64}:\n 1.0\n 1.0026929997309684\n 0.9931968903246916\n 0.9939468872805755\n 0.9941204319128776\n ⋮\n 0.9528191316023853\n 0.9355287642277988\n 0.9157684119500683\n 0.8916854826115842\n 0.8969343557511426","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"The result indicates that if we had invested in the given period, we would have lost ~10.3% of our wealth. Note that sn automatically takes the last 15 relative prices in this case.","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Now, let's investiagte the performance of the algorithm according to some of the prominent metrics:","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"julia> results = OPSMetrics(m_anticor.b, rel_price)\n\n            Cumulative Return: 0.8969343557511426\n                          APY: -0.8391655504688253\nAnnualized Standard Deviation: 0.1618626725690273\n      Annualized Sharpe Ratio: -5.307990636954478\n             Maximum Drawdown: 0.11070937679745295\n                 Calmar Ratio: -7.579895892685864\n\njulia> results.MDD\n0.11070937679745295","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"It is worht mentioning that each metric can be accessed individually by writing results. and pressing the Tab key. Note that one can individually investigate the performance of the algorithm regarding each metric. See sn, ann_std, apy, ann_sharpe, mdd, and calmar. See Performance evaluation section for more information.","category":"page"},{"location":"FL/#Online-Moving-Average-Reversion-(OLMAR)","page":"Follow the Loser","title":"Online Moving Average Reversion (OLMAR)","text":"","category":"section"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"The OLMAR algorithm stands for On-Line Moving Average Reversion. It is a new approach for on-line portfolio selection that represents multi-period mean reversion as “Moving Average Reversion” (MAR), which explicitly predicts next price relatives using moving averages. To the best of our knowledge, OLMAR is the first algorithm that exploits moving average in the setting of on-line portfolio selection [1]. Though simple in nature, OLMAR has a reasonable updating strategy and has been empirically validated via a set of extensive experiments on real markets.","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"See olmar.","category":"page"},{"location":"FL/#Run-OLMAR","page":"Follow the Loser","title":"Run OLMAR","text":"","category":"section"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Let's run the algorithm on the real market data. In this case, the data is collected as noted in the Fetch Data section.","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Let's run the algorithm on the given data (named as prices):","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"juila> using OnlinePortfolioSelection\n\njulia> size(prices)\n(17, 5)\n\n# OnlinePortfolioSelection suppose that the data is in the form of a matrix\n# where each row is the price vector of the assets at a specific time period.\njulia> prices = prices |> permutedims;\n\njulia> window_size = 3;\njulia> eps = 2;\n\n# Let's run the algorithm for the last 15 days of the data.\njulia> m_olmar = olmar(prices[:, end-14:end], eps, window_size);\n\n# Get the weights of the assets for each day\njuila> m_olmar.b\n5×15 Matrix{Float64}:\n 0.2  0.2  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0\n 0.2  0.2  0.0  0.0  1.0  0.0     1.0  0.0  0.0  0.147231   \n 0.2  0.2  0.0  0.0  0.0  1.0     0.0  0.0  0.0  0.0        \n 0.2  0.2  1.0  1.0  0.0  0.0     0.0  1.0  1.0  0.0        \n 0.2  0.2  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.852769","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"One can calculate the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(m_olmar.b, rel_price)\n16-element Vector{Float64}:\n 1.0\n 1.0026929997309684\n 0.9931968903246916\n 0.9844182209638911\n 0.979271976499212\n ⋮\n 0.9390854420408513\n 0.9192499651820158\n 0.89507547776031\n 0.886526969495664","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"The result indicates that if we had invested in the given period, we would have lost ~11.3% of our wealth. Note that sn automatically takes the last 15 relative prices in this case.","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Now, let's investiagte the performance of the algorithm according to some of the prominent metrics:","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"julia> results = OPSMetrics(m_olmar.b, rel_price)\n        \n            Cumulative Return: 0.886526969495664\n                          APY: -0.8678020275925177\nAnnualized Standard Deviation: 0.20186187705069908\n      Annualized Sharpe Ratio: -4.398066839384139\n             Maximum Drawdown: 0.11585403534927716\n                 Calmar Ratio: -7.490477349159786\n\njulia> results.MDD\n0.11585403534927716","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"It is worht mentioning that each metric can be accessed individually by writing results. and pressing the Tab key. Note that one can individually investigate the performance of the algorithm regarding each metric. See sn, ann_std, apy, ann_sharpe, mdd, and calmar. See Performance evaluation section for more information.","category":"page"},{"location":"ML/#Meta-Learning-Strategies-(ML)","page":"Meta-Learning","title":"Meta-Learning Strategies (ML)","text":"","category":"section"},{"location":"ML/","page":"Meta-Learning","title":"Meta-Learning","text":"ML strategie are used to combine the experts opinitions to achieve a final portfolio. The opinion of each expert is a vector of weights that sum to one. Orthonormaly, the performance of each expert gets quantified, and affects the final portfolio. Each expert, can be a portfolio optimization model, or just a vector of weights as an input. The following ML strategies are implemented so far in the package:","category":"page"},{"location":"ML/","page":"Meta-Learning","title":"Meta-Learning","text":"Combination Weights based on Online Gradient Descent (CW-OGD) ","category":"page"},{"location":"ML/#Combination-Weights-based-on-Online-Gradient-Descent-(CW-OGD)","page":"Meta-Learning","title":"Combination Weights based on Online Gradient Descent (CW-OGD)","text":"","category":"section"},{"location":"ML/","page":"Meta-Learning","title":"Meta-Learning","text":"Zhang et al. (2021) proposed a new online portfolio selection strategy based on a weighted learning technique and an online gradient descent algorithm. Their strategy achieves improved robustness by integrating different expert strategies and overcomes the difficult problem of complex computational time. First, an expert pool including many basic expert strategies, in which they choose the strategy that invests in a single stock as the basic expert strategy, is established. Second, they exploit the loss function to evaluate the performance of each basic expert strategies and use the OGD algorithm to update the weight vector for the experts based on their losses.","category":"page"},{"location":"ML/#Run-CW-OGD","page":"Meta-Learning","title":"Run CW-OGD","text":"","category":"section"},{"location":"ML/","page":"Meta-Learning","title":"Meta-Learning","text":"Note: This package is meant to be used by researchers NOT FOR MARKET PRACTITIONERS. Let's run the algorithm on the real market data. (see cwogd for more information.)","category":"page"},{"location":"ML/","page":"Meta-Learning","title":"Meta-Learning","text":"julia> using OnlinePortfolioSelection, YFinance\n\njulia> tickers = [\"AAPL\", \"MSFT\", \"GOOG\"];\n\njulia> startdt, enddt = \"2019-01-01\", \"2019-01-10\";\n\njulia> querry_open_price = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"open\"] for ticker in tickers];\n\njulia> open_pr = reduce(hcat, querry_open_price) |> permutedims;\n\njulia> querry_close_pr = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"adjclose\"] for ticker in tickers];\n\njulia> close_pr = reduce(hcat, querry_close_pr) |> permutedims;\n\njulia> rel_pr = close_pr ./ open_pr\n3×6 Matrix{Float64}:\n 1.01956  0.987568  1.02581  0.994822  1.00796   1.01335\n 1.01577  0.973027  1.02216  1.00413   0.997671  1.00395\n 1.0288   0.976042  1.03692  0.997097  1.00016   0.993538\n\njulia> gamma = 0.1; H = 0.5;\n\njulia> model = cwogd(rel_pr, gamma, H);\n\njulia> model.b\n3×5 Matrix{Float64}:\n 0.333333  0.351048  0.346241  0.338507  0.350524\n 0.333333  0.321382  0.309454  0.320351  0.311853\n 0.333333  0.32757   0.344305  0.341142  0.337623","category":"page"},{"location":"ML/","page":"Meta-Learning","title":"Meta-Learning","text":"Now, let's investiagte the performance of the algorithm according to some of the prominent metrics:","category":"page"},{"location":"ML/","page":"Meta-Learning","title":"Meta-Learning","text":"julia> metrics = OPSMetrics(model.b, rel_pr)\n            Cumulative Return: 1.0323425490046683\n                          APY: 2.8071567518024554\nAnnualized Standard Deviation: 0.2821163077868604\n      Annualized Sharpe Ratio: 9.879459906685577\n             Maximum Drawdown: 0.021128559444089628\n                 Calmar Ratio: 132.86077355300776\n\njuila> metrics.Sn\n7-element Vector{Float64}:\n 1.0\n 1.0213786603648736\n 0.9997984006244297\n 1.0282690253184847\n 1.0266415196096432\n 1.0286957343361505\n 1.0323425490046683","category":"page"},{"location":"ML/","page":"Meta-Learning","title":"Meta-Learning","text":"The result indicates that if we had invested in the given period, we would have gained ~3.2% profit. It is worht mentioning that each metric can be accessed individually by writing results. and pressing the Tab key. Note that one can individually investigate the performance of the algorithm regarding each metric. See sn, ann_std, apy, ann_sharpe, mdd, and calmar. See Performance evaluation section for more information.","category":"page"},{"location":"ML/","page":"Meta-Learning","title":"Meta-Learning","text":"","category":"page"},{"location":"PM/#Pattern-matching-algorithms","page":"Pattern-Matching","title":"Pattern-matching algorithms","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Pattern-matching algorithms are one of most popular algorithms in the context of online portfolio selection. The main idea behind these algorithms is to find a pattern in the past price data and use it to predict the future price. These strategies are in consensus with technical analysts perspective. Technical analysts believe that the historical patterns in the price data will repeat in the future. The following pattern-matching algorithms are implemented in this package so far:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Correlation-driven Nonparametric Learning","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"1.1. CORN-U   1.2. CORN-K","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Dynamic RIsk CORrelation-driven Non-parametric\nBᴷ\nClusLog","category":"page"},{"location":"PM/#Correlation-driven-Nonparametric-Learning","page":"Pattern-Matching","title":"Correlation-driven Nonparametric Learning","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Correlation-driven Nonparametric Learning (CORN) is a pattern-matching algorithm proposed by Borodin et al. (2010). CORN utilizes the correlation as the similarity measure between time windows. Additionally, CORN defines several experts to construct portfolios. For each trading day, CORN combines the portfolios of the experts to construct the final portfolio. This is where CORN-K and CORN-U differ. CORN-K uses K best experts (based on their performance on historical data) to construct the final portfolio. On the other hand, CORN-U uses all the experts and uniformly combines their portfolios to construct the final portfolio. See cornu and cornk. ","category":"page"},{"location":"PM/#Run-CORN-U","page":"Pattern-Matching","title":"Run CORN-U","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"The most important parameters of CORN-U are w (maximum window size to be examined) and rho (correlation threshold). The higher the w is, the more window sizes are examined; consequently, the more time it takes to run the algorithm. However, the algorithm performs more accurately. The former is not true for rho. The authors have recommended to avoid extreme values for rho (e.g., 0.99 or 0.01). Since CORN aims to find time windows positive directional correlation, the negative values of rho are not allowed. Authors have found that the best values for rho in their experiments are 0.2. As a result, the default value for rho is set to 0.2.","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Since CORN family algorithms perform better when they are trained on a long period of time, we use the data of a longer period of time (e.g., ~1 year) to train the algorithm. Then, we use the data of a shorter period of time (e.g., last 10 days) to perform the portfolio selection.","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"juila> using OnlinePortfolioSelection\n\njulia> size(prices)\n(268, 5)\n\n# OnlinePortfolioSelection suppose that the data is in the form of a matrix\n# where each row is the price vector of the assets at a specific time period.\njulia> prices = prices |> permutedims;\n\n# run the algorithm on the last 5 days\njulia> horizon, w = 5, 10\n\njulia> model = cornu(prices, horizon, w)\n\njulia> model.b\n5×5 Matrix{Float64}:\n 0.0       0.198536  0.0995612  0.0        0.0\n 0.0       0.389272  0.0        0.0        0.0980504\n 0.0       0.0       0.430479   0.0998267  0.0\n 0.714743  0.0       0.0        0.0        0.203183\n 0.285257  0.412192  0.46996    0.900173   0.698766","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"One can compute the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(model.b, rel_price)\n6-element Vector{Float64}:\n 1.0\n 0.9910701218600744\n 0.9956345799968089\n 1.0038929232387375\n 0.9914403615208097\n 0.9851289224781754","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"The result indicates that the algorithm has lost 1.5% of the initial wealth during the investment period. Further analysis of the algorithm can be done by using the ann_std, apy, ann_sharpe, mdd, and calmar functions. See Performance evaluation section for more information.","category":"page"},{"location":"PM/#Run-CORN-K","page":"Pattern-Matching","title":"Run CORN-K","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"The most important parameters of CORN-K are k (number of best experts to be used for portfolio construction), w (maximum window size to be examined), and rho (number of correlation coefficient thresholds to be examined). Since CORN-K uses the best experts to construct the final portfolio, it is supposed to perform better than CORN-U. Let's run CORN-K on the same data as CORN-U:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"# run the algorithm on the last 5 days\njulia> horizon, k, w, rho = 5, 10, 5, 5, 5;\n\njulia> model = cornk(prices, horizon, k, w, rho);\n\njulia> model.b","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Last but not least, the cumulative return of the algorithm on the investment period and given dataset can be computed by using the sn function:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(model.b, rel_price)\n6-element Vector{Float64}:\n 1.0\n 0.9920219584145965\n 0.997769753240107\n 1.0153550964116513\n 1.004610801506029\n 1.0017637293758395","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"As mentioned earlier, CORN-K performed better than CORN-U on the same dataset. The result indicates that the algorithm has gained ~0.18% of the initial wealth during the investment period. Further analysis of the algorithm can be done by using the ann_std, apy, ann_sharpe, mdd, and calmar functions. See Performance evaluation section for more information.","category":"page"},{"location":"PM/#Dynamic-RIsk-CORrelation-driven-Non-parametric","page":"Pattern-Matching","title":"Dynamic RIsk CORrelation-driven Non-parametric","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Dynamic RIsk CORrelation-driven Non-parametric (DRICORN) follows the same idea as CORN-K. However, DRICORN considers the beta of portfolio as a measure of risk in the portfolio optimization. Furthermore, they consider the recent trend of market in order to take advantage of positive risks, and avoid negative risks. See dricornk.","category":"page"},{"location":"PM/#Run-DRICORN-K","page":"Pattern-Matching","title":"Run DRICORN-K","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Since this algorithm is built on top of CORN-K, it shares the similar parameters with CORN-K. Nevertheless, DRICORN-K needs the data of the market index (e.g., S&P 500) in order to compute the beta of the portfolio, and the trend of the market. It is worth mentioning that the algorithm also takes a coefficient in order to regularize the beta of the portfolio. The default value for this coefficient is 1e-3. Let's run DRICORN-K on the same data as CORN-U and CORN-K:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"# run the algorithm on the last 5 days\njulia> horizon, k, w, rho = 5, 10, 5, 5, 5;\n\njulia> model = dricornk(prices, market_prices, horizon, k, w, rho);\n\njulia> model.b\n4×5 Matrix{Float64}:\n 0.0  0.25  0.25  0.25  0.17438\n 0.0  0.25  0.25  0.25  0.17438\n 0.0  0.25  0.25  0.25  0.174281\n 1.0  0.25  0.25  0.25  0.476959","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Using sn function, one can compute the cumulative wealth during the investment period:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(model.b, rel_price)\n6-element Vector{Float64}:\n 1.0\n 0.9906902403938972\n 0.9867624995658737\n 0.9841621752990845\n 0.9754797369845584\n 0.9738144349688777","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"The result indicates that the algorithm has lost ~2.6% of the initial wealth during the investment period. Further analysis of the algorithm can be done by using the ann_std, apy, ann_sharpe, mdd, and calmar functions. See Performance evaluation section for more information.","category":"page"},{"location":"PM/#Bᴷ","page":"Pattern-Matching","title":"Bᴷ","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Bᴷ which is introduced as a class of kernel-based investment strategies, is a pattern-matching algorithm proposed by Györfi et al. (2006). Bᴷ, in spirit, is similar to the histogram-based strategies. The main difference is that the elementary strategies used by the strategy replace the rigid discretization of the past few market vectors by a more flexible “moving-window” rule. This implementation comes with the uniform kernel function. See bk.","category":"page"},{"location":"PM/#Run-Bᴷ","page":"Pattern-Matching","title":"Run Bᴷ","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"The most important parameter of Bᴷ is k (number of best experts to be used for portfolio construction). Let's run Bᴷ on the same data as CORN-U, CORN-K, etc.:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"julia> using OnlinePortfolioSelection\n\njulia> horizon, k, n_splits, similarity_thresh = 5, 5, 10, 0.2;\n\njulia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\n# run the algorithm on the last 5 days\njulia> model = bk(rel_price[:, end-horizon+1:end], k, n_splits, similarity_thresh);\n\njulia> model.b\n5×5 Matrix{Float64}:\n 0.2  0.2  0.196078  0.156876  0.153047\n 0.2  0.2  0.196078  0.156876  0.250758\n 0.2  0.2  0.215685  0.156876  0.172675\n 0.2  0.2  0.196078  0.156876  0.153047\n 0.2  0.2  0.196079  0.372496  0.270474","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Using sn function, one can compute the cumulative wealth during the investment period:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(model.b, rel_price)\n6-element Vector{Float64}:\n 1.0\n 0.987982263196868\n 0.9854808683947185\n 0.9870411234122491\n 0.9763511652573162\n 0.9698166561732083","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"The result indicates that the algorithm has lost ~3% of the initial wealth during the investment period. Further analysis of the algorithm can be done by using the ann_std, apy, ann_sharpe, mdd, and calmar functions. See Performance evaluation section for more information.","category":"page"},{"location":"PM/#ClusLog","page":"Pattern-Matching","title":"ClusLog","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"ClusLog contains some variant of models proposed by Khedmati & Azin (2020), namely, KMNLOG and KMDLOG. The main idea behind these algorithms is to cluster the historical time windows based on their inter-correlation. Then, the algorithm uses a day after the found time windows as the potential day to occur with the same pattern for tomorrow. In order to perform the portfolio selection, the algorithm uses the semi-log optimal approach in order to maximize the expected return of the portfolio. See cluslog.","category":"page"},{"location":"PM/#Run-ClusLog","page":"Pattern-Matching","title":"Run ClusLog","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"In order to use this function, you have to install the Clustering.jl package and import it on your own. The reason behind this design is that I do not intend to add extra dependencies to this package for the sake of just an algorithm. The Clustering.jl package can be installed by running the following command in the Julia REPL:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"julia> using Pkg\n\njulia> pkg\"add Clustering@0.15.2\"\n\n# Or\n\njulia> pkg.add(name=\"Clustering\", version=\"0.15.2\")","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"After intalling the package, you can use the cluslog function after importing the Clustering.jl package. Let's run ClusLog on the same data as CORN-U, CORN-K, etc.:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"julia> using OnlinePortfolioSelection, Clustering\n\njulia> horizon, max_window_size, clustering_model, max_n_clusters, max_n_clustering, optm_boundries = 2, 3, KmeansModel, 3, 7, (0.0, 1.0);\n\njulia> prices = prices |> permutedims;\n\njulia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\n# run the algorithm on the last 2 days\njulia> model = cluslog(rel_price, horizon, max_window_size, clustering_model, max_n_clusters, max_n_clustering, optm_boundries);\n[ Info: Analysis for trading day 1 is done.\n[ Info: Analysis for trading day 2 is done.\n\njulia> model.b\n5×2 Matrix{Float64}:\n 0.963883    0.00479629\n 0.00337321  0.973796\n 0.00657932  0.00360691\n 0.00183594  0.00164263\n 0.0243289   0.0161582","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Using sn function, one can compute the cumulative wealth during the investment period:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"julia> sn(model.b, rel_price)\n3-element Vector{Float64}:\n 1.0\n 0.9932798769652941\n 0.9817775041346212","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"The result indicates that the algorithm has lost ~1.8% of the initial wealth during the investment period. Further analysis of the algorithm can be done by using the ann_std, apy, ann_sharpe, mdd, and calmar functions. See Performance evaluation section for more information.","category":"page"},{"location":"funcs/#API","page":"Functions","title":"API","text":"","category":"section"},{"location":"funcs/","page":"Functions","title":"Functions","text":"Modules = [OnlinePortfolioSelection]\nPrivate = false\nOrder   = [:function, :type]","category":"page"},{"location":"funcs/#OnlinePortfolioSelection.ann_sharpe-Union{Tuple{T}, Tuple{T, T, T}} where T<:AbstractFloat","page":"Functions","title":"OnlinePortfolioSelection.ann_sharpe","text":"ann_sharpe(APY::T, Rf::T, sigma_prtf::T) where T<:AbstractFloat\n\nCalculate the Annualized Sharpe Ratio of investment.\n\nArguments\n\nAPY::T: the APY of investment.\nRf::T: the risk-free rate of return.\nsigma_prtf::T: the standard deviation of the portfolio sigma_p.\n\nReturns\n\n::AbstractFloat: the Annualized Sharpe Ratio of investment.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.ann_std-Tuple{Vector{<:AbstractFloat}}","page":"Functions","title":"OnlinePortfolioSelection.ann_std","text":"ann_std(cum_ret::Vector{AbstractFloat}; dpy)\n\nCalculate the Annualized Standard Deviation (σₚ) of portfolio.\n\nArguments\n\ncum_ret::Vector{AbstractFloat}: the cumulative return of investment during the investment period.\n\nKeyword Arguments\n\ndpy: the number of days in a year.\n\nReturns\n\n::AbstractFloat: the Annualized Standard Deviation (σₚ) of portfolio.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.anticor-Union{Tuple{T}, Tuple{Matrix{T}, Int64}} where T<:Real","page":"Functions","title":"OnlinePortfolioSelection.anticor","text":"anticor(adj_close::Matrix{T}, window::Int) where {T<:Real}\n\nRun the Anticor algorithm on adj_close with window sizes window.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nArguments\n\nadj_close::Matrix{T}: matrix of adjusted close prices\nwindow::Int: size of the window\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): An OPSAlgorithm object.\n\nExample\n\njulia> using OnlinePortfolioSelection\n\njulia> adj_close = [\n       1. 2.\n       4. 9.\n       7. 8.\n       10. 11.\n       13. 7.\n       8. 17.\n       19. 20.\n       22. 23.\n       25. 8.\n       2. 12.\n       5. 12.\n       5. 0.\n       0. 2.\n       1. 1.\n       ];\n\njulia> adj_close = permutedims(adj_close);\n\njulia> m_anticor = anticor(adj_close, 3);\n\njulia> m_anticor.b\n2×14 Matrix{Float64}:\n 0.5  0.5  0.5  0.5  …  0.0  0.0  0.0  1.0\n 0.5  0.5  0.5  0.5     1.0  1.0  1.0  0.0\n\njulia> sum(m_anticor.b, dims=1) .|> isapprox(1., atol=1e-8) |> all\ntrue\n\nReferences\n\n[1] Can We Learn to Beat the Best Stock\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.apy-Union{Tuple{S}, Tuple{AbstractFloat, S}} where S<:Int64","page":"Functions","title":"OnlinePortfolioSelection.apy","text":"apy(Sn::AbstractFloat, n_periods::S; dpy::S=252) where S<:Int\n\nCalculate the Annual Percentage Yield (APY) of investment.\n\nArguments\n\nSn::AbstractFloat: the cumulative return of investment.\nn_periods::S: the number investment periods.\ndpy::S=252: the number of days in a year.\n\nReturns\n\n::AbstractFloat: the APY of investment.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.bk-Union{Tuple{S}, Tuple{T}, Tuple{Matrix{T}, S, S, Any}} where {T<:Float64, S<:Int64}","page":"Functions","title":"OnlinePortfolioSelection.bk","text":"bk(rel_price::Matrix{T}, K::S, L::S, c) where {T<:Float64, S<:Int}\n\nRun Bᴷ algorithm.\n\nArguments\n\nrel_price::Matrix{T}: Relative prices of assets.\nK::S: Number of experts.\nL::S: Number of time windows.\nc::T: The similarity threshold.\n\nwarning: Beware!\nrel_price should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): An object of type OPSAlgorithm.\n\nExample\n\njulia> using OnlinePortfolioSelection\n\njulia> daily_relative_prices = rand(10, 100);\n\njulia> model = bk(daily_relative_prices, 10, 10, 0.5);\n\njulia> model.alg\n\"Bᵏ\"\n\njulia> sum(model.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\nReference\n\n[1] NONPARAMETRIC KERNEL-BASED SEQUENTIAL INVESTMENT STRATEGIES\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.bs-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Float64","page":"Functions","title":"OnlinePortfolioSelection.bs","text":"bs(adj_close::Matrix{T}; last_n::Int=0) where {T<:Float64}\n\nRun the Best So Far algorithm on the given data.\n\nArguments\n\nadj_close::Matrix{T}: A matrix of adjusted closing prices of assets.\n\nKeyword Arguments\n\nlast_n::Int: The number of periods to look back for the performance of each asset. If last_n is 0, then the performance is calculated from the first period to the previous period.\n\nwarning: Beware!\nThe adj_close matrix should be in the order of assets x periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): An instance of OPSAlgorithm.\n\nExample\n\njulia> using OnlinePortfolioSelection\n\njulia> adj_close = rand(5, 10);\n\njulia> model = bs(adj_close, last_n=2);\n\njulia> model.b\n5×10 Matrix{Float64}:\n 0.2  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0\n 0.2  0.0  0.0  1.0  0.0  1.0  0.0  0.0  0.0  0.0\n 0.2  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.2  1.0  1.0  0.0  0.0  0.0  1.0  0.0  1.0  1.0\n 0.2  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0\n\njulia> sum(model.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\nReferences\n\n[1] KERNEL-BASED SEMI-LOG-OPTIMAL EMPIRICAL PORTFOLIO SELECTION STRATEGIES\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.calmar-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractFloat","page":"Functions","title":"OnlinePortfolioSelection.calmar","text":"calmar(APY::T, MDD::T) where T<:AbstractFloat\n\nCalculate the Calmar Ratio of investment.\n\nArguments\n\nAPY::T: the APY of investment.\nMDD::T: the MDD of investment.\n\nReturns\n\n::AbstractFloat: the Calmar Ratio of investment.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.cluslog","page":"Functions","title":"OnlinePortfolioSelection.cluslog","text":"cluslog()\ncluslog(\n  rel_pr::AbstractMatrix{<:AbstractFloat},\n  horizon::Int,\n  TW::Int,\n  clus_mod::Type{<:ClusteringModel},\n  nclusters::Int,\n  nclustering::Int,\n  boundries::NTuple{2, AbstractFloat};\n  progress::Bool=true\n)\n\nYou need to install and import the following packages before using this function:\n\nClustering\n\njulia> using Pkg\n\njulia> Pkg.add(name=\"Clustering\", version=\"0.15.2\")\n\njulia> using OnlinePortfolioSelection, Clustering\n\ncluslog(\n  rel_pr::AbstractMatrix{<:AbstractFloat},\n  horizon::Int,\n  TW::Int,\n  clus_mod::Type{<:ClusteringModel},\n  nclusters::Int,\n  nclustering::Int,\n  boundries::NTuple{2, AbstractFloat};\n  log::Bool=true\n)\n\nRun KMNLOG, KMDLOG, etc., algorithms on the given data.\n\nArguments\n\nrel_pr::AbstractMatrix{<:AbstractFloat}: Relative prices of assets. Each column represents the price of an asset at a given time.\nhorizon::Int: Number of trading days.\nTW::Int: Maximum time window length to be examined.\nclus_mod::Type{<:ClusteringModel}: Clustering model to be used. Currently, only KmeansModel and KmedoidsModel are supported.\nnclusters::Int: The maximum number of clusters to be examined.\nnclustering::Int: The number of times clustering algorithm is run for optimal\n\nnumber of clusters.\n\nboundries::NTuple{2, AbstractFloat}: The lower and upper boundries for the weights of assets in the portfolio.\n\nKeyword Arguments\n\nprogress::Bool=true: Whether to log the progress or not.\n\nwarning: Beware!\nrel_pr should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm: An OPSAlgorithm object.\n\nExample\n\nTwo clustering model is available as of now: KmeansModel, and KmedoidsModel. The first example utilizes KmeansModel:\n\njulia> using OnlinePortfolioSelection, Clustering\n\njulia> adj_close = [\n         1.5464 1.5852 1.6532 1.7245 1.5251 1.4185 1.2156 1.3231 1.3585 1.4563 1.4456\n         1.2411 1.2854 1.3456 1.4123 1.5212 1.5015 1.4913 1.5212 1.5015 1.4913 1.5015\n         1.3212 1.3315 1.3213 1.3153 1.3031 1.2913 1.2950 1.2953 1.3315 1.3213 1.3315\n       ]\n\njulia> rel_pr = adj_close[:, 2:end]./adj_close[:, 1:end-1]\n\njulia> horizon = 3; TW = 3; nclusters_ = 3; nclustering = 10; lb, ub = 0.0, 1.;\n\njulia> model = cluslog(rel_pr, horizon, TW, KmeansModel, nclusters_, nclustering, (lb, ub));\n\njulia> model.b\n3×3 Matrix{Float64}:\n0.00264911  0.00317815  0.148012\n0.973581    0.971728    0.848037\n0.02377     0.0250939   0.00395028\n\njulia> sum(model.b , dims=1) .|> isapprox(1.) |> all\ntrue\n\nThe same approach works for KmedoidsModel as well:\n\njulia> using OnlinePortfolioSelection, Clustering\n\njulia> model = cluslog(rel_pr, horizon, TW, KmedoidsModel, nclusters_, nclustering, (lb, ub));\n\njulia> model.b\n3×3 Matrix{Float64}:\n4.59938e-7  4.96421e-7  4.89426e-7\n0.999998    0.999997    0.999997\n2.02964e-6  2.02787e-6  2.02964e-6\n\njulia> sum(model.b , dims=1) .|> isapprox(1.) |> all\ntrue\n\nReference\n\nAn online portfolio selection algorithm using clustering approaches and considering transaction costs\n\n\n\n\n\n","category":"function"},{"location":"funcs/#OnlinePortfolioSelection.cornk-Union{Tuple{T}, Tuple{Matrix{Float64}, Vararg{T, 4}}} where T<:Int64","page":"Functions","title":"OnlinePortfolioSelection.cornk","text":"cornk(\n  adj_close::Matrix{Float64},\n  horizon::T,\n  k::T,\n  w::T,\n  p::T;\n  init_budg=1,\n  progress::Bool=false\n) where T<:Int\n\nRun CORN-K algorithm.\n\nArguments\n\nadj_close::Matrix{Float64}: Adjusted close prices of assets.\nhorizon::T: The number of periods to invest.\nk::T: The number of top experts to be selected.\nw::T: maximum length of time window to be examined.\np::T: maximum number of correlation coefficient thresholds.\n\nKeyword Arguments\n\ninit_budg=1: The initial budget for investment.\nprogress::Bool=false: Whether to show the progress bar.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): An object of type OPSAlgorithm.\n\nReference\n\n[1] CORN: Correlation-driven nonparametric learning approach for portfolio selection\n\nExamples\n\njulia> using OnlinePortfolioSelection\n\njulia> adj_close = rand(5, 100);\n\njulia> model = cornk(adj_close, 10, 3, 5, 3);\n\njulia> model.alg\n\"CORN-K\"\n\njulia> sum(model.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.cornu-Union{Tuple{M}, Tuple{T}, Tuple{Matrix{T}, M, M}} where {T<:Float64, M<:Int64}","page":"Functions","title":"OnlinePortfolioSelection.cornu","text":"cornu(\n  adj_close::Matrix{T},\n  horizon::M,\n  w::M;\n  rho::T=0.2,\n  init_budg=1,\n  progress::Bool=false\n) where {T<:Float64, M<:Int}\n\nRun CORN-U algorithm.\n\nArguments\n\nadj_close::Matrix{T}: Adjusted close prices of assets.\nhorizon::M: The number of periods to invest.\nw::M: maximum length of time window to be examined.\n\nKeyword Arguments\n\nrho::T=0.2: The correlation coefficient threshold.\ninit_budg=1: The initial budget for investment.\nprogress::Bool=false: Whether to show the progress bar.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): An object of type OPSAlgorithm.\n\nExamples\n\njulia> using OnlinePortfolioSelection\n\njulia> adj_close = rand(5, 100);\n\njulia> model = cornu(adj_close, 10, 5, 0.5);\n\njulia> model.alg\n\"CORN-U\"\n\njulia> sum(model.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\nReference\n\n[1] CORN: Correlation-driven nonparametric learning approach for portfolio selection\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.crp-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Float64","page":"Functions","title":"OnlinePortfolioSelection.crp","text":"crp(adj_close::Matrix{T}) where T<:Float64\n\nRun Constant Rebalanced Portfolio (CRP) algorithm.\n\nArguments\n\nadj_close::Matrix{Float64}: adjusted close prices\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): OPSAlgorithm object\n\nExample\n\njulia> using OnlinePortfolioSelection\n\njulia> typeof(adj_close), size(adj_close)\n(Matrix{Float64}, (3, 10))\n\njulia> m_crp = crp(adj_close);\n\njulia> m_crp.b\n3×10 Matrix{Float64}:\n 0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333\n 0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333\n 0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333\n\njulia> sum(m_crp.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\nReferences\n\n[1] Universal Portfolios\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.cwogd-Tuple{AbstractMatrix, AbstractFloat, Any}","page":"Functions","title":"OnlinePortfolioSelection.cwogd","text":"cwogd(\n  rel_pr::AbstractMatrix,\n  γ::AbstractFloat,\n  H;\n  bj::AbstractMatrix=diagm(ones(size(rel_pr, 1)))\n)\n\nRun the CW-OGD algorithm.\n\nPositional Arguments\n\nrel_pr::AbstractMatrix: Relative price matrix where it represents proportion of the closing price to the opening price of each asset in each day.\nγ::AbstractFloat: Regular term coefficient of the basic expert's loss function.\nH::AbstractFloat: Constant for calculating step sizes.\n\nKeyword Arguments\n\nbj::AbstractMatrix=diagm(ones(size(rel_pr, 1))): Matrix of experts opinions. Each column of this matrix must have just one positive element == 1. and others are zero. Also, sum of each column must be equal to 1. and number of rows must be equal to number of rows of rel_pr.\n\nwarning: Beware!\nrel_pr should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm: An object of OPSAlgorithm type.\n\nExample\n\njulia> using OnlinePortfolioSelection, YFinance\n\njulia> tickers = [\"AAPL\", \"MSFT\", \"GOOG\"];\n\njulia> startdt, enddt = \"2019-01-01\", \"2019-01-10\";\n\njulia> querry_open_price = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"open\"] for ticker in tickers];\n\njulia> open_pr = reduce(hcat, querry_open_price) |> permutedims;\n\njulia> querry_close_pr = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"adjclose\"] for ticker in tickers];\n\njulia> close_pr = reduce(hcat, querry_close_pr) |> permutedims;\n\njulia> rel_pr = close_pr ./ open_pr\n3×6 Matrix{Float64}:\n 1.01956  0.987568  1.02581  0.994822  1.00796   1.01335\n 1.01577  0.973027  1.02216  1.00413   0.997671  1.00395\n 1.0288   0.976042  1.03692  0.997097  1.00016   0.993538\n\njulia> gamma = 0.1; H = 0.5;\n\njulia> model = cwogd(rel_pr, gamma, H);\n\njulia> model.b\n3×5 Matrix{Float64}:\n 0.333333  0.351048  0.346241  0.338507  0.350524\n 0.333333  0.321382  0.309454  0.320351  0.311853\n 0.333333  0.32757   0.344305  0.341142  0.337623\n\njulia> sum(model.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\nOr using a custom matrix of experts opinions:\n\njulia> b1 = [\n          0.0 1.0 0.0\n          1.0 0.0 0.0\n          0.0 0.0 1.0\n        ]\n\njulia> model = cwogd(rel_pr, gamma, H, bj=b1);\n\njulia> model.b\n3×6 Matrix{Float64}:\n 0.333333  0.329802  0.347517  0.34271   0.334976  0.346992\n 0.333333  0.322351  0.3104    0.298472  0.309369  0.300871\n 0.333333  0.347847  0.342083  0.358819  0.355655  0.352137\n\njulia> sum(model.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\nReferences\n\n[1] Combining expert weights for online portfolio selection based on the gradient descent algorithm.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.dricornk-Union{Tuple{M}, Tuple{T}, Tuple{Matrix{T}, Vector{T}, Vararg{M, 4}}} where {T<:Float64, M<:Int64}","page":"Functions","title":"OnlinePortfolioSelection.dricornk","text":"dricornk(\n  adj_close::Matrix{T},\n  adj_close_market::Vector{T},\n  horizon::M,\n  k::M,\n  w::M,\n  p::M;\n  lambda::T=1e-3,\n  init_budg=1,\n  progress::Bool=false\n) where {T<:Float64, M<:Int}\n\nRun the DRICORNK algorithm.\n\nArguments\n\nadj_close::Matrix{T}: A matrix of adjusted close prices of the assets.\nadj_close_market::Vector{T}: A vector of adjusted close prices of the market in the same period.\nhorizon::M: The investment horizon.\nk::M: The number of experts.\nw::M: maximum length of time window to be examined.\np::M: maximum number of correlation coefficient thresholds.\n\nKeyword Arguments\n\nlambda::T=1e-3: The regularization parameter.\ninit_budg=1: The initial budget for investment.\nprogress::Bool=false: Whether to show the progress bar.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): An object of type OPSAlgorithm.\n\nExample\n\njulia> using OnlinePortfolioSelection\n\njulia> stocks_adj, market_adj = rand(10, 100), rand(100);\n\njulia> m_dricornk = dricornk(stocks_adj, market_adj, 5, 2, 4, 3);\n\njulia> sum(m_dricornk.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\nReference\n\n[1] DRICORN-K: A Dynamic RIsk CORrelation-driven Non-parametric Algorithm for Online Portfolio Selection\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.eg-Tuple{Matrix{Float64}}","page":"Functions","title":"OnlinePortfolioSelection.eg","text":"eg(adj_close::Matrix{Float64}; eta=0.05)\n\nExponential Gradient (EG) algorithm.\n\nCalculate the Exponential Gradient (EG) weights and budgets using the given historical prices and parameters and return an EG object.\n\nArguments\n\nadj_close::Matrix{Float64}: Historical adjusted close prices.\n\nKeyword Arguments\n\neta=0.05: Learning rate.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): OPSAlgorithm object.\n\nExamples\n\njulia> using OnlinePortfolioSelection\n\njulia> typeof(adj_close), size(adj_close)\n(Matrix{Float64}, (3, 10))\n\njulia> m_eg = eg(adj_close);\n\njulia> m_eg.b\n3×10 Matrix{Float64}:\n 0.333333  0.333119  0.333296  0.333232  0.33327   0.333276  0.333201  0.333171  0.332832  0.332789\n 0.333333  0.333436  0.333274  0.333485  0.333481  0.333359  0.333564  0.333477  0.333669  0.333835\n 0.333333  0.333445  0.33343   0.333283  0.333249  0.333365  0.333234  0.333353  0.333499  0.333377\n\njulia> sum(m_eg.b, dims=1) .|> isapprox(1.0) |> all\ntrue\n\nReferences\n\n[1] On-Line Portfolio Selection Using Multiplicative Updates\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.load-Union{Tuple{S}, Tuple{T}, Tuple{AbstractMatrix{T}, T, S, S, T}} where {T<:Float64, S<:Int64}","page":"Functions","title":"OnlinePortfolioSelection.load","text":"load(adj_close::AbstractMatrix{T}, α::T, ω::S, horizon::S, η::T, ϵ::T=1.5) where {T<:Float64, S<:Int}\n\nRun LOAD algorithm.\n\nArguments\n\nadj_close::AbstractMatrix{T}: Adjusted close price data.\nα::T: Decay factor. (0 < α < 1)\nω::S: Window size. (ω > 0)\nhorizon::S: Investment horizon. (n_periods > horizon > 0)\nη::T: Threshold value. (η > 0)\nϵ::T=1.5: Expected return threshold value.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\nOPSAlgorithm: An object of type OPSAlgorithm containing the weights of each asset for each period.\nSₜ::Vector{Float64}: Cumulative wealth for each period.\n\nExample\n\n# Get data\njulia> using YFinance\njulia> startdt, enddt = \"2022-04-01\", \"2023-04-27\";\njulia> querry = [\n          get_prices(ticker, startdt=startdt, enddt=enddt)[\"adjclose\"] for ticker in tickers\n       ];\njulia> prices = reduce(hcat, querry);\njulia> prices = permutedims(prices);\n\njulia> using OnlinePortfolioSelection\n\njulia> model, s = load(prices, 0.5, 30, 5, 0.1);\n\njulia> model.b\n5×5 Matrix{Float64}:\n 0.2  2.85298e-8  0.0        0.0       0.0\n 0.2  0.455053    0.637299   0.694061  0.653211\n 0.2  0.215388    0.0581291  0.0       0.0\n 0.2  0.329559    0.304572   0.305939  0.346789\n 0.2  6.06128e-9  0.0        0.0       0.0\n\njulia> sum(model.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\njulia> s\n6-element Vector{Float64}:\n 1.0\n 0.9879822754225864\n 0.9853561439014098\n 0.9836737048568326\n 0.971437501096619\n 0.9660091217094392\n\nReferences\n\nA local adaptive learning system for online portfolio selection\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.mdd-Union{Tuple{Vector{T}}, Tuple{T}} where T<:AbstractFloat","page":"Functions","title":"OnlinePortfolioSelection.mdd","text":"mdd(Sn::Vector{T}) where T<:AbstractFloat\n\nCalculate the Maximum Drawdown (MDD) of investment.\n\nArguments\n\nSn::Vector{T}: the cumulative return of investment during the investment period.\n\nReturns\n\n::AbstractFloat: the MDD of investment.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.mer-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractFloat}} where T<:AbstractFloat","page":"Functions","title":"OnlinePortfolioSelection.mer","text":"mer(\n  weights::AbstractMatrix{T},\n  rel_pr::AbstractMatrix{T},\n  𝘷::AbstractFloat=0.\n) where T<:AbstractFloat\n\nCalculate the investments's Mean excess return (MER).\n\nArguments\n\nweights::T: the weights of the portfolio.\nrel_pr::T: the relative price of the stocks.\n𝘷::AbstractFloat=0.: the transaction cost rate.\n\nwarning: Warning\nThe size of weights and rel_pr must be (n_stocks, n_periods).\n\nnote: Note\nIf size(rel_pr, 2) is greater than size(weights, 2), then the last size(weights, 2) columns of rel_pr will be used.\n\nReturns\n\nMER::AbstractFloat: the investments's Mean excess return (MER).\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.mrvol-Union{Tuple{S}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, S, S, S, T, T}} where {T<:AbstractFloat, S<:Integer}","page":"Functions","title":"OnlinePortfolioSelection.mrvol","text":"mrvol(\n  rel_pr::AbstractMatrix{T},\n  rel_vol::AbstractMatrix{T},\n  horizon::S,\n  Wₘᵢₙ::S,\n  Wₘₐₓ::S,\n  λ::T,\n  η::T\n) where {T<:AbstractFloat, S<:Integer}\n\nRun MRvol algorithm.\n\nArguments\n\nrel_pr::AbstractMatrix{T}: Relative price matrix where it represents proportion of the closing price to the opening price of each asset in each day.\nrel_vol::AbstractMatrix{T}: Relative volume matrix where 𝘷ᵢⱼ represents the tᵗʰ trading volume of asset 𝑖 divided by the (t - 1)ᵗʰ trading volume of asset 𝑖.\nhorizon::S: Investment horizon. The last horizon days of the data will be used to run the algorithm.\nWₘᵢₙ::S: Minimum window size.\nWₘₐₓ::S: Maximum window size.\nλ::T: Trade-off parameter in the loss function.\nη::T: Learning rate.\n\nwarning: Beware!\nrel_pr and rel_vol should be matrixes of size n_assets × n_periods.\n\nReturns\n\nOPSAlgorithm: An OPSAlgorithm object.\n\nExample\n\njulia> using OnlinePortfolioSelection, YFinance\n\njulia> tickers = [\"AAPL\", \"MSFT\", \"GOOG\"];\n\njulia> startdt, enddt = \"2019-01-01\", \"2020-01-01\";\n\njulia> querry_open_price = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"open\"] for ticker in tickers];\n\njulia> open_pr = reduce(hcat, querry_open_price) |> permutedims;\n\njulia> querry_close_pr = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"adjclose\"] for ticker in tickers];\n\njulia> close_pr = reduce(hcat, querry_close_pr) |> permutedims;\n\njulia> querry_vol = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"vol\"] for ticker in tickers];\n\njulia> vol = reduce(hcat, querry_vol) |> permutedims;\n\njulia> rel_pr = (close_pr ./ open_pr)[:, 2:end];\n\njulia> rel_vol = vol[:, 2:end] ./ vol[:, 1:end-1];\n\njulia> size(rel_pr) == size(rel_vol)\ntrue\n\njulia> horizon = 100; Wₘᵢₙ = 4; Wₘₐₓ = 10; λ = 0.05; η = 0.01;\n\njulia> r = mrvol(rel_pr, rel_vol, horizon, Wₘᵢₙ, Wₘₐₓ, λ, η);\n\njulia> r.b\n3×100 Matrix{Float64}:\n 0.333333  0.0204062  0.0444759  …  0.38213   0.467793\n 0.333333  0.359864   0.194139      0.213264  0.281519\n 0.333333  0.61973    0.761385      0.404606  0.250689\n\nReferences\n\n[1] Online portfolio selection of integrating expert strategies based on mean reversion and trading volume.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.olmar-Tuple{Matrix{Float64}, Int64, Int64}","page":"Functions","title":"OnlinePortfolioSelection.olmar","text":"olmar(adj_close::Matrix{Float64}, ϵ::Int, ω::Int)::OPSAlgortihm\n\nRun the Online Moving Average Reversion algorithm.\n\nArguments\n\nadj_close::Matrix{Float64}: matrix of adjusted closing prices.\nϵ::Int: Reversion threshold.\nω::Int: Window size.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgortihm(n_asset, b, alg): An OPSAlgortihm object.\n\nExample\n\njulia> using OnlinePortfolioSelection\n\njulia> adj = [\n        1.315 1.326 1.358 1.39461 1.424 1.4015 1.52531\n        1.215 1.111 1.215 1.35614 1.454 1.2158 1.32561\n       ];\n\njulia> m_olmar = olmar(adj, 2, 3);\n\njulia> m_olmar.b\n2×7 Matrix{Float64}:\n 0.5  0.5  1.0  1.0  1.0  1.0  0.0\n 0.5  0.5  0.0  0.0  0.0  0.0  1.0\n\njulia> all(sum(m_olmar.b, dims=1) .≈ 1.0)\ntrue\n\nReferences\n\n[1] On-Line Portfolio Selection with Moving Average Reversion\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.opsmethods-Tuple{}","page":"Functions","title":"OnlinePortfolioSelection.opsmethods","text":"opsmethods()\n\nPrint the available methods in the package.\n\nExample\n\njulia> using OnlinePortfolioSelection\n\njulia> opsmethods()\n\n      ===== OnlinePortfolioSelection.jl =====\n            Currently available methods\n       =====================================\n\n        up: Universal Portfolio - Call `up`\n        eg: Exponential Gradient - Call `eg`\n     cornu: CORN-U - Call `cornu`\n          ⋮\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.rprt-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Float64","page":"Functions","title":"OnlinePortfolioSelection.rprt","text":"rprt(\n  adj_close::Matrix{T};\n  w::Int64=5,\n  theta::T=0.8,\n  epsilon=50\n) where T<:Float64\n\nRun RPRT algorithm.\n\nArguments\n\nadj_close::Matrix{T}: Adjusted close prices of assets.\n\nKeyword Arguments\n\nw::Int64=5: maximum length of time window to be examined.\ntheta::T=0.8: The threshold for the relative price.\nepsilon=50: The threshold for the condition of the portfolio.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): An object of type OPSAlgorithm.\n\nExamples\n\njulia> using OnlinePortfolioSelection\n\njulia> typeof(adj_close), size(adj_close)\n(Matrix{Float64}, (3, 7))\n\njulia> m_rprt = rprt(adj_close);\n\njulia> m_rprt.b\n3×7 Matrix{Float64}:\n 0.333333  0.333333  0.0  0.0  0.0  1.0  0.0\n 0.333333  0.333333  1.0  1.0  1.0  0.0  1.0\n 0.333333  0.333333  0.0  0.0  0.0  0.0  0.0\n\njulia> sum(m_rprt.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\nReference\n\n[1] Reweighted Price Relative Tracking System for Automatic Portfolio Optimization\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.sn-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}} where T<:AbstractFloat","page":"Functions","title":"OnlinePortfolioSelection.sn","text":"sn(weights::AbstractMatrix{T}, rel_pr::AbstractMatrix{T}; init_inv::T=1.) where T<:AbstractFloat\n\nCalculate the cumulative return of investment during a period of time.\n\nArguments\n\nweights::AbstractMatrix{T}: the weights of the portfolio.\nrel_pr::AbstractMatrix{T}: the relative price of the stocks.\n\nKeyword Arguments\n\ninit_inv::T=1: the initial investment.\n\nwarning: Beware!\nThe size of weights and rel_pr must be (n_stocks, n_periods).\n\nnote: Note\nIf size(rel_pr, 2) is greater than size(weights, 2), then the last size(weights, 2) columns of rel_pr will be used.\n\nReturns\n\nall_sn::Vector{T}: the cumulative return of investment during the investment period.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.uniform-Tuple{Int64, Int64}","page":"Functions","title":"OnlinePortfolioSelection.uniform","text":"uniform(n_assets::Int, horizon::Int)\n\nConstruct uniform portfolios.\n\nArguments\n\nn_assets::Int: The number of assets.\nhorizon::Int: The number of investment periods.\n\nReturns\n\n::OPSAlgorithm: An object of OPSAlgorithm type.\n\nExample\n\njulia> using OnlinePortfolioSelection\n\njulia> model = uniform(3, 10)\n\njulia> sum(model.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.up-Tuple{Matrix{Float64}}","page":"Functions","title":"OnlinePortfolioSelection.up","text":"up(adj_close::Matrix{Float64}; eval_points::Int=10^4)\n\nUniversal Portfolio (UP) algorithm.\n\nCalculate the Universal Portfolio (UP) weights and budgets using the given historical prices and parameters.\n\nArguments\n\nadj_close::Matrix{Float64}: Historical adjusted close prices.\n\nKeyword Arguments\n\neval_points::Int=10^4: Number of evaluation points.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): OPSAlgorithm object.\n\nExamples\n\njulia> using OnlinePortfolioSelection\n\njulia> typeof(adj_close), size(adj_close)\n(Matrix{Float64}, (3, 30))\n\njulia> m_up = up(adj_close);\n\njulia> m_up.b\n3×30 Matrix{Float64}:\n 0.333333  0.331149  0.33204   0.331716  …  0.326788  0.325788  0.325829  0.326222\n 0.333333  0.336058  0.335239  0.336304     0.343405  0.342161  0.342283  0.340693\n 0.333333  0.332793  0.33272   0.331981     0.329807  0.332051  0.331888  0.333086\n\njulia> sum(m_up.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\nReferences\n\n[1] Universal Portfolios\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.OPSAlgorithm","page":"Functions","title":"OnlinePortfolioSelection.OPSAlgorithm","text":"OPSAlgorithm{T<:Float64}\n\nA OPSAlgorithm object that contains the result of running the algorithm.\n\nFields\n\nn_asset::Int: Number of assets in the portfolio.\nb::Matrix{T}: Weights of the created portfolios.\nalg::String: Name of the algorithm.\n\nThe formula for calculating the cumulative return of the portfolio is as follows:\n\nS_n = S_0prodlimits_t = 1^T leftlangle b_tx_t rightrangle \n\nwhere S₀ is the initial budget, n is the investment horizon, b_t is the vector of weights of the period t, and x_t is the relative price of the t-th period.\n\n\n\n\n\n","category":"type"},{"location":"funcs/#OnlinePortfolioSelection.OPSMetrics","page":"Functions","title":"OnlinePortfolioSelection.OPSMetrics","text":"OPSMetrics(Sn::Vector{T}, APY::T, Ann_Sharpe::T, MDD::T, Calmar::T) where {T<:AbstractFloat}\n\nA struct to store the metrics of the OPS algorithm.\n\nFields\n\nSn::Vector{T}: the cumulative return of investment during the investment period.\nAPY::T: the Annual Percentage Yield (APY) of investment.\nAnn_Std::T: the Annualized Standard Deviation (σₚ) of investment.\nAnn_Sharpe::T: the Annualized Sharpe Ratio (SR) of investment.\nMDD::T: the Maximum Drawdown (MDD) of investment.\nCalmar::T: the Calmar Ratio of investment.\n\n\n\n\n\n","category":"type"},{"location":"funcs/#OnlinePortfolioSelection.OPSMetrics-Union{Tuple{S}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}} where {T<:AbstractFloat, S<:Int64}","page":"Functions","title":"OnlinePortfolioSelection.OPSMetrics","text":"OPSMetrics(\n  weights::AbstractMatrix{T},\n  rel_pr::AbstractMatrix{T};\n  init_inv::T=1.,\n  Rf::T=0.02\n  dpy::S=252,\n  v::T=0.\n  dpy::S=252\n) where {T<:AbstractFloat, S<:Int}\n\nCalculate the metrics of an OPS algorithm.\n\nArguments\n\nweights::AbstractMatrix{T}: the weights of the portfolio.\nrel_pr::AbstractMatrix{T}: the relative price of the stocks.\n\nKeyword Arguments\n\ninit_inv::T=1: the initial investment.\nRf::T=0.02: the risk-free rate of return.\ndpy::S=252: the number of days in a year.\nv::T=0.: the transaction cost rate.\n\nwarning: Warning\nThe size of weights and rel_pr must be (n_stocks, n_periods).\n\nnote: Note\nIf size(rel_pr, 2) is greater than size(weights, 2), then the last size(weights, 2) columns of rel_pr will be used.\n\nReturns\n\n::OPSMetrics: the metrics of the OPS algorithm.\n\n\n\n\n\n","category":"method"},{"location":"FW/#Follow-the-Winner-(FW)","page":"Follow the Winner","title":"Follow the Winner (FW)","text":"","category":"section"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Follow the Winner (FW) strategies believe that the best performing asset in the past will continue to perform well in the future. The following FW strategies are implemented in this package so far:","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Universal Portfolio (UP)\nExponential Gradient (EG)","category":"page"},{"location":"FW/#Universal-Portfolio","page":"Follow the Winner","title":"Universal Portfolio","text":"","category":"section"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Universal Portfolio (UP) is a FW strategy proposed by Cover (1991). The Universal Portfolio algorithm is a portfolio selection algorithm from the field of machine learning and information theory. UP aims to maximize the cumulative reurn of the portfolio during the investment horizon. The algorithm is based on the performance of the stock market on each day and the proportion of wealth invested in each stock. ","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"See up.","category":"page"},{"location":"FW/#Run-UP","page":"Follow the Winner","title":"Run UP","text":"","category":"section"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Note: This package is meant to be used by researchers NOT FOR MARKET PRACTITIONERS. Let's run the algorithm on the real market data. The data is collected as noted in the Fetch Data section.","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Let's run the algorithm on the given data (named as prices):","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"juila> using OnlinePortfolioSelection\n\njulia> size(prices)\n(17, 5)\n\n# OnlinePortfolioSelection suppose that the data is in the form of a matrix\n# where each row is the price vector of the assets at a specific time period.\njulia> prices = prices |> permutedims;\n\n# Let's run the algorithm on the last 5 days of the data.\njulia> m_up = up(prices[:, end-4:end], eval_points=100);\n\njuila> m_up.b\n5×5 Matrix{Float64}:\n 0.2  0.216518  0.216638  0.21681   0.216542\n 0.2  0.203395  0.203615  0.203754  0.203528\n 0.2  0.191899  0.191793  0.192316  0.192473\n 0.2  0.193023  0.192302  0.191687  0.19208\n 0.2  0.195164  0.195652  0.195433  0.195377","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"One can calculate the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(m_up.b, rel_price)\n6-element Vector{Float64}:\n 1.0\n 0.9879822623031318\n 0.9856240412854884\n 0.9874863498385578\n 0.9778277061434468\n 0.9718529924971879","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"The result indicates that if we had invested in the given period, we would have lost ~2.8% of our wealth. Note that sn automatically takes the last 5 relative prices in this case. Now, let's investiagte the performance of the algorithm according to some of the prominent metrics:","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"julia> results = OPSMetrics(m_up.b, rel_price)\n\n            Cumulative Return: 0.972\n                          APY: -0.763\nAnnualized Standard Deviation: 0.088\n      Annualized Sharpe Ratio: -8.857\n             Maximum Drawdown: 0.028\n                 Calmar Ratio: -27.101\n\njulia> results.\nAPY         Ann_Sharpe  Ann_Std     Calmar      MDD         Sn\n\njulia> results.MDD\n0.02814700750281207","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"It is worht mentioning that each metric can be accessed individually by writing results. and pressing Tab key. Note that one can individually investigate the performance of the algorithm regarding each metric. See sn, ann_std, apy, ann_sharpe, mdd, and calmar. See Performance evaluation section for more information.","category":"page"},{"location":"FW/#Exponential-Gradient","page":"Follow the Winner","title":"Exponential Gradient","text":"","category":"section"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Exponential Gradient (EG) is a FW strategy proposed by Helmbold et al. (1998). Authors claim that EG can achieve almost the same wealth as the best constantrebalanced portfolio (BCRP) determined in hindsight from the actual market outcomes. the algorithm is very simple to implement and requires only constant storage and computing time per stock in each trading period.","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"See eg.","category":"page"},{"location":"FW/#Run-EG","page":"Follow the Winner","title":"Run EG","text":"","category":"section"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Let's run the algorithm on the real market data. The data is collected as noted in the \"Fetch-Data\" section.","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"juila> using OnlinePortfolioSelection\n\njulia> size(prices)\n(17, 5)\n\n# OnlinePortfolioSelection suppose that the data is in the form of a matrix\n# where each row is the price vector of the assets at a specific time period.\njulia> prices = prices |> permutedims;\n\n# Let's run the algorithm on the last 5 days of the data.\njulia> m_eg = eg(prices[:, end-4:end], eta=0.02);\n\njuila> m_eg.b\n5×5 Matrix{Float64}:\n 0.2  0.200001  0.200016  0.20003   0.199997\n 0.2  0.200049  0.200073  0.200087  0.200064\n 0.2  0.19999   0.199973  0.200029  0.200051\n 0.2  0.199937  0.199846  0.19978   0.199827\n 0.2  0.200023  0.200092  0.200074  0.200061 ","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"One can calculate the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(m_eg.b, rel_price)\n6-element Vector{Float64}:\n 1.0\n 0.9879822623031318\n 0.9854825989102248\n 0.98713136445759\n 0.9773624367829401\n 0.9716549466747438","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"The result indicates that if we had invested in the given period, we would have lost ~2.8% of our wealth. Note that sn automatically takes the last 5 relative prices in this case. Now, let's investiagte the performance of the algorithm according to some of the prominent metrics:","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"julia> results = OPSMetrics(m_eg.b, rel_price)\n\n            Cumulative Return: 0.972\n                          APY: -0.765\nAnnualized Standard Deviation: 0.087\n      Annualized Sharpe Ratio: -9.005\n             Maximum Drawdown: 0.028\n                 Calmar Ratio: -26.9\n\njulia> results.\nAPY         Ann_Sharpe  Ann_Std     Calmar      MDD         Sn\n\njulia> results.MDD\n0.028345053325256164","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"It is worht mentioning that each metric can be accessed individually by writing results. and pressing the Tab key. Note that one can individually investigate the performance of the algorithm regarding each metric. See sn, ann_std, apy, ann_sharpe, mdd, and calmar. See Performance evaluation section for more information.","category":"page"},{"location":"Combined/#Introduction","page":"Combined Strategies","title":"Introduction","text":"","category":"section"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"Nowadays researchers are trying to take advantage of each strategy and propose new methods that combine them. I plan to implement some of these methods in this package. A list of the methods that I've implemented so far is as follows:","category":"page"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"LOcal ADaptive learning system (LOAD)\nMRvol","category":"page"},{"location":"Combined/#LOcal-ADaptive-learning-system-(LOAD)","page":"Combined Strategies","title":"LOcal ADaptive learning system (LOAD)","text":"","category":"section"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"Guan & An (2019) proposed a new OPS method, named LOcal ADaptive learning system (LOAD), which is a combination of the Follow the Winner (FW) and Follow the Loser principles. They tried to find the stocks that have a positive trend in the most recent time window by fitting a linear regression on the price data of the stocks against time. They used momentum principle to predict the next price of assets in this case. On the other hand, for the stocks that does not have a satisfactory trend in the most recent time window, they used the mean reversion principle to predict the next price of assets. They claim that through this fusion, the overall system can be more adaptive and effective than systems based on single strategies. After predicting the next prices, the next relative prices are predicted and used in the portfolio optimization.","category":"page"},{"location":"Combined/#Run-LOAD","page":"Combined Strategies","title":"Run LOAD","text":"","category":"section"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"Note: This package is meant to be used by researchers NOT FOR MARKET PRACTITIONERS. Let's run the algorithm on the real market data.","category":"page"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"julia> using OnlinePortfolioSelection, YFinance\n\njulia> tickers = [\"AAPL\", \"MSFT\", \"AMZN\"];\n\njulia> startdt, enddt = \"2022-04-01\", \"2023-04-27\";\n\njulia> prices = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"adjclose\"] for ticker in tickers];\n\njulia> prices = reduce(hcat, prices);\n\njulia> prices = prices |> permutedims;\n\njulia> d_fac, window, horizon, eta = 0.5, 10, 5, 0.1;\n\njulia> model, St = load(prices, d_fac, window, horizon, eta);\n\n# Get the portfolio weights\njulia> model.b\n3×5 Matrix{Float64}:\n 0.333333  2.65043e-10  1.65697e-8  0.669392  0.329286\n 0.333333  1.0          1.0         0.330608  0.670714\n 0.333333  0.0          0.0         0.0       0.0 \n\n# Get the cumulative wealth of the portfolio over the trading period\njulia> St\n6-element Vector{Float64}:\n 1.0\n 0.9937811173943497\n 0.9925654837139548\n 0.9787063658040356\n 0.9652327928615669\n 1.012107319760618","category":"page"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"The result indicates that if we had invested in the given period, we would have gained ~1.2% profit. Now, let's investiagte the performance of the algorithm according to some of the prominent metrics:","category":"page"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"juli> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> metrics = OPSMetrics(model.b, rel_price)\n            Cumulative Return: 1.0121073197606183\n                          APY: 0.8340827024050514\nAnnualized Standard Deviation: 0.40329283437815505\n      Annualized Sharpe Ratio: 2.0185895533212266\n             Maximum Drawdown: 0.034767207138433065\n                 Calmar Ratio: 23.990500562325092\n\njulia> metrics.Sn\n6-element Vector{Float64}:\n 1.0\n 0.9937811173943497\n 0.9925654837139548\n 0.9787063658040356\n 0.9652327928615669\n 1.0121073197606183","category":"page"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"It is worht mentioning that each metric can be accessed individually by writing results. and pressing the Tab key. Note that one can individually investigate the performance of the algorithm regarding each metric. See sn, ann_std, apy, ann_sharpe, mdd, and calmar. See Performance evaluation section for more information.","category":"page"},{"location":"Combined/#MRvol","page":"Combined Strategies","title":"MRvol","text":"","category":"section"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"Combination of meta-learning algorithms with other strategies are also investogated. For example, Lin et al. (2023) proposed a new OPS method, named MRvol, which is a combination of the Follow the Loser (FL) and Meta-Learning (ML) strategies. First, they try to select the stocks that have the relative price bellow than 1 as the first filter, and then search for the stock that have the most relative volume value among the filtered stocks as the second filter. Then, they apply a meta-algorithm to integrate expert opinions (i.e., expert strategies), which are obtained based on mean reversion and trading volume. Thirdly, they determine the window size of the expert strategy as W and establish an expert strategy. When the expert constructs a stock portfolio, he/she identifies an investment target asset for each period, so there are W investment target assets. As they said, in order to reduce investment risk and increase diversification of investment, this paper considers using moving window data of different sizes to construct a pool of expert strategies, which is also called a pool of expert opinions, and then applies meta-algorithm in machine learning technique to integrate expert opinions to propose an investment strategy.","category":"page"},{"location":"Combined/#Run-MRvol","page":"Combined Strategies","title":"Run MRvol","text":"","category":"section"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"Let's run the algorithm on the real market data.","category":"page"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"julia> using OnlinePortfolioSelection, YFinance\n\njulia> tickers = [\"AAPL\", \"MSFT\", \"GOOG\"];\n\njulia> startdt, enddt = \"2019-01-01\", \"2020-01-01\";\n\njulia> querry_open_price = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"open\"] for ticker in tickers];\n\njulia> open_pr = reduce(hcat, querry_open_price) |> permutedims;\n\njulia> querry_close_pr = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"adjclose\"] for ticker in tickers];\n\njulia> close_pr = reduce(hcat, querry_close_pr) |> permutedims;\n\njulia> querry_vol = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"vol\"] for ticker in tickers];\n\njulia> vol = reduce(hcat, querry_vol) |> permutedims;\n\njulia> rel_pr = (close_pr ./ open_pr)[:, 2:end];\n\njulia> rel_vol = vol[:, 2:end] ./ vol[:, 1:end-1];\n\njulia> size(rel_pr) == size(rel_vol)\ntrue\n\njulia> horizon = 100; Wₘᵢₙ = 4; Wₘₐₓ = 10; λ = 0.05; η = 0.01;\n\njulia> r = mrvol(rel_pr, rel_vol, horizon, Wₘᵢₙ, Wₘₐₓ, λ, η);\n\njulia> r.b\n3×100 Matrix{Float64}:\n 0.333333  0.0204062  0.0444759   …   0.38213   0.467793      \n 0.333333  0.359864   0.194139        0.213264  0.281519\n 0.333333  0.61973    0.761385        0.404606  0.250689\n\njulia> sum(r.b, dims=1) .|> isapprox(1.0) |> all\ntrue","category":"page"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"Now, let's investiagte the performance of the algorithm according to some of the prominent metrics:","category":"page"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"julia> metrics = OPSMetrics(r.b, rel_pr)\n            Cumulative Return: 1.0277067897356449\n                          APY: 0.07129838196490379\nAnnualized Standard Deviation: 0.1224831726093685\n      Annualized Sharpe Ratio: 0.41881983354977265\n             Maximum Drawdown: 0.0692690958483587\n                 Calmar Ratio: 1.0292956922808336\n\njulia> metrics.Sn\n101-element Vector{Float64}:\n 1.0\n 0.9945454662509302\n 0.9889386321026037\n 1.0108661401532446\n ⋮\n 1.0219508111711197\n 1.0185657113697373\n 1.0277067897356449","category":"page"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"The result of metrics.Sn indicates that if we had invested in the given period, we would have gained ~2.8% profit. It is worht mentioning that each metric can be accessed individually by writing results. and pressing the Tab key. Note that one can individually investigate the performance of the algorithm regarding each metric. See sn, ann_std, apy, ann_sharpe, mdd, and calmar. See Performance evaluation section for more information.","category":"page"},{"location":"python/#Use-OnlinePortfolioSelection.jl-in-Python","page":"Use In Python","title":"Use OnlinePortfolioSelection.jl in Python","text":"","category":"section"},{"location":"python/","page":"Use In Python","title":"Use In Python","text":"Generally, Julia packages can be used in a Python environtment easily using packages than can wrap Julia packages into Python packages. For example, PyJulia is one of the most popular wrapper packages in this area. There is a comprehensive installation guide in the PyJulia documentation. Please follow the instructions there to install PyJulia and Julia. Importing Julia packages into Python is discussed before (i.e., see [1, 2]). In this section, I'll show how to use OnlinePortfolioSelection.jl in Python. If you had issues with importing the package, please check this discussion.","category":"page"},{"location":"python/","page":"Use In Python","title":"Use In Python","text":"Install PyJulia: pip install julia. Make sure the Julia path is registered in the system environment variable PATH (i.e., julia can be called in the command line). The Julia path is usually \\.julia\\juliaup\\julia-<VERSION>\\bin or C:\\Users\\your-user-name\\AppData\\Local\\Programs\\Julia\\Julia-<VERSION>\\bin.\nRun Python\nEnter the following commands in Python (Here, I run the MRvol algorithm as an example):","category":"page"},{"location":"python/","page":"Use In Python","title":"Use In Python","text":">>> from julia import Pkg\n>>> Pkg.add(\"OnlinePortfolioSelection\")\n>>> from julia import OnlinePortfolioSelection as OPS\n\n# Generate a random relatvive price matrix. The rows are the assets, and the columns represent the time.\n>>> import numpy as np\n>>> rel_pr = np.random.rand(3, 100)\n>>> rel_vol = np.random.rand(3, 100)\n>>> horizon, Wmin, Wmax, lambdaa, eta = (10, 4, 10, 0.05, 0.01)\n>>> model = OPS.mrvol(rel_pr, rel_vol, horizon, Wmin, Wmax, lambdaa, eta)\n>>> type(model)\n<class 'PyCall.jlwrap'>\n>>> model.b\narray([[0.33333333, 0.36104291, 0.3814967 , 0.26303273, 0.16525094,\n        0.23471654, 0.28741473, 0.34746891, 0.41769629, 0.34582386],\n      [0.33333333, 0.35745995, 0.24895616, 0.30306051, 0.36527706,\n        0.2817696 , 0.36959982, 0.43371551, 0.48357232, 0.51374896],\n      [0.33333333, 0.28149714, 0.36954713, 0.43390676, 0.469472  ,\n        0.48351386, 0.34298546, 0.21881558, 0.09873139, 0.14042718]])\n>>> type(model.b)\n<class 'numpy.ndarray'>\n>>> model.b.sum(axis=0)\narray([1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])\n>>> model.alg\n'MRvol'\n>>> model.n_assets\n3","category":"page"},{"location":"python/","page":"Use In Python","title":"Use In Python","text":"As shown above, the mrvol function returns a PyCall.jlwrap object. The portfolio weights can be accessed by model.b which are automatically converted to a numpy.ndarray object. The other attributes of the model object can be accessed in the same way. In order to check the attributes of the model object, you can check the returned object by the mrvol function. Let's continue and calculate the performance of the algorithm according to some of the prominent metrics:","category":"page"},{"location":"python/","page":"Use In Python","title":"Use In Python","text":">>> metrics = OPS.OPSMetrics(model.b, rel_pr)\n>>> metrics\n\n<PyCall.jlwrap             Cumulative Return: 0.0003879435247256176\n                          APY: -1.0\nAnnualized Standard Deviation: 2.7595804965778328\n      Annualized Sharpe Ratio: -0.36962139762362656\n             Maximum Drawdown: 0.9996120564752744\n                 Calmar Ratio: -1.0003880940833123\n\n>>> metrics.Sn\narray([1.00000000e+00, 5.75525607e-01, 1.45701657e-01, 7.12853019e-02,\n       4.30702987e-02, 2.03865521e-02, 1.53802433e-02, 7.10270166e-03,\n       1.97878448e-03, 8.65966074e-04, 3.87943525e-04])","category":"page"},{"location":"python/","page":"Use In Python","title":"Use In Python","text":"As shown above, the OPSMetrics function returns a PyCall.jlwrap object. The cumulative wealth of portfolios can be accessed by metrics.Sn which are automatically converted to a numpy.ndarray object. The other attributes of the metrics object can be accessed in the same way. In order to check the attributes of the metrics object, you can check the returned object by the OPSMetrics function. It's worth mentioning that you can get the documentation of each function through Python. For example, you can get the documentation of the mrvol function using the following commands:","category":"page"},{"location":"python/","page":"Use In Python","title":"Use In Python","text":">>> from julia import Main as jl\n>>> jl.Docs.doc(OPS.mrvol)\n<PyCall.jlwrap mrvol(       rel*pr::AbstractMatrix{T},       rel*vol::AbstractMatrix{T},       horizon::S,       Wₘᵢₙ::S,       Wₘₐₓ::S,       λ::T,       η::T     ) where {T<:AbstractFloat, S<:Integer}\n\nRun MRvol algorithm.\n\n# Arguments\n\n  * `rel_pr::AbstractMatrix{T}`: Relative price matrix where it represents proportion of the closing price to the opening price of each asset in each day.\n  * `rel_vol::AbstractMatrix{T}`: Relative volume matrix where 𝘷ᵢⱼ represents the tᵗʰ trading volume of asset 𝑖 divided by the (t - 1)ᵗʰ trading volume of asset 𝑖.\n  * `horizon::S`: Investment horizon. The last `horizon` days of the data will be used to run the algorithm.\n  * `Wₘᵢₙ::S`: Minimum window size.\n  * `Wₘₐₓ::S`: Maximum window size.\n  * `λ::T`: Trade-off parameter in the loss function.\n  * `η::T`: Learning rate.\n\n# Returns\n\n  * `OPSAlgorithm`: An [`OPSAlgorithm`](@ref) object.\n\n# Example\n\n...","category":"page"},{"location":"benchmark/#Benchmark-Strategies","page":"Benchmark","title":"Benchmark Strategies","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Some strategies in the context of online portfolio selection are considered as benchmark strategies. The simplest benchmark strategy is the Buy and Hold (BH) strategy which is called as the market strategy. The BAH model invests equally in m assets at the beginning and remains unchanged during the next periods, thus the weights of assets change passively with their price variations. A special BAH model, the Best-Stock (BS), invests all the capital into the best asset over the periods which is an optimal BAH in hindsight. Overall, the Benchmark portfolio selection models are quite simple because they do not adopt complex or sophisticated techniques via statistics and machine learning to explore the patterns within the data. Thus they are often taken as the baselines for performance comparison with new designed models. Another benchmark strategy is the Constant Rebalanced Portfolio (CRP) which assigns a fixed weight to each asset throughout a given period. The following strategies are implemented in this package so far:","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Constant Rebalanced Portfolio (CRP)\nBest Stock (BS)\nUniform Portfolio (1/N)","category":"page"},{"location":"benchmark/#CRP","page":"Benchmark","title":"CRP","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Let's run the algorithm on the real market data. Assume the data (named as prices) is collected as noted in the Fetch Data section.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"juila> using OnlinePortfolioSelection\n\njulia> size(prices)\n(17, 5)\n\n# OnlinePortfolioSelection suppose that the data is in the form of a matrix\n# where each row is the price vector of the assets at a specific time period.\njulia> prices = prices |> permutedims;\n\n# Let's run the algorithm on the last 5 days of the data.\njulia> m_crp = crp(prices[:, end-4:end]);\n\njuila> m_crp.b\n5×5 Matrix{Float64}:\n 0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"One can calculate the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(m_crp.b, rel_price)\n6-element Vector{Float64}:\n 1.0\n 0.9879822623031318\n 0.9854808899164217\n 0.9871240426268018\n 0.977351149446221\n 0.9716459683279461","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"The result indicates that if we had invested in the given period, we would have lost ~2.8% of our capital. Note that sn automatically takes the last 5 relative prices in this case. Now, let's investiagte the performance of the algorithm according to some of the prominent metrics:","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"julia> results = OPSMetrics(m_crp.b, rel_price)\n\n            Cumulative Return: 0.972\n                          APY: -0.765\nAnnualized Standard Deviation: 0.087\n      Annualized Sharpe Ratio: -9.008\n             Maximum Drawdown: 0.028\n                 Calmar Ratio: -26.993\n\njulia> results.\nAPY         Ann_Sharpe  Ann_Std     Calmar      MDD         Sn\n\njulia> results.MDD\n0.02835403167205386","category":"page"},{"location":"benchmark/#BS","page":"Benchmark","title":"BS","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"This model is a subset of the BAH strategy in which the best stock is acquired retroactively. In this package, users can choose the number of days to look back (through last_n keyword argument) and find the best stock. If the last_n is not provided or is set to 0, the algorithm will consider the whole data until the day at each period to find the best stock. Otherwise, the algorithm will consider the last last_n days performance of each stock and chooses the best one. Let's run the algorithm on the real market data. Assume the data (named as prices) is collected as noted in the Fetch Data section.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"juila> using OnlinePortfolioSelection\n\njulia> size(prices)\n(17, 5)\n\n# OnlinePortfolioSelection suppose that the data is in the form of a matrix\n# where each row is the price vector of the assets at a specific time period.\njulia> prices = prices |> permutedims;\n\n# Let's run the algorithm on the last 10 days of the data.\njulia> m_bs = bs(prices[:, end-9:end]);\n\njuila> m_bs.b\n5×10 Matrix{Float64}:\n 0.2  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.2  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.2  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.2  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.2  1.0  0.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"After running the algorithm, one can calculate the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(m_bs.b, rel_price)\n11-element Vector{Float64}:\n 1.0\n 1.0067934076484562\n 1.009228482491198\n 1.0188656476194202\n 1.0387633347003844\n 1.0354766468359777\n 1.027215571086806\n 1.0305022589512125\n 1.0499557074411052\n 1.0350324760158582\n 1.0255278032954953","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"The result indicates that if we had invested in the given period, we would have gained ~2.6% of our capital. Note that sn automatically takes the last 10 relative prices in this case.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Note that this package provides functions to analyze the performance of the algorithm. See the Performance evaluation section for more details.","category":"page"},{"location":"benchmark/#/N","page":"Benchmark","title":"1/N","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"This model invests equally in all assets. Let's run the algorithm:","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"juila> using OnlinePortfolioSelection\n\njulia> size(prices)\n(17, 5)\n\n# OnlinePortfolioSelection suppose that the data is in the form of a matrix\n# where each row is the price vector of the assets at a specific time period.\njulia> prices = prices |> permutedims;\n\n# Let's run the algorithm on the last 10 days of the data.\njulia> m_uni = uniform(5, 10);\n\njuila> m_uni.b\n5×10 Matrix{Float64}:\n 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"After running the algorithm, one can calculate the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(m_uni.b, rel_price)\n11-element Vector{Float64}:\n 1.0\n 1.006793403065235\n 1.0044027643134168\n 1.0040238271404696\n 1.0051064998568846\n 0.9884495565932121\n 0.9765706200501145\n 0.9740981677925922\n 0.9757223268076264\n 0.9660623342882886\n 0.960423009921307","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"The result indicates that if we had invested in the given period, we would have lost ~3.9% of our capital. Note that sn automatically takes the last 10 relative prices in this case.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Note that this package provides functions to analyze the performance of the algorithm. See the Performance evaluation section for more details.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = quote\n    using OnlinePortfolioSelection\nend","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Online Portfolio Selection (OPS) strategies are trading algorithms that sequentially allocate capital among a group of assets to maximize the final returns of the investment. It is a fundamental problem in computational finance that has been extensively studied across several research communities, including finance, statistics, artificial intelligence, machine learning, and data mining. From an online machine learning perspective, it is formulated as a sequential decision problem and there are a variety of state-of-the-art approaches that have been developed to solve it. These approaches are grouped into several major categories, including benchmarks, “Follow-the-Winner” approaches, “Follow-the-Loser” approaches, “Pattern-Matching” based approaches, and \"Meta-Learning\" Algorithms [1]. This package provides an efficient implementation of OPS algorithms. The algorithms are implemented in Julia in a fully type-stable manner. All the algorithms return an object of type OPSAlgorithm which can be used to query the portfolio weights, number of assets, and the name of the algorithm. Sixteen algorithms are implemented so far and more will be added in the future. The available algorithms are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Constant Rebalanced Portfolio (CRP)\nExponential Gradient (EG)\nUniversal Portfolio (UP)\nCorrelation-driven Nonparametric Learning","category":"page"},{"location":"","page":"Home","title":"Home","text":"4.1 CORN-U\n4.2 CORN-K","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dynamic RIsk CORrelation-driven Non-parametric (DRICORN-K)\nBest Stock (BS)\nReweighted Price Relative Tracking (RPRT)\nAnti-Correlation (Anticor)\nOnline Moving Average Reversion (OLMAR)\nBᴷ\nLOcal ADaptive learning system (LOAD)\nMRvol\nCombination Weights based on Online Gradient Descent (CW-OGD)\nUniform Portfolio (1/N)\nCLUSLOG (contains the KMNLOG and KMDLOG variants)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The available methods can be viewed by calling the opsmethods function.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The latest stable version of the package can be installed by running the following command in the Julia REPL after pressing ]:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add OnlinePortfolioSelection","category":"page"},{"location":"","page":"Home","title":"Home","text":"or","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"OnlinePortfolioSelection\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or even","category":"page"},{"location":"","page":"Home","title":"Home","text":"juila> using Pkg; pkg\"add OnlinePortfolioSelection\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"The dev version can be installed usint the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/shayandavoodii/OnlinePortfolioSelection.jl.git","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be imported by running the following command in the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using OnlinePortfolioSelection","category":"page"},{"location":"","page":"Home","title":"Home","text":"One can perform several strategies on a given dataset and analyse and compare the results. The following code snippet shows how to perform the strategies on a given dataset and compare the results:","category":"page"},{"location":"","page":"Home","title":"Home","text":"juila> using CSV, DataFrames\n\n# read adjusted close prices\njulia> pr = CSV.read(\"data\\\\sp500.csv\", DataFrame) |> Matrix |> permutedims;\n\njulia> pr = pr[2:end, :];\n\njulia> market_pr = pr[1, :];\n\njulia> size(pr)\n(24, 1276)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The dataset contains the adjusted close prices of 24 stocks in the S&P 500 within 1276 trading days. Now, suppose we want to perform the strategies on the last 50 days of the dataset with default arguments:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> m_corn_u = cornu(pr, 50, 3);\n\njulia> m_corn_k = cornk(pr, 50, 3, 2, 2);\n\njuila> m_drcorn_k = dricornk(pr, market_pr, 50, 5, 5, 5);","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now, let's plot the trend of daily cumulative budgets of each algorithm. For this, we have to calculate it using the achieved portfolio weights and relative prices in the same time period:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# calculate the relative prices\njulia> rel_pr = pr[:, 2:end] ./ pr[:, 1:end-1];\n\njulia> models = [m_corn_u, m_corn_k, m_drcorn_k];\n\n# calculate the cumulative budgets\njulia> budgets = [sn(model.b, rel_pr[:, end-49:end]) for model in models];\n\njulia> using Plots\n\njulia> plot(\n            budgets, \n            label = [\"CORN-U\" \"CORN-K\" \"DRICORN-K\"], \n            xlabel = \"Day\", ylabel = \"Cumulative return\", legend = :bottomleft,\n       )","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"assets/cumulative_budgets.png\" width=\"100%\">","category":"page"},{"location":"","page":"Home","title":"Home","text":"The plot shows that the cumulative return of CORN-K outperforms the other algorithms almost all the time. Note that the initial investment for all of the algorithms is set to 1 (this can be modified by setting the keyword argument init_budg for each algorithm). Now, let's investigate the performance of the algorithms in terms of some of prominent performance metrics:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> all_metrics = OPSMetrics.([m_corn_u.b, m_corn_k.b, m_drcorn_k.b], Ref(rel_pr));","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now, one can embed the metrics in a DataFrame and compare the performance of the algorithms with respect to each other:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using DataFrames\n\njulia> nmodels = length(all_metrics);\n\njulia> comp_algs = DataFrame(\n           Algorithm = [\"CORN-U\", \"CORN-K\", \"DRICORN-K\"],\n           APY = [all_metrics[i].APY for i = 1:nmodels],\n           Ann_Sharpe = [all_metrics[i].Ann_Sharpe for i = 1:nmodels],\n           Ann_Std = [all_metrics[i].Ann_Std for i = 1:nmodels],\n           Calmar = [all_metrics[i].Calmar for i = 1:nmodels],\n           MDD = [all_metrics[i].MDD for i = 1:nmodels],\n       )\n3×6 DataFrame\n Row │ Algorithm  APY        Ann_Sharpe  Ann_Std   Calmar    MDD       \n     │ String     Float64    Float64     Float64   Float64   Float64   \n─────┼─────────────────────────────────────────────────────────────────\n   1 │ CORN-U     -0.126009   -0.505762  0.288691  -1.25383  0.100499\n   2 │ CORN-K      0.826495    2.48378   0.324705  17.688    0.0467263\n   3 │ DRICORN-K  -0.248393   -1.20933   0.221934  -2.54505  0.0975985","category":"page"},{"location":"","page":"Home","title":"Home","text":"The comp_algs shows that CORN-K outperforms the other algorithms in terms of annualizeed percentage yield (APY), annualized Sharpe ratio, Calmar ratio, and maximum drawdown (MDD). However, the annualized standard deviation of CORN-K is higher than the other algorithms in this dataset. Note that these metrics can be calculated individually by calling the corresponding sn, apy, ann_sharpe, ann_std, calmar, and mdd functions. See the Performance evaluation for more details.","category":"page"}]
}
