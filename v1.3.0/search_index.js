var documenterSearchIndex = {"docs":
[{"location":"PM/#Pattern-matching-algorithms","page":"Pattern-Matching","title":"Pattern-matching algorithms","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Pattern-matching algorithms are one of most popular algorithms in the context of online portfolio selection. The main idea behind these algorithms is to find a pattern in the past price data and use it to predict the future price. These strategies are in consensus with technical analysts perspective. Technical analysts believe that the historical patterns in the price data will repeat in the future. The following pattern-matching algorithms are implemented in this package so far:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Correlation-driven Nonparametric Learning","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"1.1. CORN-U   1.2. CORN-K","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Dynamic RIsk CORrelation-driven Non-parametric","category":"page"},{"location":"PM/#Correlation-driven-Nonparametric-Learning","page":"Pattern-Matching","title":"Correlation-driven Nonparametric Learning","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Correlation-driven Nonparametric Learning (CORN) is a pattern-matching algorithm proposed by Borodin et al. (2010). CORN utilizes the correlation as the similarity measure between time windows. Additionally, CORN defines several experts to construct portfolios. For each trading day, CORN combines the portfolios of the experts to construct the final portfolio. This is where CORN-K and CORN-U differ. CORN-K uses K best experts (based on their performance on historical data) to construct the final portfolio. On the other hand, CORN-U uses all the experts and uniformly combines their portfolios to construct the final portfolio. See cornu and cornk. ","category":"page"},{"location":"PM/#Run-CORN-U","page":"Pattern-Matching","title":"Run CORN-U","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"The most important parameters of CORN-U are w (maximum window size to be examined) and rho (correlation threshold). The higher the w is, the more window sizes are examined; consequently, the more time it takes to run the algorithm. However, the algorithm performs more accurately. The former is not true for rho. The authors have recommended to avoid extreme values for rho (e.g., 0.99 or 0.01). Since CORN aims to find time windows positive directional correlation, the negative values of rho are not allowed. Authors have found that the best values for rho in their experiments are 0.2. As a result, the default value for rho is set to 0.2.","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Since CORN family algorithms perform better when they are trained on a long period of time, we use the data of a longer period of time (e.g., ~1 year) to train the algorithm. Then, we use the data of a shorter period of time (e.g., last 10 days) to perform the portfolio selection.","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"juila> using OnlinePortfolioSelection\n\njulia> size(prices)\n(268, 5)\n\n# OnlinePortfolioSelection suppose that the data is in the form of a matrix\n# where each row is the price vector of the assets at a specific time period.\njulia> prices = prices |> permutedims;\n\n# run the algorithm on the last 5 days\njulia> horizon, w = 5, 10\n\njulia> model = cornu(prices, horizon, w)\n\njulia> model.b\n5×5 Matrix{Float64}:\n 0.0       0.198536  0.0995612  0.0        0.0\n 0.0       0.389272  0.0        0.0        0.0980504\n 0.0       0.0       0.430479   0.0998267  0.0\n 0.714743  0.0       0.0        0.0        0.203183\n 0.285257  0.412192  0.46996    0.900173   0.698766","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"One can compute the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(model.b, rel_price)\n6-element Vector{Float64}:\n 1.0\n 0.9910701218600744\n 0.9956345799968089\n 1.0038929232387375\n 0.9914403615208097\n 0.9851289224781754","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"The result indicates that the algorithm has lost 1.5% of the initial wealth during the investment period. Further analysis of the algorithm can be done by using the ann_std, apy, ann_sharpe, mdd, and calmar functions. See Performance evaluation section for more information.","category":"page"},{"location":"PM/#Run-CORN-K","page":"Pattern-Matching","title":"Run CORN-K","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"The most important parameters of CORN-K are k (number of best experts to be used for portfolio construction), w (maximum window size to be examined), and rho (number of correlation coefficient thresholds to be examined). Since CORN-K uses the best experts to construct the final portfolio, it is supposed to perform better than CORN-U. Let's run CORN-K on the same data as CORN-U:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"# run the algorithm on the last 5 days\njulia> horizon, k, w, rho = 5, 10, 5, 5, 5;\n\njulia> model = cornk(prices, horizon, k, w, rho);\n\njulia> model.b","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Last but not least, the cumulative return of the algorithm on the investment period and given dataset can be computed by using the sn function:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(model.b, rel_price)\n6-element Vector{Float64}:\n 1.0\n 0.9920219584145965\n 0.997769753240107\n 1.0153550964116513\n 1.004610801506029\n 1.0017637293758395","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"As mentioned earlier, CORN-K performed better than CORN-U on the same dataset. The result indicates that the algorithm has gained ~0.18% of the initial wealth during the investment period. Further analysis of the algorithm can be done by using the ann_std, apy, ann_sharpe, mdd, and calmar functions. See Performance evaluation section for more information.","category":"page"},{"location":"PM/#Dynamic-RIsk-CORrelation-driven-Non-parametric","page":"Pattern-Matching","title":"Dynamic RIsk CORrelation-driven Non-parametric","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Dynamic RIsk CORrelation-driven Non-parametric (DRICORN) follows the same idea as CORN-K. However, DRICORN considers the beta of portfolio as a measure of risk in the portfolio optimization. Furthermore, they consider the recent trend of market in order to take advantage of positive risks, and avoid negative risks. See dricornk.","category":"page"},{"location":"PM/#Run-DRICORN-K","page":"Pattern-Matching","title":"Run DRICORN-K","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Since this algorithm is built on top of CORN-K, it shares the similar parameters with CORN-K. Nevertheless, DRICORN-K needs the data of the market index (e.g., S&P 500) in order to compute the beta of the portfolio, and the trend of the market. It is worth mentioning that the algorithm also takes a coefficient in order to regularize the beta of the portfolio. The default value for this coefficient is 1e-3. Let's run DRICORN-K on the same data as CORN-U and CORN-K:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"# run the algorithm on the last 5 days\njulia> horizon, k, w, rho = 5, 10, 5, 5, 5;\n\njulia> model = dricornk(prices, market_prices, horizon, k, w, rho);\n\njulia> model.b\n4×5 Matrix{Float64}:\n 0.0  0.25  0.25  0.25  0.17438\n 0.0  0.25  0.25  0.25  0.17438\n 0.0  0.25  0.25  0.25  0.174281\n 1.0  0.25  0.25  0.25  0.476959","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Using sn function, one can compute the cumulative wealth during the investment period:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(model.b, rel_price)\n6-element Vector{Float64}:\n 1.0\n 0.9906902403938972\n 0.9867624995658737\n 0.9841621752990845\n 0.9754797369845584\n 0.9738144349688777","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"The result indicates that the algorithm has lost ~2.6% of the initial wealth during the investment period. Further analysis of the algorithm can be done by using the ann_std, apy, ann_sharpe, mdd, and calmar functions. See Performance evaluation section for more information.","category":"page"},{"location":"performance_eval/#Performance-evaluation","page":"Performance Evaluation","title":"Performance evaluation","text":"","category":"section"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"This package provides a set metrics to evaluate the performance of the algorithms. The metrics are prominent in the literature and are used to compare the performance of different algorithms. Currently, the following metrics are supported:","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"Cumulative Return (CR, Also known as S_n)\nThis metric calculates the cumulative return of the algorithm during the investment period. The cumulative return is defined as:  \n$  \\begin{aligned}  {Sn} = {S0}\\prod\\limits{t = 1}^T {\\left\\langle {{bt},{x_t}} \\right\\rangle }  \\end{aligned}  $\nwhere S_0 is the initial capital, b_t is the portfolio vector at time t and x_t is the relative price vector at time t. This metric can be calculated by using the sn function.\nAnnualized Return (APY)\nThis metric calculates the annualized return of the algorithm during the investment period. The annualized return is defined as:    $  \\begin{aligned}  {APY} = \\left( {{S_n}} \\right)^{\\frac{1}{y}} - 1  \\end{aligned}  $    where y is the number of years in the investment period. This metric can be calculated by using the apy function.\nAnnualized Standard Deviation (sigma_p)\nAnother measurement used to examine the risk is the annual standard deviation of returns of the portfolio. The daily standard deviation is calculated to compute the annual standard deviation and then it is multiplied by sqrt252 (it is assumed that there are 252 days of each year). However, users can change the number of days in a year by setting the dpy keyword argument. This metric can be calculated by using the ann_std function.\nAnnualized Sharpe Ratio (SR)\nThe Sharpe ratio is a measure of risk-adjusted return. It is defined as:    $  \\begin{aligned}  SR = {{APY - {Rf}} \\over {{\\sigma _p}}}  \\end{aligned}  $    where Rf$ is the risk-free rate which is considered to be equal to the treasury bill rate at the time of investment. This metric can be calculated by using the ann_sharpe function.\nMaximum Drawdown (MDD)\nThe maximum drawdown is the maximum loss from a peak to a trough of a portfolio, before a new peak is attained. Calculation of MDD is based on the capital break value. Capital break can be considered as one of the most important criteria to evaluate the capital market which is equal to the upper bound of decline from the peak of portfolio cumulative function. Capital break is defined as:    $  \\begin{aligned}  DD\\left( T \\right) = \\sup \\left[ {0,{{\\sup }{i \\in \\left( {0,t} \\right)}}{Si} - {St}} \\right]  \\end{aligned}  $    where St$ is the portfolio cumulative function at time t. The maximum capital break can be used for measuring the risk that can be defined as:    $  \\begin{aligned}  MDD\\left( n \\right) = {\\sup _{t \\in \\left( {0,n} \\right)}}\\left[ {DD\\left( t \\right)} \\right]  \\end{aligned}  $    This metric can be calculated by using the mdd function.\nCalmar Ratio (CR)\nThe Calmar ratio is a measurement of risk-adjusted return based on maximum drawdown. It is defined as:    $  \\begin{aligned}  CR = {{APY} \\over {MDD}}  \\end{aligned}  $    This metric can be calculated by using the calmar function.  \nIt is worth mentioning that these metrics can be calculated as a whole rather than calculating them one by one. This can be done by using the OPSMetrics function. This function returns an object of type OPSMetrics which contains all the metrics mentioned above.","category":"page"},{"location":"fetchdata/#Fetch-Data","page":"Fetch Financial Data","title":"Fetch Data","text":"","category":"section"},{"location":"fetchdata/","page":"Fetch Financial Data","title":"Fetch Financial Data","text":"For fetching the data, one can use the YFinance.jl package:","category":"page"},{"location":"fetchdata/","page":"Fetch Financial Data","title":"Fetch Financial Data","text":"julia> using YFinance, DataFrames\n\njulia> tickers = [\"MMM\", \"CSCO\", \"IBM\", \"INTC\", \"XOM\"];\n\njulia> startdt, enddt = \"2023-04-01\", \"2023-04-27\";\n\njulia> querry = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"adjclose\"] for ticker in tickers];\n\n# In the Julia 1.9.0 and above, the following line can be replaced with `prices = stack(querry)`\njulia> prices = reduce(hcat, querry);\n\n# Let's make a DataFrame out of it for better visualization of the data\njulia> df = DataFrame(prices, tickers);\n\njulia> first(df, 3)\n3×5 DataFrame\n Row │ MMM      CSCO     IBM      INTC     XOM     \n     │ Float64  Float64  Float64  Float64  Float64 \n─────┼─────────────────────────────────────────────\n   1 │  104.57    51.92   132.06    32.89   116.13 \n   2 │  102.25    51.82   131.6     33.1    115.02 \n   3 │  102.29    51.82   132.14    32.83   116.99 ","category":"page"},{"location":"fetchdata/","page":"Fetch Financial Data","title":"Fetch Financial Data","text":"The given data in each example throughout this documentation has been collected using the above code. ","category":"page"},{"location":"funcs/#API","page":"Functions","title":"API","text":"","category":"section"},{"location":"funcs/","page":"Functions","title":"Functions","text":"Modules = [OnlinePortfolioSelection]\nPrivate = false\nOrder   = [:function, :type]","category":"page"},{"location":"funcs/#OnlinePortfolioSelection.ann_sharpe-Union{Tuple{T}, Tuple{T, T, T}} where T<:Float64","page":"Functions","title":"OnlinePortfolioSelection.ann_sharpe","text":"ann_sharpe(APY::T, Rf::T, sigma_prtf::T) where T<:Float64\n\nCalculate the Annualized Sharpe Ratio of investment.\n\nArguments\n\nAPY::T: the APY of investment.\nRf::T: the risk-free rate of return.\nsigmaprtf::T: the standard deviation of the portfolio ``\\sigmap``.\n\nReturns\n\n::Float64: the Annualized Sharpe Ratio of investment.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.ann_std-Tuple{Vector{Float64}}","page":"Functions","title":"OnlinePortfolioSelection.ann_std","text":"ann_std(cum_ret::Vector{Float64}; dpy)\n\nCalculate the Annualized Standard Deviation (σₚ) of portfolio.\n\nArguments\n\ncum_ret::Vector{Float64}: the cumulative return of investment during the investment period.\ndpy: the number of days in a year.\n\nReturns\n\n::Float64: the Annualized Standard Deviation (σₚ) of portfolio.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.apy-Union{Tuple{S}, Tuple{Float64, S}} where S<:Int64","page":"Functions","title":"OnlinePortfolioSelection.apy","text":"apy(Sn::Float64, n_periods::S; dpy::S=252) where S<:Int\n\nCalculate the Annual Percentage Yield (APY) of investment.\n\nArguments\n\nSn::Float64: the cumulative return of investment.\nn_periods::S: the number investment periods.\ndpy::S=252: the number of days in a year.\n\nReturns\n\n::Float64: the APY of investment.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.bs-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Float64","page":"Functions","title":"OnlinePortfolioSelection.bs","text":"bs(adj_close::Matrix{T}; last_n::Int=0) where {T<:Float64}\n\nRun the Best So Far algorithm on the given data.\n\nArguments\n\nadj_close::Matrix{T}: A matrix of adjusted closing prices of assets.\nlast_n::Int: The number of periods to look back for the performance of each asset. If last_n is 0, then the performance is calculated from the first period to the previous period.\n\nwarning: Beware!\nThe adj_close matrix should be in the order of assets x periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): An instance of OPSAlgorithm.\n\nReferences\n\nKERNEL-BASED SEMI-LOG-OPTIMAL EMPIRICAL PORTFOLIO SELECTION STRATEGIES\n\nExample\n\njulia> using OnlinePortfolioSelection\n\njulia> adj_close = rand(5, 10);\n\njulia> model = bs(adj_close, last_n=2);\n\njulia> model.b\n5×10 Matrix{Float64}:\n 0.2  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0\n 0.2  0.0  0.0  1.0  0.0  1.0  0.0  0.0  0.0  0.0\n 0.2  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.2  1.0  1.0  0.0  0.0  0.0  1.0  0.0  1.0  1.0\n 0.2  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0\n\njulia> sum(model.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.calmar-Union{Tuple{T}, Tuple{T, T}} where T<:Float64","page":"Functions","title":"OnlinePortfolioSelection.calmar","text":"calmar(APY::T, MDD::T) where T<:Float64\n\nCalculate the Calmar Ratio of investment.\n\nArguments\n\nAPY::T: the APY of investment.\nMDD::T: the MDD of investment.\n\nReturns\n\n::Float64: the Calmar Ratio of investment.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.cornk-Union{Tuple{T}, Tuple{Matrix{Float64}, Vararg{T, 4}}} where T<:Int64","page":"Functions","title":"OnlinePortfolioSelection.cornk","text":"cornk(\n  adj_close::Matrix{Float64},\n  horizon::T,\n  k::T,\n  w::T,\n  p::T;\n  init_budg=1\n) where T<:Int\n\nRun CORN-K algorithm.\n\nArguments\n\nadj_close::Matrix{Float64}: Adjusted close prices of assets.\nhorizon::T: The number of periods to invest.\nk::T: The number of top experts to be selected.\nw::T: maximum length of time window to be examined.\np::T: maximum number of correlation coefficient thresholds.\ninit_budg=1: The initial budget for investment.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): An object of type OPSAlgorithm.\n\nReference\n\n[1] CORN: Correlation-driven nonparametric learning approach for portfolio selection\n\nExamples\n\njulia> using OnlinePortfolioSelection\n\njulia> adj_close = rand(5, 100);\n\njulia> model = cornk(adj_close, 10, 3, 5, 3);\n\njulia> model.type\n\"CORN-K\"\n\njulia> sum(model.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.cornu-Union{Tuple{M}, Tuple{T}, Tuple{Matrix{T}, M, M}} where {T<:Float64, M<:Int64}","page":"Functions","title":"OnlinePortfolioSelection.cornu","text":"cornu(\n  adj_close::Matrix{T},\n  horizon::M,\n  w::M;\n  rho::T=0.2,\n  init_budg=1\n) where {T<:Float64, M<:Int}\n\nRun CORN-U algorithm.\n\nArguments\n\nadj_close::Matrix{T}: Adjusted close prices of assets.\nhorizon::M: The number of periods to invest.\nw::M: maximum length of time window to be examined.\nrho::T=0.2: The correlation coefficient threshold.\ninit_budg=1: The initial budget for investment.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): An object of type OPSAlgorithm.\n\nReference\n\n[1] CORN: Correlation-driven nonparametric learning approach for portfolio selection\n\nExamples\n\njulia> using OnlinePortfolioSelection\n\njulia> adj_close = rand(5, 100);\n\njulia> model = cornu(adj_close, 10, 5, 0.5);\n\njulia> model.type\n\"CORN-U\"\n\njulia> sum(model.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.crp-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Float64","page":"Functions","title":"OnlinePortfolioSelection.crp","text":"crp(adj_close::Matrix{T}, init_budg=1) where T<:Float64\n\nRun Constant Rebalanced Portfolio (CRP) algorithm.\n\nArguments\n\nadj_close::Matrix{Float64}: adjusted close prices\ninit_budg::Float64: initial budget\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): OPSAlgorithm object\n\nReferences\n\n[1] Universal Portfolios\n\nExample\n\njulia> using OnlinePortfolioSelection\n\njulia> typeof(adj_close), size(adj_close)\n(Matrix{Float64}, (3, 10))\n\njulia> m_crp = crp(adj_close);\n\njulia> m_crp.b\n3×10 Matrix{Float64}:\n 0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333\n 0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333\n 0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333\n\njulia> sum(m_crp.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.dricornk-Union{Tuple{M}, Tuple{T}, Tuple{Matrix{T}, Vector{T}, Vararg{M, 4}}} where {T<:Float64, M<:Int64}","page":"Functions","title":"OnlinePortfolioSelection.dricornk","text":"dricornk(\n  adj_close::Matrix{T},\n  adj_close_market::Vector{T},\n  horizon::M,\n  k::M,\n  w::M,\n  p::M;\n  lambda::T=1e-3,\n  init_budg=1\n) where {T<:Float64, M<:Int}\n\nRun the DRICORNK algorithm.\n\nArguments\n\nadj_close::Matrix{T}: A matrix of adjusted close prices of the assets.\nadj_close_market::Vector{T}: A vector of adjusted close prices of the market in the same period.\nhorizon::M: The investment horizon.\nk::M: The number of experts.\nw::M: maximum length of time window to be examined.\np::M: maximum number of correlation coefficient thresholds.\nlambda::T=1e-3: The regularization parameter.\ninit_budg=1: The initial budget for investment.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): An object of type OPSAlgorithm.\n\nReference\n\n[1] DRICORN-K: A Dynamic RIsk CORrelation-driven Non-parametric Algorithm for Online Portfolio Selection\n\nExample\n\njulia> using OnlinePortfolioSelection\n\njulia> stocks_adj, market_adj = rand(10, 100), rand(100);\n\njulia> m_dricornk = dricornk(stocks_adj, market_adj, 5, 2, 4, 3);\n\njulia> sum(m_dricornk.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.eg-Tuple{Matrix{Float64}}","page":"Functions","title":"OnlinePortfolioSelection.eg","text":"eg(adj_close::Matrix{Float64}, init_budg=1., eta=0.05)\n\nExponential Gradient (EG) algorithm.\n\nCalculate the Exponential Gradient (EG) weights and budgets using the given historical prices and parameters and return an EG object.\n\nArguments\n\nadj_close::Matrix{Float64}: Historical adjusted close prices.\ninit_budg=1.: Initial budget.\neta=0.05: Learning rate.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): OPSAlgorithm object.\n\nReferences\n\n[1] On-Line Portfolio Selection Using Multiplicative Updates](https://onlinelibrary.wiley.com/doi/10.1111/1467-9965.00058)\n\nExamples\n\njulia> using OnlinePortfolioSelection\n\njulia> typeof(adj_close), size(adj_close)\n(Matrix{Float64}, (3, 10))\n\njulia> m_eg = eg(adj_close);\n\njulia> m_eg.b\n3×10 Matrix{Float64}:\n 0.333333  0.333119  0.333296  0.333232  0.33327   0.333276  0.333201  0.333171  0.332832  0.332789\n 0.333333  0.333436  0.333274  0.333485  0.333481  0.333359  0.333564  0.333477  0.333669  0.333835\n 0.333333  0.333445  0.33343   0.333283  0.333249  0.333365  0.333234  0.333353  0.333499  0.333377\n\njulia> sum(m_eg.b, dims=1) .|> isapprox(1.0) |> all\ntrue\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.mdd-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Float64","page":"Functions","title":"OnlinePortfolioSelection.mdd","text":"mdd(Sn::Vector{T}) where T<:Float64\n\nCalculate the Maximum Drawdown (MDD) of investment.\n\nArguments\n\nSn::Vector{T}: the cumulative return of investment during the investment period.\n\nReturns\n\n::Float64: the MDD of investment.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.rprt-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Float64","page":"Functions","title":"OnlinePortfolioSelection.rprt","text":"rprt(\n  adj_close::Matrix{T};\n  w::Int64=5,\n  theta::T=0.8,\n  epsilon=50\n) where T<:Float64\n\nRun RPRT algorithm.\n\nArguments\n\nadj_close::Matrix{T}: Adjusted close prices of assets.\nw::Int64=5: maximum length of time window to be examined.\ntheta::T=0.8: The threshold for the relative price.\nepsilon=50: The threshold for the condition of the portfolio.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): An object of type OPSAlgorithm.\n\nReference\n\n[1] Reweighted Price Relative Tracking System for Automatic Portfolio Optimization\n\nExamples\n\njulia> using OnlinePortfolioSelection\n\njulia> typeof(adj_close), size(adj_close)\n(Matrix{Float64}, (3, 7))\n\njulia> m_rprt = rprt(adj_close);\n\njulia> m_rprt.b\n3×7 Matrix{Float64}:\n 0.333333  0.333333  0.0  0.0  0.0  1.0  0.0\n 0.333333  0.333333  1.0  1.0  1.0  0.0  1.0\n 0.333333  0.333333  0.0  0.0  0.0  0.0  0.0\n\njulia> sum(m_rprt.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.sn-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T<:Float64","page":"Functions","title":"OnlinePortfolioSelection.sn","text":"sn(weights::Matrix{T}, rel_pr::Matrix{T}; init_inv::T=1.) where T<:Float64\n\nCalculate the cumulative return of investment during a period of time.\n\nArguments\n\nweights::Matrix{T}: the weights of the portfolio.\nrel_pr::Matrix{T}: the relative price of the stocks.\ninit_inv::T=1: the initial investment.\n\nwarning: Beware!\nThe size of weights and rel_pr must be (n_stocks, n_periods).\n\nnote: Note\nIf size(rel_pr, 2) is greater than size(weights, 2), then the last size(weights, 2) columns of rel_pr will be used.\n\nReturns\n\nall_sn::Vector{T}: the cumulative return of investment during the investment period.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.up-Tuple{Matrix{Float64}}","page":"Functions","title":"OnlinePortfolioSelection.up","text":"up(\n  adj_close::Matrix{Float64};\n  init_budg=1.,\n  eval_points::Int=10^4,\n  leverage=1.,\n  frequency::Int=1,\n  min_history::Int=0\n)\n\nUniversal Portfolio (UP) algorithm.\n\nCalculate the Universal Portfolio (UP) weights and budgets using the given historical prices and parameters.\n\nArguments\n\nadj_close::Matrix{Float64}: Historical adjusted close prices.\ninit_budg=1.: Initial budget.\neval_points::Int=10^4: Number of evaluation points.\nleverage=1.: Leverage value.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): OPSAlgorithm object.\n\nReferences\n\n[1] Universal Portfolios\n\nExamples\n\njulia> using OnlinePortfolioSelection\n\njulia> typeof(adj_close), size(adj_close)\n(Matrix{Float64}, (3, 30))\n\njulia> m_up = up(adj_close);\n\njulia> m_up.b\n3×30 Matrix{Float64}:\n 0.333333  0.331149  0.33204   0.331716  …  0.326788  0.325788  0.325829  0.326222\n 0.333333  0.336058  0.335239  0.336304     0.343405  0.342161  0.342283  0.340693\n 0.333333  0.332793  0.33272   0.331981     0.329807  0.332051  0.331888  0.333086\n\njulia> sum(m_up.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.OPSAlgorithm","page":"Functions","title":"OnlinePortfolioSelection.OPSAlgorithm","text":"OPSAlgorithm{T<:Float64}\n\nA OPSAlgorithm object that contains the result of running the algorithm.\n\nFields\n\nn_asset::Int: Number of assets in the portfolio.\nb::Matrix{T}: Weights of the created portfolios.\nalg::String: Name of the algorithm.\n\nThe formula for calculating the cumulative return of the portfolio is as follows:\n\nS_n = S_0prodlimits_t = 1^T leftlangle b_tx_t rightrangle \n\nwhere S₀ is the initial budget, n is the investment horizon, b_t is the vector of weights of the period t, and x_t is the relative price of the t-th period.\n\n\n\n\n\n","category":"type"},{"location":"funcs/#OnlinePortfolioSelection.OPSMetrics","page":"Functions","title":"OnlinePortfolioSelection.OPSMetrics","text":"OPSMetrics(Sn::Vector{T}, APY::T, Ann_Sharpe::T, MDD::T, Calmar::T) where {T<:Float64}\n\nA struct to store the metrics of the OPS algorithm.\n\nFields\n\nSn::Vector{T}: the cumulative return of investment during the investment period.\nAPY::T: the Annual Percentage Yield (APY) of investment.\nAnn_Std::T: the Annualized Standard Deviation (σₚ) of investment.\nAnn_Sharpe::T: the Annualized Sharpe Ratio (SR) of investment.\nMDD::T: the Maximum Drawdown (MDD) of investment.\nCalmar::T: the Calmar Ratio of investment.\n\n\n\n\n\n","category":"type"},{"location":"funcs/#OnlinePortfolioSelection.OPSMetrics-Union{Tuple{S}, Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where {T<:Float64, S<:Int64}","page":"Functions","title":"OnlinePortfolioSelection.OPSMetrics","text":"OPSMetrics(\n  weights::Matrix{T},\n  rel_pr::Matrix{T};\n  init_inv::T=1.,\n  Rf::T=0.02\n  dpy::S=252\n) where {T<:Float64, S<:Int}\n\nCalculate the metrics of an OPS algorithm.\n\nArguments\n\nweights::Matrix{T}: the weights of the portfolio.\nrel_pr::Matrix{T}: the relative price of the stocks.\ninit_inv::T=1: the initial investment.\nRf::T=0.02: the risk-free rate of return.\ndpy::S=252: the number of days in a year.\n\nwarning: Warning\nThe size of weights and rel_pr must be (n_stocks, n_periods).\n\nnote: Note\nIf size(rel_pr, 2) is greater than size(weights, 2), then the last size(weights, 2) columns of rel_pr will be used.\n\nReturns\n\n::OPSMetrics: the metrics of the OPS algorithm.\n\n\n\n\n\n","category":"method"},{"location":"FL/#Follow-the-Loser-(FL)","page":"Follow the Loser","title":"Follow the Loser (FL)","text":"","category":"section"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"follow the loser has been introduced by Borodin and Vincent (2004) in which, the investment weight is transferred from a stock provided a better performance in the past to a stock with unfavorable performance, since the approach considers that a stock with an undesirable performance in the past is able to provide a desirable return in the future. In this package, the following FL strategie is implemented so far:","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Reweighted Price Relative Tracking System for Automatic Portfolio Optimization","category":"page"},{"location":"FL/#Reweighted-Price-Relative-Tracking-System-for-Automatic-Portfolio-Optimization-(RPRT)","page":"Follow the Loser","title":"Reweighted Price Relative Tracking System for Automatic Portfolio Optimization (RPRT)","text":"","category":"section"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"RPRT is a FL strategy proposed by Lai et al. (2018). In the price prediction stage, it automatically assigns separate weights to the price relative predictions according to each asset’s performance, and these weights will also be automatically updated. In the portfolio optimizing stage, they proposed a novel tracking system with a generalized increasing factor to maximize the future wealth of next period. Through their study, an efficient algorithm is designed to solve the portfolio optimization objective, which is applicable to large-scale and time-limited situations. According to their extensive experiments on six benchmark datasets from real financial markets with diverse assets and different time spans, RPRT outperforms other state-of-the-art systems in cumulative wealth, mean excess return, annual percentage yield, and some typical risk metrics. Moreover, it can withstand considerable transaction costs and runs fast. It indicates that RPRT is an effective and efficient online portfolio selection system.","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"See rprt.","category":"page"},{"location":"FL/#Run-RPRT","page":"Follow the Loser","title":"Run RPRT","text":"","category":"section"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Note: This package is meant to be used by researchers NOT FOR MARKET PRACTITIONERS. Let's run the algorithm on the real market data. In this case, the data is collected as noted in the Fetch Data section.","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Let's run the algorithm on the given data (named as prices):","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"juila> using OnlinePortfolioSelection\n\njulia> size(prices)\n(17, 5)\n\n# OnlinePortfolioSelection suppose that the data is in the form of a matrix\n# where each row is the price vector of the assets at a specific time period.\njulia> prices = prices |> permutedims;\n\njulia> window_length, threshold, epsilon = 2, 0.6, 40;\n\n# Let's run the algorithm for the last 5 days of the data.\njulia> prices = prices[:, end-4:end];\n\njulia> m_rprt = rprt(prices, w=window_length, theta=threshold, epsilon=epsilon);\n\n# Get the weights of the assets for each day\njuila> m_rprt.b\n5×5 Matrix{Float64}:\n 0.2  0.2  0.0  0.0  0.0\n 0.2  0.2  0.0  0.0  0.0\n 0.2  0.2  0.0  0.0  0.0\n 0.2  0.2  1.0  1.0  1.0\n 0.2  0.2  0.0  0.0  0.0\n ```\n\nOne can calculate the cumulative wealth during the investment period by using the [`sn`](@ref) function:\n","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"julia julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"julia> sn(mrprt.b, relprice) 6-element Vector{Float64}:  1.0  0.9879822800308067  0.985480892911241  0.9646654456994471  0.9392966194100733  0.9448257537201438","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"\nThe result indicates that if we had invested in the given period, we would have lost ~6.3% of our wealth. Note that [`sn`](@ref) automatically takes the last 5 relative prices in this case.\nNow, let's investiagte the performance of the algorithm according to some of the prominent metrics:\n","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"julia julia> results = OPSMetrics(mrprt.b, relprice)","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"        Cumulative Return: 0.945\n                      APY: -0.943","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Annualized Standard Deviation: 0.202       Annualized Sharpe Ratio: -4.760              Maximum Drawdown: 0.061                  Calmar Ratio: -15.531","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"julia> results. APY         AnnSharpe  AnnStd     Calmar      MDD         Sn","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"julia> results.MDD 0.06070338058992675 ```","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"It is worht mentioning that each metric can be accessed individually by writing results. and pressing the Tab key. Note that one can individually investigate the performance of the algorithm regarding each metric. See sn, ann_std, apy, ann_sharpe, mdd, and calmar. See Performance evaluation section for more information.","category":"page"},{"location":"FW/#Follow-the-Winner-(FW)","page":"Follow the Winner","title":"Follow the Winner (FW)","text":"","category":"section"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Follow the Winner (FW) strategies believe that the best performing asset in the past will continue to perform well in the future. The following FW strategies are implemented in this package so far:","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Universal Portfolio (UP)\nExponential Gradient (EG)","category":"page"},{"location":"FW/#Universal-Portfolio","page":"Follow the Winner","title":"Universal Portfolio","text":"","category":"section"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Universal Portfolio (UP) is a FW strategy proposed by Cover (1991). The Universal Portfolio algorithm is a portfolio selection algorithm from the field of machine learning and information theory. UP aims to maximize the cumulative reurn of the portfolio during the investment horizon. The algorithm is based on the performance of the stock market on each day and the proportion of wealth invested in each stock. ","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"See up.","category":"page"},{"location":"FW/#Run-UP","page":"Follow the Winner","title":"Run UP","text":"","category":"section"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Note: This package is meant to be used by researchers NOT FOR MARKET PRACTITIONERS. Let's run the algorithm on the real market data. The data is collected as noted in the Fetch Data section.","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Let's run the algorithm on the given data (named as prices):","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"juila> using OnlinePortfolioSelection\n\njulia> size(prices)\n(17, 5)\n\n# OnlinePortfolioSelection suppose that the data is in the form of a matrix\n# where each row is the price vector of the assets at a specific time period.\njulia> prices = prices |> permutedims;\n\n# Let's run the algorithm on the last 5 days of the data.\njulia> m_up = up(prices[:, end-4:end], eval_points=100);\n\njuila> m_up.b\n5×5 Matrix{Float64}:\n 0.2  0.216518  0.216638  0.21681   0.216542\n 0.2  0.203395  0.203615  0.203754  0.203528\n 0.2  0.191899  0.191793  0.192316  0.192473\n 0.2  0.193023  0.192302  0.191687  0.19208\n 0.2  0.195164  0.195652  0.195433  0.195377","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"One can calculate the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(m_up.b, rel_price)\n6-element Vector{Float64}:\n 1.0\n 0.9879822623031318\n 0.9856240412854884\n 0.9874863498385578\n 0.9778277061434468\n 0.9718529924971879","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"The result indicates that if we had invested in the given period, we would have lost ~2.8% of our wealth. Note that sn automatically takes the last 5 relative prices in this case. Now, let's investiagte the performance of the algorithm according to some of the prominent metrics:","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"julia> results = OPSMetrics(m_up.b, rel_price)\n\n            Cumulative Return: 0.972\n                          APY: -0.763\nAnnualized Standard Deviation: 0.088\n      Annualized Sharpe Ratio: -8.857\n             Maximum Drawdown: 0.028\n                 Calmar Ratio: -27.101\n\njulia> results.\nAPY         Ann_Sharpe  Ann_Std     Calmar      MDD         Sn\n\njulia> results.MDD\n0.02814700750281207","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"It is worht mentioning that each metric can be accessed individually by writing results. and pressing Tab key. Note that one can individually investigate the performance of the algorithm regarding each metric. See sn, ann_std, apy, ann_sharpe, mdd, and calmar. See Performance evaluation section for more information.","category":"page"},{"location":"FW/#Exponential-Gradient","page":"Follow the Winner","title":"Exponential Gradient","text":"","category":"section"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Exponential Gradient (EG) is a FW strategy proposed by Helmbold et al. (1998). Authors claim that EG can achieve almost the same wealth as the best constantrebalanced portfolio (BCRP) determined in hindsight from the actual market outcomes. the algorithm is very simple to implement and requires only constant storage and computing time per stock in each trading period.","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"See eg.","category":"page"},{"location":"FW/#Run-EG","page":"Follow the Winner","title":"Run EG","text":"","category":"section"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Let's run the algorithm on the real market data. The data is collected as noted in the \"Fetch-Data\" section.","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"juila> using OnlinePortfolioSelection\n\njulia> size(prices)\n(17, 5)\n\n# OnlinePortfolioSelection suppose that the data is in the form of a matrix\n# where each row is the price vector of the assets at a specific time period.\njulia> prices = prices |> permutedims;\n\n# Let's run the algorithm on the last 5 days of the data.\njulia> m_eg = eg(prices[:, end-4:end], eta=0.02);\n\njuila> m_eg.b\n5×5 Matrix{Float64}:\n 0.2  0.200001  0.200016  0.20003   0.199997\n 0.2  0.200049  0.200073  0.200087  0.200064\n 0.2  0.19999   0.199973  0.200029  0.200051\n 0.2  0.199937  0.199846  0.19978   0.199827\n 0.2  0.200023  0.200092  0.200074  0.200061 ","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"One can calculate the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(m_eg.b, rel_price)\n6-element Vector{Float64}:\n 1.0\n 0.9879822623031318\n 0.9854825989102248\n 0.98713136445759\n 0.9773624367829401\n 0.9716549466747438","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"The result indicates that if we had invested in the given period, we would have lost ~2.8% of our wealth. Note that sn automatically takes the last 5 relative prices in this case. Now, let's investiagte the performance of the algorithm according to some of the prominent metrics:","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"julia> results = OPSMetrics(m_eg.b, rel_price)\n\n            Cumulative Return: 0.972\n                          APY: -0.765\nAnnualized Standard Deviation: 0.087\n      Annualized Sharpe Ratio: -9.005\n             Maximum Drawdown: 0.028\n                 Calmar Ratio: -26.9\n\njulia> results.\nAPY         Ann_Sharpe  Ann_Std     Calmar      MDD         Sn\n\njulia> results.MDD\n0.028345053325256164","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"It is worht mentioning that each metric can be accessed individually by writing results. and pressing the Tab key. Note that one can individually investigate the performance of the algorithm regarding each metric. See sn, ann_std, apy, ann_sharpe, mdd, and calmar. See Performance evaluation section for more information.","category":"page"},{"location":"benchmark/#Benchmark-Strategies","page":"Benchmark","title":"Benchmark Strategies","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Some strategies in the context of online portfolio selection are considered as benchmark strategies. The simplest benchmark strategy is the Buy and Hold (BH) strategy which is called as the market strategy. The BAH model invests equally in m assets at the beginning and remains unchanged during the next periods, thus the weights of assets change passively with their price variations. A special BAH model, the Best-Stock (BS), invests all the capital into the best asset over the periods which is an optimal BAH in hindsight. Overall, the Benchmark portfolio selection models are quite simple because they do not adopt complex or sophisticated techniques via statistics and machine learning to explore the patterns within the data. Thus they are often taken as the baselines for performance comparison with new designed models. Another benchmark strategy is the Constant Rebalanced Portfolio (CRP) which assigns a fixed weight to each asset throughout a given period. The following strategies are implemented in this package so far:","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Constant Rebalanced Portfolio (CRP)\nBest Stock (BS)","category":"page"},{"location":"benchmark/#CRP","page":"Benchmark","title":"CRP","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Let's run the algorithm on the real market data. Assume the data (named as prices) is collected as noted in the Fetch Data section.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"juila> using OnlinePortfolioSelection\n\njulia> size(prices)\n(17, 5)\n\n# OnlinePortfolioSelection suppose that the data is in the form of a matrix\n# where each row is the price vector of the assets at a specific time period.\njulia> prices = prices |> permutedims;\n\n# Let's run the algorithm on the last 5 days of the data.\njulia> m_crp = crp(prices[:, end-4:end]);\n\njuila> m_crp.b\n5×5 Matrix{Float64}:\n 0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"One can calculate the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(m_crp.b, rel_price)\n6-element Vector{Float64}:\n 1.0\n 0.9879822623031318\n 0.9854808899164217\n 0.9871240426268018\n 0.977351149446221\n 0.9716459683279461","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"The result indicates that if we had invested in the given period, we would have lost ~2.8% of our capital. Note that sn automatically takes the last 5 relative prices in this case. Now, let's investiagte the performance of the algorithm according to some of the prominent metrics:","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"julia> results = OPSMetrics(m_crp.b, rel_price)\n\n            Cumulative Return: 0.972\n                          APY: -0.765\nAnnualized Standard Deviation: 0.087\n      Annualized Sharpe Ratio: -9.008\n             Maximum Drawdown: 0.028\n                 Calmar Ratio: -26.993\n\njulia> results.\nAPY         Ann_Sharpe  Ann_Std     Calmar      MDD         Sn\n\njulia> results.MDD\n0.02835403167205386","category":"page"},{"location":"benchmark/#BS","page":"Benchmark","title":"BS","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"This model is a subset of the BAH strategy in which the best stock is acquired retroactively. In this package, users can choose the number of days to look back (through last_n keyword argument) and find the best stock. If the last_n is not provided or is set to 0, the algorithm will consider the whole data until the day at each period to find the best stock. Otherwise, the algorithm will consider the last last_n days performance of each stock and chooses the best one. Let's run the algorithm on the real market data. Assume the data (named as prices) is collected as noted in the Fetch Data section.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"juila> using OnlinePortfolioSelection\n\njulia> size(prices)\n(17, 5)\n\n# OnlinePortfolioSelection suppose that the data is in the form of a matrix\n# where each row is the price vector of the assets at a specific time period.\njulia> prices = prices |> permutedims;\n\n# Let's run the algorithm on the last 10 days of the data.\njulia> m_bs = bs(prices[:, end-9:end]);\n\njuila> m_bs.b\n5×10 Matrix{Float64}:\n 0.2  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.2  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.2  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.2  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.2  1.0  0.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"After running the algorithm, one can calculate the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(m_bs.b, rel_price)\n11-element Vector{Float64}:\n 1.0\n 1.0067934076484562\n 1.009228482491198\n 1.0188656476194202\n 1.0387633347003844\n 1.0354766468359777\n 1.027215571086806\n 1.0305022589512125\n 1.0499557074411052\n 1.0350324760158582\n 1.0255278032954953","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"The result indicates that if we had invested in the given period, we would have gained ~2.6% of our capital. Note that sn automatically takes the last 10 relative prices in this case.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Note that this package provides functions to analyze the performance of the algorithm. See the Performance evaluation section for more details.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = quote\n    using OnlinePortfolioSelection\nend","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Online Portfolio Selection (OPS) strategies are trading algorithms that sequentially allocate capital among a group of assets to maximize the final returns of the investment. It is a fundamental problem in computational finance that has been extensively studied across several research communities, including finance, statistics, artificial intelligence, machine learning, and data mining. From an online machine learning perspective, it is formulated as a sequential decision problem and there are a variety of state-of-the-art approaches that have been developed to solve it. These approaches are grouped into several major categories, including benchmarks, “Follow-the-Winner” approaches, “Follow-the-Loser” approaches, “Pattern-Matching” based approaches, and \"Meta-Learning\" Algorithms1. This package provides an efficient implementation of OPS algorithms. The algorithms are implemented in Julia in a fully type-stable manner. All the algorithms return an object of type OPSAlgorithm which can be used to query the portfolio weights, number of assets, and the name of the algorithm. Eight algorithms are implemented so far and more will be added in the future. The available algorithms are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Constant Rebalanced Portfolio (CRP)\nExponential Gradient (EG)\nUniversal Portfolio (UP)\nCorrelation-driven Nonparametric Learning","category":"page"},{"location":"","page":"Home","title":"Home","text":"4.1 CORN-U\n4.2 CORN-K","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dynamic RIsk CORrelation-driven Non-parametric (DRICORN-K)\nBest Stock (BS)\nReweighted Price Relative Tracking (RPRT)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The latest stable version of the package can be installed by running the following command in the Julia REPL after pressing ]:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add OnlinePortfolioSelection","category":"page"},{"location":"","page":"Home","title":"Home","text":"or","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"OnlinePortfolioSelection\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or even","category":"page"},{"location":"","page":"Home","title":"Home","text":"juila> using Pkg; pkg\"add OnlinePortfolioSelection\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"The dev version can be installed usint the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/shayandavoodii/OnlinePortfolioSelection.jl.git","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be imported by running the following command in the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using OnlinePortfolioSelection","category":"page"},{"location":"","page":"Home","title":"Home","text":"One can perform several strategies on a given dataset and analyse and compare the results. The following code snippet shows how to perform the strategies on a given dataset and compare the results:","category":"page"},{"location":"","page":"Home","title":"Home","text":"juila> using CSV, DataFrames\n\n# read adjusted close prices\njulia> pr = CSV.read(\"data\\\\sp500.csv\", DataFrame) |> Matrix |> permutedims;\n\njulia> pr = pr[2:end, :];\n\njulia> market_pr = pr[1, :];\n\njulia> size(pr)\n(24, 1276)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The dataset contains the adjusted close prices of 24 stocks in the S&P 500 within 1276 trading days. Now, suppose we want to perform the strategies on the last 50 days of the dataset with default arguments:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> m_corn_u = cornu(pr, 50, 3);\n\njulia> m_corn_k = cornk(pr, 50, 3, 2, 2);\n\njuila> m_drcorn_k = dricornk(pr, market_pr, 50, 5, 5, 5);","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now, let's plot the trend of daily cumulative budgets of each algorithm. For this, we have to calculate it using the achieved portfolio weights and relative prices in the same time period:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# calculate the relative prices\njulia> rel_pr = pr[:, 2:end] ./ pr[:, 1:end-1];\n\njulia> models = [m_corn_u, m_corn_k, m_drcorn_k];\n\n# calculate the cumulative budgets\njulia> budgets = [sn(model.b, rel_pr[:, end-49:end]) for model in models];\n\njulia> using Plots\n\njulia> plot(\n            budgets, \n            label = [\"CORN-U\" \"CORN-K\" \"DRICORN-K\"], \n            xlabel = \"Day\", ylabel = \"Cumulative return\", legend = :bottomleft,\n       )","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"assets/cumulative_budgets.png\" width=\"100%\">","category":"page"},{"location":"","page":"Home","title":"Home","text":"The plot shows that the cumulative return of CORN-K outperforms the other algorithms almost all the time. Note that the initial investment for all of the algorithms is set to 1 (this can be modified by setting the keyword argument init_budg for each algorithm). Now, let's investigate the performance of the algorithms in terms of some of prominent performance metrics:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> all_metrics = OPSMetrics.([m_corn_u.b, m_corn_k.b, m_drcorn_k.b], Ref(rel_pr));","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now, one can embed the metrics in a DataFrame and compare the performance of the algorithms with respect to each other:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using DataFrames\n\njulia> nmodels = length(all_metrics);\n\njulia> comp_algs = DataFrame(\n           Algorithm = [\"CORN-U\", \"CORN-K\", \"DRICORN-K\"],\n           APY = [all_metrics[i].APY for i = 1:nmodels],\n           Ann_Sharpe = [all_metrics[i].Ann_Sharpe for i = 1:nmodels],\n           Ann_Std = [all_metrics[i].Ann_Std for i = 1:nmodels],\n           Calmar = [all_metrics[i].Calmar for i = 1:nmodels],\n           MDD = [all_metrics[i].MDD for i = 1:nmodels],\n       )\n3×6 DataFrame\n Row │ Algorithm  APY        Ann_Sharpe  Ann_Std   Calmar    MDD       \n     │ String     Float64    Float64     Float64   Float64   Float64   \n─────┼─────────────────────────────────────────────────────────────────\n   1 │ CORN-U     -0.126009   -0.505762  0.288691  -1.25383  0.100499\n   2 │ CORN-K      0.826495    2.48378   0.324705  17.688    0.0467263\n   3 │ DRICORN-K  -0.248393   -1.20933   0.221934  -2.54505  0.0975985","category":"page"},{"location":"","page":"Home","title":"Home","text":"The comp_algs shows that CORN-K outperforms the other algorithms in terms of annualizeed percentage yield (APY), annualized Sharpe ratio, Calmar ratio, and maximum drawdown (MDD). However, the annualized standard deviation of CORN-K is higher than the other algorithms in this dataset. Note that these metrics can be calculated individually by calling the corresponding sn, apy, ann_sharpe, ann_std, calmar, and mdd functions. See the Performance evaluation for more details.","category":"page"}]
}
