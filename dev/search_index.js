var documenterSearchIndex = {"docs":
[{"location":"performance_eval/#Performance-evaluation","page":"Performance Evaluation","title":"Performance evaluation","text":"","category":"section"},{"location":"performance_eval/#Introduction","page":"Performance Evaluation","title":"Introduction","text":"","category":"section"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"This package provides a variety of metrics for evaluating algorithm performance. These metrics are widely recognized in the literature and serve as benchmarks for comparing the performances of different algorithms. Currently, the supported metrics include:","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"Cumulative Return (CR, Also known as S_n)","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"This metric computes the portfolio's cumulative return of the algorithm throughout an investment period. The cumulative return is defined as:","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"beginaligned\nS_n = S_0prodlimits_t = 1^T leftlangle b_tx_t rightrangle \nendaligned","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"where S_0 represents the initial capital, b_t stands for the portfolio vector at time t, and x_t denotes the relative price vector at time t. This metric can be evaluated using the sn function.","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"Mean excess return (MER)","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"MER is utilized to gauge the average excess returns of an OPS method that surpasses the benchmark market strategy. MER is defined as:","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"MER = 1 over nsumnolimits_t = 1^n R_t -  1 over nsumnolimits_t = 1^n R_t^*","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"where R and R_t^* represent the daily returns of a portfolio and the market strategy at the tth trading day, respectively. For a given OPS method, accounting for transaction costs, R_t is calculated by R_t = left( mathbfx_tmathbfb_t right) times left( 1 - nu  over 2 times sumnolimits_i = 1^d left b_ti - tilde b_ti right  right) - 1. The market strategy initially allocates capital equally among all assets and remains unchanged. R_t^* is defined as: R_t^* = mathbfx_t cdot mathbfb^* - 1 and mathbfb^* = left( 1 over d1 over d ldots 1 over d right)^ top , where d is the number of assets, and n is the number of trading days. This metric can be calculated using the mer function. (see [20] for more details.)","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"Annualized Return (APY)","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"This metric computes the annualized return of the algorithm throughout the investment period. The annualized return is defined as:","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"beginaligned\nAPY = left( S_n right)^frac1y - 1\nendaligned","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"where y represents the number of years in the investment period. This metric can be evaluated using the apy function.","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"Annualized Standard Deviation (sigma_p)","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"Another measurement employed to assess risk is the annual standard deviation of portfolio returns. The daily standard deviation is computed to derive the annual standard deviation, after which it is multiplied by sqrt252 (assuming 252 days in a year). Users can adjust the number of days in a year by specifying the dpy keyword argument. This metric can be computed using the ann_std function.","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"Annualized Sharpe Ratio (SR)","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"The Sharpe ratio serves as a measure of risk-adjusted return. It is defined as:","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"beginaligned\nSR = APY - R_f over sigma _p\nendaligned","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"Here, R_f denotes the risk-free rate, typically equivalent to the treasury bill rate at the investment period. This metric can be computed using the ann_sharpe function.","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"Maximum Drawdown (MDD)","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"The maximum drawdown is the largest loss observed from a peak to a trough within a portfolio, before a subsequent peak is attained. The calculation of MDD relies on the capital break value. Capital break serves as a critical criterion for assessing the capital market and equals the maximum decline from the peak of the portfolio cumulative function. Capital break is defined as:","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"beginaligned\nDDleft( T right) = sup left 0sup _i in left( 0t right)S_i - S_t right\nendaligned","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"where S_t denotes the portfolio cumulative function at time t. The maximum capital break, used to gauge risk, is defined as:","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"beginaligned\nMDDleft( n right) = sup _t in left( 0n right)left DDleft( t right) right\nendaligned","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"This metric can be calculated using the mdd function.","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"Calmar Ratio (CR)","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"The Calmar ratio is a risk-adjusted return metric based on the maximum drawdown. It is defined as:","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"beginaligned\nCR = APY over MDD\nendaligned","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"This metric can be computed using the calmar function. Additionally, it's noteworthy that these metrics can be computed collectively rather than individually. This can be achieved using the OPSMetrics function. This function yields an object of type OPSMetrics containing all the aforementioned metrics.","category":"page"},{"location":"performance_eval/#Examples","page":"Performance Evaluation","title":"Examples","text":"","category":"section"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"Below is a simple example that illustrates how to utilize the metrics. Initially, I utilize the OPSMetrics function to compute all the metrics collectively. Subsequently, I present the procedure to compute each metric individually.","category":"page"},{"location":"performance_eval/#[OPSMetrics](@ref)-function","page":"Performance Evaluation","title":"OPSMetrics function","text":"","category":"section"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"The OPSMetrics function facilitates the computation of all metrics simultaneously. It requires the following positional arguments:","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"weights: A matrix sized m times t, representing the portfolio weights on each trading day utilizing the chosen OPS algorithm. rel_pr: A matrix sized m times t, which includes the relative prices of assets on each trading day. Typically, these prices are computed as fracp_tip_t-1i in most studies, where p_ti denotes the price of asset i at time t. Alternatively, in some studies, relative prices are calculated as fracc_tio_ti, where c_ti and o_ti are the closing and opening prices of asset i at time t. The user can decide which relative prices to employ and input the corresponding matrix into the function. Additionally, the function accepts the following keyword arguments:","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"init_inv=1.: The initial investment, which is set to 1.0 by default.\nRF=0.02: The risk-free rate, which is set to 0.02 by default.\ndpy=252: The number of days in a year, which is set to 252 days by default.\nv=0.: The transaction cost rate, which is set to 0.0 by default.","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"The function returns an object of type OPSMetrics containing all the metrics as fields. Now, let's choose few algorithms and assess their performance using the aforementioned function.","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"using OnlinePortfolioSelection, YFinance, Plots\n\n# Fetch data\ntickers = [\"AAPL\", \"MSFT\", \"AMZN\", \"META\", \"GOOG\"]\n\nstartdt, enddt = \"2023-04-01\", \"2023-08-27\";\n\nquerry = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"adjclose\"] for ticker in tickers];\n\nprices = stack(querry) |> permutedims;\n\nrel_pr = prices[:, 2:end]./prices[:, 1:end-1];\n\nnassets, ndays = size(rel_pr);\n\n# Run algorithms for 30 days\nhorizon = 30;\n\n# Run models on the given data\nloadm = load(prices, 0.5, 8, horizon, 0.1)[1];\nuniformm = uniform(nassets, horizon);\ncornkm = cornk(prices, horizon, 5, 5, 10, progress=true);\n┣████████████████████████████████████████┫ 100.0% |30/30 \n\nnames = [\"LOAD\", \"UNIFORM\", \"CORNK\"];\n\nmetrics = (:Sn, :MER, :APY, :Ann_Std, :Ann_Sharpe, :MDD, :Calmar);\n\nall_metrics_vals = OPSMetrics.([loadm.b, uniformm.b, cornkm.b], Ref(rel_pr));\n\n# Draw a bar plot to depict the values of each metric for each algorithm\ngroupedbar(\n  vcat([repeat([String(metric)], length(names)) for metric in metrics]...),\n  [getfield(result, metric) |> last for metric in metrics for result in all_metrics_vals],\n  group=repeat(names, length(metrics)),\n)","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"<img src=\"../assets/performance_eval.png\" width=\"100%\">","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"The plot illustrates the value of each metric for each algorithm. ","category":"page"},{"location":"performance_eval/#Individual-functions","page":"Performance Evaluation","title":"Individual functions","text":"","category":"section"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"The metrics can be calculated individually as well. For instance, in the next code block, I compute each metric individually for the 'CORNK' algorithm.","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"# Compute the cumulative return\njulia> sn_ = sn(cornkm.b, rel_pr)\n31-element Vector{Float64}:\n 1.0\n 1.0056658141861143\n 1.0456910599891474\n ⋮\n 1.0812597940398256\n 1.0561895221684217\n 1.0661252685319844\n\n# Compute the mean excess return\njulia> mer(cornkm.b, rel_pr)\n0.0331885901993342\n\n# Compute the annualized return\njulia> apy_ = apy(last(sn_), size(cornkm.b, 2))\n0.7123367957886144\n\n# Compute the annualized standard deviation\njulia> ann_std_ = ann_std(sn_, dpy=252)\n0.312367085936459\n\n# Compute the annualized sharpe ratio\njulia> rf = 0.02\njulia> ann_sharpe(apy_, rf, ann_std_)\n2.216420445556956\n\n# Compute the maximum drawdown\njulia> mdd_ = mdd(sn_)\n0.06460283126873347\n\n# Compute the calmar ratio\njulia> calmar(apy_, mdd_)\n11.026402121997583\n\njulia> last(all_metrics_vals)\n\n            Cumulative Return: 1.0661252685319844\n        Mean Excessive Return: 0.0331885901993342\n  Annualized Percentage Yield: 0.7123367957886144\nAnnualized Standard Deviation: 0.312367085936459\n      Annualized Sharpe Ratio: 2.216420445556956\n             Maximum Drawdown: 0.06460283126873347\n                 Calmar Ratio: 11.026402121997583","category":"page"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"As shown, the results are consistent with the results obtained using the OPSMetrics function. Individual functions can be found in Functions (see sn, mer, apy, ann_std, ann_sharpe, mdd, and calmar for more information).","category":"page"},{"location":"performance_eval/#References","page":"Performance Evaluation","title":"References","text":"","category":"section"},{"location":"performance_eval/","page":"Performance Evaluation","title":"Performance Evaluation","text":"W. Xi, Z. Li, X. Song and H. Ning. Online portfolio selection with predictive instantaneous risk assessment. Pattern Recognition 144, 109872 (2023).\n\n\n\n","category":"page"},{"location":"fetchdata/#Fetch-Data","page":"Fetch Financial Data","title":"Fetch Data","text":"","category":"section"},{"location":"fetchdata/","page":"Fetch Financial Data","title":"Fetch Financial Data","text":"For fetching the data, one can use the YFinance.jl package:","category":"page"},{"location":"fetchdata/","page":"Fetch Financial Data","title":"Fetch Financial Data","text":"julia> using YFinance, DataFrames\n\njulia> tickers = [\"MMM\", \"CSCO\", \"IBM\", \"INTC\", \"XOM\"];\n\njulia> startdt, enddt = \"2023-04-01\", \"2023-04-27\";\n\njulia> querry = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"adjclose\"] for ticker in tickers];\n\n# In the Julia 1.9.0 and above, the following line can be replaced with `prices = stack(querry)`\njulia> prices = reduce(hcat, querry);\n\n# Let's make a DataFrame out of it for better visualization of the data\njulia> df = DataFrame(prices, tickers);\n\njulia> first(df, 3)\n3×5 DataFrame\n Row │ MMM      CSCO     IBM      INTC     XOM     \n     │ Float64  Float64  Float64  Float64  Float64 \n─────┼─────────────────────────────────────────────\n   1 │  104.57    51.92   132.06    32.89   116.13 \n   2 │  102.25    51.82   131.6     33.1    115.02 \n   3 │  102.29    51.82   132.14    32.83   116.99 ","category":"page"},{"location":"fetchdata/","page":"Fetch Financial Data","title":"Fetch Financial Data","text":"The provided data in several examples within this documentation has been obtained using the code mentioned above.","category":"page"},{"location":"FL/#Follow-the-Loser-(FL)","page":"Follow the Loser","title":"Follow the Loser (FL)","text":"","category":"section"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"The \"Follow the Loser\" (FL) strategy, introduced by Borodin et al. [4], involves reallocating investment weight from a stock with a superior past performance to a stock with unfavorable performance. This approach is grounded in the belief that a stock exhibiting undesirable past performance may offer a favorable return in the future. Presently, this package includes the following FL strategies:","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Reweighted Price Relative Tracking System for Automatic Portfolio Optimization\nAnti-Correlation (Anticor)\nOnline Moving Average Reversion (OLMAR)\nPassive Aggressive Mean Reversion (PAMR)\nConfidence Weighted Mean Reversion (CWMR)","category":"page"},{"location":"FL/#Reweighted-Price-Relative-Tracking-System-for-Automatic-Portfolio-Optimization-(RPRT)","page":"Follow the Loser","title":"Reweighted Price Relative Tracking System for Automatic Portfolio Optimization (RPRT)","text":"","category":"section"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"RPRT, a \"Follow the Loser\" (FL) strategy introduced by Lai et al. [5], automatically allocates distinct weights to price relative predictions based on each asset's performance during the price prediction phase. These weights are continually adjusted. In the portfolio optimization phase, the authors introduced a novel tracking system with a flexible increasing factor to maximize future wealth in the next period. Their study resulted in the design of an efficient algorithm to address portfolio optimization objectives, suitable for large-scale and time-limited scenarios. Through extensive experiments involving six benchmark datasets from real financial markets, encompassing varied assets and time spans, RPRT demonstrated superior performance compared to other state-of-the-art systems. It showcased better cumulative wealth, mean excess return, annual percentage yield, and typical risk metrics. Additionally, RPRT exhibited resilience to substantial transaction costs and delivered swift performance, highlighting its effectiveness and efficiency as an online portfolio selection system.","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"See rprt.","category":"page"},{"location":"FL/#Run-RPRT","page":"Follow the Loser","title":"Run RPRT","text":"","category":"section"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Note: This package is meant to be used by researchers NOT FOR MARKET PRACTITIONERS. Let's run the algorithm on the real market data. In this case, the data is collected as noted in the Fetch Data section.","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"juila> using OnlinePortfolioSelection\n\njulia> size(prices)\n(17, 5)\n\n# OnlinePortfolioSelection suppose that the data is in the form of a matrix\n# where each row is the price vector of the assets at a specific time period.\njulia> prices = prices |> permutedims;\n\njulia> window_length, threshold, epsilon = 2, 0.6, 40;\n\n# Let's run the algorithm for the last 5 days of the data.\njulia> prices = prices[:, end-4:end];\n\njulia> m_rprt = rprt(prices, w=window_length, theta=threshold, epsilon=epsilon);\n\n# Get the weights of the assets for each day\njuila> m_rprt.b\n5×5 Matrix{Float64}:\n 0.2  0.2  0.0  0.0  0.0\n 0.2  0.2  0.0  0.0  0.0\n 0.2  0.2  0.0  0.0  0.0\n 0.2  0.2  1.0  1.0  1.0\n 0.2  0.2  0.0  0.0  0.0","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"One can calculate the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(m_rprt.b, rel_price)\n6-element Vector{Float64}:\n 1.0\n 0.9879822800308067\n 0.985480892911241\n 0.9646654456994471\n 0.9392966194100733\n 0.9448257537201438","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"The outcome reveals an approximate loss of ~6.3% if an investment were made during the provided period. It's important to note that in this scenario, sn automatically considers the last 5 relative prices. Next, let's examine the algorithm's performance based on several significant metrics.","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"julia> results = OPSMetrics(m_rprt.b, rel_price)\n\n            Cumulative Return: 0.945\n                          APY: -0.943\nAnnualized Standard Deviation: 0.202\n      Annualized Sharpe Ratio: -4.760\n             Maximum Drawdown: 0.061\n                 Calmar Ratio: -15.531\n\njulia> results.\nAPY         Ann_Sharpe  Ann_Std     Calmar      MDD         Sn\n\njulia> results.MDD\n0.06070338058992675","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"It is worth mentioning that each metric can be accessed individually by writing results. and pressing the Tab key. Note that one can individually investigate the performance of the algorithm regarding each metric. See sn, ann_std, apy, ann_sharpe, mdd, and calmar. See Performance evaluation section for more information.","category":"page"},{"location":"FL/#Anti-Correlation-(Anticor)","page":"Follow the Loser","title":"Anti-Correlation (Anticor)","text":"","category":"section"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Anticor is an FL strategy introduced by Borodin et al. [4]. The strategy aims to capitalize on the mean-reversion attribute of asset prices. It transfers wealth from asset i to asset j within two consecutive market windows of size w if the growth rate of asset i exceeds that of asset j in the most recent window. It is also contingent on a positive correlation between asset i in the second last window and asset j in the last window. The extent of wealth transferred from asset i to j depends on the correlation strength between the assets and the degree of \"self-anti-correlations\" for each asset i. [1]","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"See anticor.","category":"page"},{"location":"FL/#Run-Anticor","page":"Follow the Loser","title":"Run Anticor","text":"","category":"section"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Note: This package is meant to be used by researchers NOT FOR MARKET PRACTITIONERS. Let's run the algorithm on the real market data. In this case, the data is collected as noted in the Fetch Data section.","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"juila> using OnlinePortfolioSelection\n\njulia> size(prices)\n(17, 5)\n\n# OnlinePortfolioSelection suppose that the data is in the form of a matrix\n# where each row is the price vector of the assets at a specific time period.\njulia> prices = prices |> permutedims;\n\njulia> window_size = 2;\n\n# Let's run the algorithm for the last 15 days of the data.\njulia> m_anticor = anticor(prices[:, end-14:end], window_size);\n\n# Get the weights of the assets for each day\njuila> m_anticor.b\n5×15 Matrix{Float64}:\n 0.2  0.2  0.2  0.2  0.266667   0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0   \n 0.2  0.2  0.2  0.2  0.0333333  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0   \n 0.2  0.2  0.2  0.2  0.0        0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0   \n 0.2  0.2  0.2  0.2  0.433333   1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 0.2  0.2  0.2  0.2  0.266667   0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"One can calculate the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(m_anticor.b, rel_price)\n16-element Vector{Float64}:\n 1.0\n 1.0026929997309684\n 0.9931968903246916\n 0.9939468872805755\n 0.9941204319128776\n ⋮\n 0.9528191316023853\n 0.9355287642277988\n 0.9157684119500683\n 0.8916854826115842\n 0.8969343557511426","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"The outcome suggests that if we had invested in the given period, our wealth would have decreased by approximately 10.3%. Note that in this instance, sn automatically considers the last 15 relative prices.","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Let's now assess the algorithm's performance based on several key metrics.","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"julia> results = OPSMetrics(m_anticor.b, rel_price)\n\n            Cumulative Return: 0.8969343557511426\n                          APY: -0.8391655504688253\nAnnualized Standard Deviation: 0.1618626725690273\n      Annualized Sharpe Ratio: -5.307990636954478\n             Maximum Drawdown: 0.11070937679745295\n                 Calmar Ratio: -7.579895892685864\n\njulia> results.MDD\n0.11070937679745295","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"It is worth mentioning that each metric can be accessed individually by writing results. and pressing the Tab key. Note that one can individually investigate the performance of the algorithm regarding each metric. See sn, ann_std, apy, ann_sharpe, mdd, and calmar. See Performance evaluation section for more information.","category":"page"},{"location":"FL/#Online-Moving-Average-Reversion-(OLMAR)","page":"Follow the Loser","title":"Online Moving Average Reversion (OLMAR)","text":"","category":"section"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"The OLMAR algorithm, short for On-Line Moving Average Reversion [6], introduces a novel approach to online portfolio selection. It incorporates multi-period mean reversion by utilizing “Moving Average Reversion” (MAR), which predicts next price relatives through moving averages. As far as the available literature indicates, OLMAR is the initial algorithm to employ moving averages within the framework of online portfolio selection [7]. While relatively straightforward, OLMAR includes a reasonable updating strategy and has been empirically validated through extensive real-market experiments. Li and Hoi [6] proposed two different variant of the algorithm, namely 'OLMAR' and 'BAH(OLMAR)'. The difference between these two variants is that the latter one defines several OLMAR experts with different window sizes and combines them to achieve a final portfolio. In this package, both variants are provided (See olmar).","category":"page"},{"location":"FL/#Run-OLMAR","page":"Follow the Loser","title":"Run OLMAR","text":"","category":"section"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Let's run the algorithm on the real market data:","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"julia> using OnlinePortfolioSelection, YFinance\n\njulia> tickers = [\"AAPL\", \"MSFT\", \"AMZN\", \"GOOG\", \"META\"];\n\njulia> startdt, enddt = \"2019-01-01\", \"2020-01-01\"\n\njulia> querry = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"adjclose\"] for ticker in tickers];\n\njulia> prices = stack(querry) |> permutedims;\n\njulia> rel_pr = prices[:, 2:end]./prices[:, 1:end-1];\n\njulia> horizon = 5;\njulia> windows = 3;\njulia> epsilon = 4;\n\njulia> m_olmar = olmar(rel_pr, horizon, windows, epsilon);\n\njulia> m_olmar.b\n5×5 Matrix{Float64}:\n 0.2  1.0         0.484825  1.97835e-8  0.0\n 0.2  1.95724e-8  0.515175  0.0         0.0\n 0.2  0.0         0.0       1.0         1.0\n 0.2  0.0         0.0       0.0         0.0\n 0.2  0.0         0.0       0.0         1.9851e-8","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"One can calculate the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"julia> sn(m_olmar.b, rel_pr)\n6-element Vector{Float64}:\n 1.0\n 0.9979181552890171\n 1.017717331692027\n 1.0184883306518602\n 1.0060091504010344\n 1.0065266263361812","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"The outcome highlights a potential gain of ~0.7% if an investment were made during the provided period. Note that in this instance, sn automatically considers the last 5 (horizon=5) relative prices. Next, let's examine the algorithm's performance based on several significant metrics.","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"julia> results = OPSMetrics(m_olmar.b, rel_pr)\n\n            Cumulative Return: 1.0065266263361812\n        Mean Excessive Return: -0.009414275874519928\n  Annualized Percentage Yield: 0.38801292579932145\nAnnualized Standard Deviation: 0.18519745676483274\n      Annualized Sharpe Ratio: 1.9871381185683952\n             Maximum Drawdown: 0.012252649220672674\n                 Calmar Ratio: 31.66767601121445\n\njulia> results.MDD\n0.012252649220672674","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"It is worth mentioning that each metric can be accessed individually by writing results. and pressing the Tab key.","category":"page"},{"location":"FL/#Run-BAH(OLMAR)","page":"Follow the Loser","title":"Run BAH(OLMAR)","text":"","category":"section"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"In order to run this variant, you have to pass a Vector of window sizes to the method as the third positional argument. Let's run the algorithm on the real market data:","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"julia> using OnlinePortfolioSelection, YFinance\n\njulia> tickers = [\"AAPL\", \"MSFT\", \"AMZN\", \"GOOG\", \"META\"];\n\njulia> startdt, enddt = \"2019-01-01\", \"2020-01-01\"\n\njulia> querry = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"adjclose\"] for ticker in tickers];\n\njulia> prices = stack(querry) |> permutedims;\n\njulia> rel_pr = prices[:, 2:end]./prices[:, 1:end-1];\n\njulia> horizon = 5;\njulia> windows = [3, 5, 7];\njulia> epsilon = 4;\n\njulia> model = olmar(rel_pr, horizon, windows, epsilon);\n\njulia> model.b\n5×5 Matrix{Float64}:\n 0.2  0.2  0.333333    0.162297  1.33072e-8\n 0.2  0.2  1.31177e-8  0.555158  0.0\n 0.2  0.2  6.57906e-9  0.0       0.667358\n 0.2  0.2  0.0         0.0       0.332642\n 0.2  0.2  0.666667    0.282545  0.0","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Finally, let's assess the algorithm's performance based on several key metrics.","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"julia> results = OPSMetrics(model.b, rel_pr)\n\n            Cumulative Return: 1.0099455075377595\n        Mean Excessive Return: -0.008744240554973382\n  Annualized Percentage Yield: 0.6467067326806284\nAnnualized Standard Deviation: 0.16828625245124013\n      Annualized Sharpe Ratio: 3.7240518672920873\n             Maximum Drawdown: 0.008831430868281412\n                 Calmar Ratio: 73.22785427708125","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"As can be seen, 'BAH(OLMAR)' has a better performance in terms of the cumulative return, annualized sharpe ratio, and calmar ratio compared to the 'OLMAR' algorithm. However, the maximum drawdown is slightly higher than the 'OLMAR' algorithm. In this case, 'BAH(OLMAR)' algorithm performed better than the 'OLMAR' algorithm in terms of the 'Mean Excessive Return' and 'Annualized Percentage Yield' metrics.","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Note that one can individually investigate the performance of the algorithm regarding each metric. See Performance evaluation section for more information.","category":"page"},{"location":"FL/#Passive-Aggressive-Mean-Reversion-(PAMR)","page":"Follow the Loser","title":"Passive Aggressive Mean Reversion (PAMR)","text":"","category":"section"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"The Passive Aggressive Mean Reversion (PAMR) algorithm [8] is a machine learning model employed in the domain of quantitative finance, specifically designed for trading strategies in mean-reverting markets. PAMR employs a passive-aggressive learning approach to adjust portfolio weights in response to deviations from the mean, aiming to capitalize on mean reversion phenomena prevalent in financial markets. The algorithm's core component, the step size tau_t, is determined by the ratio of the observed error ell_in^t to the squared norm of the discrepancy between the current feature vector mathbfx_t and the mean feature vector barx_t up to time t. The formula for the step size in PAMR is expressed as:","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"tau_t = fracell_in^tleft mathbfx_t - barx_t mathbf1 right^2","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"PAMR-1 and PAMR-2 are variants that modify the calculation of the step size for greater adaptability. PAMR-1 restricts the step size to a maximum value (C), preventing excessively large updates and is expressed as:","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"tau_t = min left C fracell_in^tleft mathbfx_t - barx_t mathbf1 right^2 right","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"On the other hand, PAMR-2 incorporates a more nuanced approach by adding a term related to a constant (C) in the denominator, providing more controlled updates and minimizing extreme adjustments:","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"tau_t = fracell_in^tleft mathbfx_t - barx_t mathbf1 right^2 + frac12C","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"These variants aim to enhance the adaptability and stability of the PAMR algorithm, with PAMR-1 capping the maximum update size and PAMR-2 providing controlled updates to ensure smoother parameter adjustments in response to observed errors. It is worth noting that all three variants of the PAMR algorithm are provided in this package. See PAMR.","category":"page"},{"location":"FL/#Run-PAMR","page":"Follow the Loser","title":"Run PAMR","text":"","category":"section"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Let's run the algorithm on the real market data:","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"julia> using OnlinePortfolioSelection, YFinance\n\njulia> tickers = [\"AAPL\", \"MSFT\", \"AMZN\", \"META\", \"GOOG\"]\n\njulia> startdt, enddt = \"2019-01-01\", \"2020-01-01\"\n\njulia> querry = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"adjclose\"] for ticker in tickers]\n\njulia> prices = stack(querry) |> permutedims\n\njulia> rel_pr =  prices[:, 2:end]./prices[:, 1:end-1]\n\njulia> model = PAMR()\n\njulia> eps = 0.01\n\njulia> result = PAMR(rel_pr, eps, model)\n\njulia> result.b\n5×251 Matrix{Float64}:\n 0.2  0.224672  0.22704   0.230855  0.229743  …  0.0966823  0.0966057  0.0900667\n 0.2  0.196884  0.197561  0.199825  0.203945     0.172787   0.171734   0.171626\n 0.2  0.191777  0.190879  0.178504  0.178478     0.290126   0.289638   0.291135\n 0.2  0.193456  0.193855  0.196363  0.189322     0.182514   0.181609   0.185527\n 0.2  0.193211  0.190665  0.194453  0.198513     0.25789    0.260414   0.261645\n\njulia> sum(result.b, dims=1) .|> isapprox(1.) |> all\ntrue","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"One can calculate the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"julia> sn(result.b, rel_pr)\n252-element Vector{Float64}:\n 1.0\n 0.9561680212268941\n 1.0019306281522522\n ⋮\n 1.4741536647632398\n 1.4768989860970627\n\njulia> sn(result.b, rel_pr) |> last\n1.4768989860970627","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"The result indicates that if we had invested in the given period, we would have gained ~47.7% of our wealth. Note that sn automatically takes the last 251 relative prices in this case.","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Now, let's investiagte the performance of the algorithm according to some of the prominent metrics:","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"julia> results = OPSMetrics(result.b, rel_pr)\n\n            Cumulative Return: 1.4768989860970627\n                          MER: -0.4153297366246913\n                          APY: 0.47919522668054726\nAnnualized Standard Deviation: 0.2379066078050204\n      Annualized Sharpe Ratio: 1.9301491073206631\n             Maximum Drawdown: 0.1390668593306162\n                 Calmar Ratio: 3.445790240659086\n\njulia> results.MDD\n0.1390668593306162","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Note that other variants of the algorithm can be used by changing the model parameter. For instance, let's use the PAMR-1 algorithm (see PAMR1, and PAMR):","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"julia> model = PAMR1(0.01);\n\njulia> result = PAMR(rel_pr, eps, model);\n\njulia> results = OPSMetrics(result.b, rel_pr)\n\n            Cumulative Return: 1.4875128237671749\n                          MER: -0.41530107834650865\n                          APY: 0.48986807082085115\nAnnualized Standard Deviation: 0.2365856617445457\n      Annualized Sharpe Ratio: 1.9860378154623461\n             Maximum Drawdown: 0.1399713874022588\n                 Calmar Ratio: 3.4997729172537","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"In this case, the algorithm has a better performance in terms of the cumulative return, annualized sharpe ratio, and calmar ratio. However, the maximum drawdown is slightly higher than the PAMR algorithm. The same procedure can be applied to the PAMR-2 algorithm (see PAMR2).","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"It is worth mentioning that each metric can be accessed individually by writing results. and pressing the Tab key. Note that one can individually investigate the performance of the algorithm regarding each metric. See sn, ann_std, apy, ann_sharpe, mdd, and calmar. See Performance evaluation section for more information.","category":"page"},{"location":"FL/#Confidence-Weighted-Mean-Reversion-(CWMR)","page":"Follow the Loser","title":"Confidence Weighted Mean Reversion (CWMR)","text":"","category":"section"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Confidence Weighted Mean Reversion (CWMR) [9] combines the mean reversion principle, which assumes that the relative prices of assets tend to return to their historical or intrinsic mean over time, and the confidence weighted learning technique, which models the portfolio vector as a Gaussian distribution and updates it with confidence bounds. CWMR aims to exploit the power of mean reversion for online portfolio selection, and it can adapt to different market conditions and risk preferences. The paper evaluates the performance of CWMR on various real markets and shows that it outperforms the state-of-the-art techniques (see cwmr). It is worth mentioning that all variants of this algorithm have been provided through this package.","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"Let's run the algorithm on the real market data. In order to use this algorithm, you have to install Distributions.jl package. After a successful installation and importing, you can use this algorithm. The deterministic versions of the algorithm are known by by CWMR-Var and CWMR-Stdev and the stochastic ones by CWMR-Var-s and CWMR-Stdev-s. Furthermore, mixed variants are denoted by CWMR-Var-Mix and CWMR-Stdev-Mix for deterministic ones, and CWMR-Var-Mix-s and CWMR-Stdev-Mix-s for stochastic ones. Let's run all the variants of the first method, such as 'CWMR-Var', 'CWMR-Stdev', 'CWMR-Var-s' and 'CWMR-Stdev-s':","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"julia> using OnlinePortfolioSelection, YFinance, Distributions\n\njulia> tickers = [\"AAPL\", \"MSFT\", \"AMZN\"];\n\njulia> startdt, enddt = \"2019-01-01\", \"2019-01-10\";\n\njulia> querry = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"adjclose\"] for ticker=tickers];\n\njulia> prices = stack(querry) |> permutedims;\n\njulia> rel_pr = prices[:, 2:end]./prices[:, 1:end-1];\n\njulia> variant, ptf_distrib = CWMRS, Var;\n\njulia> model = cwmr(rel_pr, 0.5, 0.1, variant, ptf_distrib);\n\njulia> model.b\n3×5 Matrix{Float64}:\n 0.344307  1.0         1.0         0.965464   0.0\n 0.274593  2.76907e-8  0.0         0.0186898  1.0\n 0.3811    2.73722e-8  2.23057e-9  0.0158464  2.21487e-7\n\njulia> variant, ptf_distrib = CWMRD, Var;\n\njulia> model = cwmr(rel_pr, 0.5, 0.1, variant, ptf_distrib);\n\njulia> model.b\n3×5 Matrix{Float64}:\n 0.333333  1.0  1.0  1.0          0.0\n 0.333333  0.0  0.0  3.00489e-10  1.0\n 0.333333  0.0  0.0  0.0          0.0\n\njulia> variant, ptf_distrib = CWMRS, Stdev;\n\njulia> model = cwmr(rel_pr, 0.5, 0.1, variant, ptf_distrib);\n\njulia> model.b\n3×5 Matrix{Float64}:\n 0.340764  1.0         1.0         1.0         0.00107058\n 0.294578  1.086e-8    1.22033e-9  3.26914e-8  0.998929\n 0.364658  1.39844e-8  0.0         6.78125e-9  6.94453e-8\n\njulia> variant, ptf_distrib = CWMRD, Stdev;\n\njulia> model = cwmr(rel_pr, 0.5, 0.1, variant, ptf_distrib);\n\njulia> model.b\n3×5 Matrix{Float64}:\n 0.333333  1.0  1.0  1.0          0.0\n 0.333333  0.0  0.0  3.00475e-10  1.0\n 0.333333  0.0  0.0  0.0          0.0\n\njulia> variant, ptf_distrib = CWMRS, Var;\n\njulia> model = cwmr(rel_pr, [0.5, 0.5], [0.1, 0.1], variant, ptf_distrib);\n\njulia> model.b\n3×5 Matrix{Float64}:\n 0.329642  0.853456   0.863553   0.819096  0.0671245\n 0.338512  0.0667117  0.0694979  0.102701  0.842985\n 0.331846  0.0798325  0.0669491  0.078203  0.0898904\n\njulia> variant, ptf_distrib = CWMRD, Var;\n\njulia> model = cwmr(rel_pr, [0.5, 0.5], [0.1, 0.1], variant, ptf_distrib);\n\njulia> model.b\n3×5 Matrix{Float64}:\n0.333333  0.866506   0.866111   0.864635   0.0671175\n0.333333  0.0667268  0.0669182  0.0676007  0.865363\n0.333333  0.0667675  0.0669704  0.0677642  0.0675194\n\njulia> variant, ptf_distrib = CWMRS, Stdev;\n\njulia> model = cwmr(rel_pr, [0.5, 0.5], [0.1, 0.1], variant, ptf_distrib);\n\njulia> model.b\n3×5 Matrix{Float64}:\n 0.349565  0.832093   0.807798   0.82296    0.0730128\n 0.289073  0.0859194  0.102561   0.109303   0.859462\n 0.361362  0.0819874  0.0896411  0.0677375  0.0675254\n\njulia> variant, ptf_distrib = CWMRD, Stdev;\n\njulia> model = cwmr(rel_pr, [0.5, 0.5], [0.1, 0.1], variant, ptf_distrib);\n\njulia> model.b\n3×5 Matrix{Float64}:\n 0.333333  0.866506   0.866111   0.864635   0.0671175\n 0.333333  0.0667268  0.0669182  0.0676007  0.865363\n 0.333333  0.0667675  0.0669704  0.0677642  0.0675194\n\n# Now, let's pass two different 'EG' portfolios as additional expert's portfolios:\n\njulia> variant, ptf_distrib = CWMRS, Var;\n\njulia> eg1 = eg(rel_pr, eta=0.1).b;\n\njulia> eg2 = eg(rel_pr, eta=0.2).b;\n\njulia> model = cwmr(rel_pr, [0.5, 0.5], [0.1, 0.1], variant, ptf_distrib, adt_ptf=[eg1, eg2]);\n\njulia> model.b\n3×5 Matrix{Float64}:\n 0.318927  0.768507  0.721524  0.753618  0.135071\n 0.338759  0.111292  0.16003   0.133229  0.741106\n 0.342314  0.120201  0.118446  0.113154  0.123823","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"One can calculate the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"julia> sn(model.b, rel_pr)\n6-element Vector{Float64}:\n 1.0\n 0.9494421425374454\n 0.9899730968369733\n 0.9912079696970942\n 1.010103241988922 \n 1.0244230620335244","category":"page"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"The result indicates that if we had invested in the given period, we would have gained ~2.4% of our wealth. Note that sn automatically takes the last 6 relative prices in this case. Check out the Performance evaluation section for more information.","category":"page"},{"location":"FL/#References","page":"Follow the Loser","title":"References","text":"","category":"section"},{"location":"FL/","page":"Follow the Loser","title":"Follow the Loser","text":"A. Borodin, R. El-Yaniv and V. Gogan. Can we learn to beat the best stock. Advances in Neural Information Processing Systems 16 (2003).\n\n\n\nZ.-R. Lai, P.-Y. Yang, L. Fang and X. Wu. Reweighted Price Relative Tracking System for Automatic Portfolio Optimization. IEEE Transactions on Systems, Man, and Cybernetics: Systems 50, 4349–4361 (2020).\n\n\n\nB. Li and S. C. Hoi. On-Line Portfolio Selection with Moving Average Reversion (2012), arXiv:1206.4626 [cs.CE].\n\n\n\nB. Li, S. C. Hoi, D. Sahoo and Z.-Y. Liu. Moving average reversion strategy for on-line portfolio selection. Artificial Intelligence 222, 104–123 (2015).\n\n\n\nB. Li, P. Zhao, S. C. Hoi and V. Gopalkrishnan. PAMR: Passive aggressive mean reversion strategy for portfolio selection. Machine Learning 87, 221–258 (2012).\n\n\n\nB. Li, S. C. Hoi, P. Zhao and V. Gopalkrishnan. Confidence Weighted Mean Reversion Strategy for Online Portfolio Selection. ACM Trans. Knowl. Discov. Data 7 (2013).\n\n\n\n","category":"page"},{"location":"ML/#Meta-Learning-Strategies-(ML)","page":"Meta-Learning","title":"Meta-Learning Strategies (ML)","text":"","category":"section"},{"location":"ML/","page":"Meta-Learning","title":"Meta-Learning","text":"Meta-learning strategies are employed to combine opinions from experts to formulate a final portfolio. Each expert's opinion is represented as a vector of weights summing to one. Subsequently, the performance of each expert is quantified, influencing the final portfolio. Each expert can either be a portfolio optimization model or simply a vector of weights as an input. The following meta-learning strategies are currently implemented in the package:","category":"page"},{"location":"ML/","page":"Meta-Learning","title":"Meta-Learning","text":"Combination Weights based on Online Gradient Descent (CW-OGD)\nContinuous Aggregating Exponential Gradient (CAEG)","category":"page"},{"location":"ML/#Combination-Weights-based-on-Online-Gradient-Descent-(CW-OGD)","page":"Meta-Learning","title":"Combination Weights based on Online Gradient Descent (CW-OGD)","text":"","category":"section"},{"location":"ML/","page":"Meta-Learning","title":"Meta-Learning","text":"Zhang et al. [16] introduced a novel online portfolio selection algorithm leveraging a weighted learning technique and an online gradient descent algorithm. Their strategy demonstrates enhanced robustness by integrating various expert strategies and successfully addresses the challenge of complex computational time. To begin, the authors establish an expert pool encompassing numerous basic expert strategies, among which the strategy investing in a single stock is chosen as the fundamental expert strategy. Subsequently, they employ a loss function to assess the performance of each basic expert strategy and utilize the OGD algorithm to adjust the weight vector for the experts based on their losses.","category":"page"},{"location":"ML/#Run-CW-OGD","page":"Meta-Learning","title":"Run CW-OGD","text":"","category":"section"},{"location":"ML/","page":"Meta-Learning","title":"Meta-Learning","text":"Note: This package is meant to be used by researchers NOT FOR MARKET PRACTITIONERS. Let's run the algorithm on the real market data. (see cwogd for more information.)","category":"page"},{"location":"ML/","page":"Meta-Learning","title":"Meta-Learning","text":"julia> using OnlinePortfolioSelection, YFinance\n\njulia> tickers = [\"AAPL\", \"MSFT\", \"GOOG\"];\n\njulia> startdt, enddt = \"2019-01-01\", \"2019-01-10\";\n\njulia> querry_open_price = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"open\"] for ticker in tickers];\n\njulia> open_pr = reduce(hcat, querry_open_price) |> permutedims;\n\njulia> querry_close_pr = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"adjclose\"] for ticker in tickers];\n\njulia> close_pr = reduce(hcat, querry_close_pr) |> permutedims;\n\njulia> rel_pr = close_pr ./ open_pr\n3×6 Matrix{Float64}:\n 1.01956  0.987568  1.02581  0.994822  1.00796   1.01335\n 1.01577  0.973027  1.02216  1.00413   0.997671  1.00395\n 1.0288   0.976042  1.03692  0.997097  1.00016   0.993538\n\njulia> gamma = 0.1; H = 0.5;\n\njulia> model = cwogd(rel_pr, gamma, H);\n\njulia> model.b\n3×5 Matrix{Float64}:\n 0.333333  0.351048  0.346241  0.338507  0.350524\n 0.333333  0.321382  0.309454  0.320351  0.311853\n 0.333333  0.32757   0.344305  0.341142  0.337623","category":"page"},{"location":"ML/","page":"Meta-Learning","title":"Meta-Learning","text":"Now, let's investiagte the performance of the algorithm according to some of the prominent metrics:","category":"page"},{"location":"ML/","page":"Meta-Learning","title":"Meta-Learning","text":"julia> metrics = OPSMetrics(model.b, rel_pr)\n            Cumulative Return: 1.0323425490046683\n                          APY: 2.8071567518024554\nAnnualized Standard Deviation: 0.2821163077868604\n      Annualized Sharpe Ratio: 9.879459906685577\n             Maximum Drawdown: 0.021128559444089628\n                 Calmar Ratio: 132.86077355300776\n\njuila> metrics.Sn\n7-element Vector{Float64}:\n 1.0\n 1.0213786603648736\n 0.9997984006244297\n 1.0282690253184847\n 1.0266415196096432\n 1.0286957343361505\n 1.0323425490046683","category":"page"},{"location":"ML/","page":"Meta-Learning","title":"Meta-Learning","text":"The result indicates that if we had invested in the given period, we would have gained ~3.2% profit. It is worth mentioning that each metric can be accessed individually by writing results. and pressing the Tab key. Note that one can individually investigate the performance of the algorithm regarding each metric. See sn, ann_std, apy, ann_sharpe, mdd, and calmar. See Performance evaluation section for more information.","category":"page"},{"location":"ML/#Continuous-Aggregating-Exponential-Gradient-(CAEG)","page":"Meta-Learning","title":"Continuous Aggregating Exponential Gradient (CAEG)","text":"","category":"section"},{"location":"ML/","page":"Meta-Learning","title":"Meta-Learning","text":"Xingyu Yang and Zhang [17] presented a new online portfolio strategy that aggregates multiple exponential gradient strategies with different learning rates using the weak aggregating algorithm. The strategy has a universal property that guarantees its average logarithmic growth rate to be the same as the best constant rebalanced portfolio in hindsight. The authors combine the portfolio pool using the following formula:","category":"page"},{"location":"ML/","page":"Meta-Learning","title":"Meta-Learning","text":"mathbfb_t + 1 = fracsumnolimits_eta  in tilde E mathbfb_t + 1left( eta  right)left( S_tleft( eta  right) right)^frac1sqrt t + 1  sumnolimits_eta  in tilde E left( S_tleft( eta  right) right)^frac1sqrt t + 1  ","category":"page"},{"location":"ML/","page":"Meta-Learning","title":"Meta-Learning","text":"where t is the today's index, tilde E =  eta _1eta _2 ldots eta _n is a set of EG experts with different eta parameters, the cumulative return of the expert eta at time t is denoted as S_tleft( eta  right), and the portfolio by expert eta at time t+1 is represented as mathbfb_t + 1.","category":"page"},{"location":"ML/#Run-CAEG","page":"Meta-Learning","title":"Run CAEG","text":"","category":"section"},{"location":"ML/","page":"Meta-Learning","title":"Meta-Learning","text":"Let's run the algorithm on the real market data (Also, see caeg):","category":"page"},{"location":"ML/","page":"Meta-Learning","title":"Meta-Learning","text":"julia> using OnlinePortfolioSelection, YFinance\n\njulia> tickers = [\"AAPL\", \"MSFT\", \"GOOG\"];\n\njulia> startdt, enddt = \"2020-1-1\", \"2020-1-10\";\n\njulia> open_querry = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"open\"] for ticker ∈ tickers];\n\njulia> open_ = stack(open_querry) |> permutedims;\n\njulia> close_querry = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"adjclose\"] for ticker ∈ tickers];\n\njulia> close_ = stack(close_querry) |> permutedims;\n\njulia> rel_pr = close_./open_;\n\njulia> learning_rates = [0.02, 0.05];\n\njulia> model = caeg(rel_pr, learning_rates);\n\njulia> model.b\n3×6 Matrix{Float64}:\n 0.333333  0.333322  0.333286  0.333271  0.333287  0.333368\n 0.333333  0.333295  0.333271  0.333171  0.333123  0.333076\n 0.333333  0.333383  0.333443  0.333558  0.33359   0.333557","category":"page"},{"location":"ML/","page":"Meta-Learning","title":"Meta-Learning","text":"Now, let's investiagte the performance of the algorithm according to some of the prominent metrics:","category":"page"},{"location":"ML/","page":"Meta-Learning","title":"Meta-Learning","text":"julia> metrics = OPSMetrics(model.b, rel_pr)\n\n            Cumulative Return: 1.0503793029297175\n        Mean Excessive Return: -0.041332740360267836\n  Annualized Percentage Yield: 6.880223548529358\nAnnualized Standard Deviation: 0.16251944416204514\n      Annualized Sharpe Ratio: 42.21170939822534\n             Maximum Drawdown: 0.006347966314766578\n                 Calmar Ratio: 1083.8468900700761","category":"page"},{"location":"ML/","page":"Meta-Learning","title":"Meta-Learning","text":"The result indicates that if we had invested in the given period, we would have gained ~5% profit. Please check the Performance evaluation section for more information.","category":"page"},{"location":"ML/#References","page":"Meta-Learning","title":"References","text":"","category":"section"},{"location":"ML/","page":"Meta-Learning","title":"Meta-Learning","text":"Y. Zhang, H. Lin, X. Yang and W. Long. Combining expert weights for online portfolio selection based on the gradient descent algorithm. Knowledge-Based Systems 234, 107533 (2021).\n\n\n\nJ. H. Xingyu Yang and Y. Zhang. Aggregating exponential gradient expert advice for online portfolio selection. Journal of the Operational Research Society 73, 587–597 (2022).\n\n\n\n","category":"page"},{"location":"PM/#Pattern-Matching-(PM)","page":"Pattern-Matching","title":"Pattern-Matching (PM)","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Pattern-matching algorithms stand among the most popular strategies in the domain of online portfolio selection. These algorithms primarily aim to discern patterns within historical price data and employ them for predicting future prices. They align with the perspective of technical analysts who anticipate the repetition of historical patterns in future market behavior. The current package incorporates the following pattern-matching algorithms:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Correlation-driven Nonparametric Learning (CORN)\nCORN-U\nCORN-K\nDynamic RIsk CORrelation-driven Non-parametric (DRICORN-K)\nBᴷ\nClusLog\nKMNLOG\nKMDLOG","category":"page"},{"location":"PM/#Correlation-driven-Nonparametric-Learning","page":"Pattern-Matching","title":"Correlation-driven Nonparametric Learning","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Correlation-driven Nonparametric Learning (CORN) is a pattern-matching algorithm introduced by Li et al. [12]. CORN employs correlation as the measure of similarity between different time windows. Within CORN, multiple experts are defined to generate portfolios. Each trading day involves a combination of expert portfolios to create the final portfolio. The distinction between CORN-K and CORN-U lies in their portfolio construction methods. CORN-K selects the K best experts, determined by their historical performance, to create the final portfolio. Conversely, CORN-U amalgamates all experts uniformly to construct the final portfolio. For further details, refer to cornu and cornk.","category":"page"},{"location":"PM/#Run-CORN-U","page":"Pattern-Matching","title":"Run CORN-U","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"The key parameters for CORN-U include w (maximum window size to be examined) and rho (correlation threshold). Larger values of w involve examining more window sizes, leading to enhanced accuracy but increased algorithm runtime. However, the same relationship does not hold for rho. Extreme values for rho (e.g., 0.99 or 0.01) are advised against by the authors. As CORN is intended to identify time windows with positive directional correlation, negative values for rho are not permissible. From the authors' experiments, an optimal rho value was found to be 0.2, and this has been set as the default value.","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"CORN algorithms, including CORN-U, exhibit improved performance when trained on longer time periods (e.g., ~1 year) for portfolio selection.","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"juila> using OnlinePortfolioSelection\n\njulia> size(prices)\n(268, 5)\n\n# OnlinePortfolioSelection suppose that the data is in the form of a matrix\n# where each row is the price vector of the assets at a specific time period.\njulia> prices = prices |> permutedims;\n\n# run the algorithm on the last 5 days\njulia> horizon, w = 5, 10\n\njulia> model = cornu(prices, horizon, w)\n\njulia> model.b\n5×5 Matrix{Float64}:\n 0.0       0.198536  0.0995612  0.0        0.0\n 0.0       0.389272  0.0        0.0        0.0980504\n 0.0       0.0       0.430479   0.0998267  0.0\n 0.714743  0.0       0.0        0.0        0.203183\n 0.285257  0.412192  0.46996    0.900173   0.698766","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"One can compute the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(model.b, rel_price)\n6-element Vector{Float64}:\n 1.0\n 0.9910701218600744\n 0.9956345799968089\n 1.0038929232387375\n 0.9914403615208097\n 0.9851289224781754","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"The result indicates that the algorithm experienced a loss of 1.5% of the initial wealth during the investment period. Further analysis of the algorithm's performance can be conducted using the ann_std, apy, ann_sharpe, mdd, and calmar functions. For more detailed information, refer to the Performance evaluation section.","category":"page"},{"location":"PM/#Run-CORN-K","page":"Pattern-Matching","title":"Run CORN-K","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"The key parameters of CORN-K include k (number of best experts used for portfolio construction), w (maximum window size to be examined), and rho (number of correlation coefficient thresholds to be examined). CORN-K utilizes the best experts to formulate the final portfolio, aiming to outperform CORN-U. To observe its performance, let's execute CORN-K on the same dataset as used for CORN-U:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"# run the algorithm on the last 5 days\njulia> horizon, k, w, rho = 5, 10, 5, 5, 5;\n\njulia> model = cornk(prices, horizon, k, w, rho);\n\njulia> model.b","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Last but not least, the cumulative return of the algorithm on the investment period and given dataset can be computed by using the sn function:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(model.b, rel_price)\n6-element Vector{Float64}:\n 1.0\n 0.9920219584145965\n 0.997769753240107\n 1.0153550964116513\n 1.004610801506029\n 1.0017637293758395","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Expectedly, CORN-K performed better than CORN-U on the same dataset. The result indicates that the algorithm has gained ~0.18% of the initial wealth during the investment period. Further analysis of the algorithm can be done by using the ann_std, apy, ann_sharpe, mdd, and calmar functions. See Performance evaluation section for more information.","category":"page"},{"location":"PM/#Dynamic-RIsk-CORrelation-driven-Non-parametric","page":"Pattern-Matching","title":"Dynamic RIsk CORrelation-driven Non-parametric","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Dynamic Risk CORrelation-driven Non-parametric (DRICORN)[13] employs a similar principle to CORN-K. However, DRICORN incorporates the beta of the portfolio as a risk measure in the portfolio optimization. Additionally, it considers the recent market trend to capitalize on positive risks while minimizing exposure to negative risks. For further details, refer to dricornk.","category":"page"},{"location":"PM/#Run-DRICORN-K","page":"Pattern-Matching","title":"Run DRICORN-K","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Given that this algorithm is constructed on the CORN-K model, it shares analogous parameters. However, DRICORN-K requires market index data (e.g., S&P 500) to calculate the portfolio's beta and the market trend. Additionally, a coefficient is used to regulate the portfolio's beta, with the default value set to 1e-3. Let's execute DRICORN-K using the same data as CORN-U and CORN-K.","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"# run the algorithm on the last 5 days\njulia> horizon, k, w, rho = 5, 10, 5, 5, 5;\n\njulia> model = dricornk(prices, market_prices, horizon, k, w, rho);\n\njulia> model.b\n4×5 Matrix{Float64}:\n 0.0  0.25  0.25  0.25  0.17438\n 0.0  0.25  0.25  0.25  0.17438\n 0.0  0.25  0.25  0.25  0.174281\n 1.0  0.25  0.25  0.25  0.476959","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Using sn function, one can compute the cumulative wealth during the investment period:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(model.b, rel_price)\n6-element Vector{Float64}:\n 1.0\n 0.9906902403938972\n 0.9867624995658737\n 0.9841621752990845\n 0.9754797369845584\n 0.9738144349688777","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"The result indicates that the algorithm has lost ~2.6% of the initial wealth during the investment period. Further analysis of the algorithm can be done by using the ann_std, apy, ann_sharpe, mdd, and calmar functions. See Performance evaluation section for more information.","category":"page"},{"location":"PM/#Bᴷ","page":"Pattern-Matching","title":"Bᴷ","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Bᴷ, presented as a type of kernel-based investment strategy, is a pattern-matching algorithm introduced by Györfi et al. [14]. In essence, Bᴷ shares similarities with histogram-based strategies, albeit utilizing more flexible elementary strategies that replace rigid past market vector discretization with a \"moving-window\" rule. This implementation incorporates the uniform kernel function. Check bk for more information.","category":"page"},{"location":"PM/#Run-Bᴷ","page":"Pattern-Matching","title":"Run Bᴷ","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"The most important parameter of Bᴷ is k (number of best experts to be used for portfolio construction). Let's run Bᴷ on the same data as CORN-U, CORN-K, etc.:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"julia> using OnlinePortfolioSelection\n\njulia> horizon, k, n_splits, similarity_thresh = 5, 5, 10, 0.2;\n\njulia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\n# run the algorithm on the last 5 days\njulia> model = bk(rel_price[:, end-horizon+1:end], k, n_splits, similarity_thresh);\n\njulia> model.b\n5×5 Matrix{Float64}:\n 0.2  0.2  0.196078  0.156876  0.153047\n 0.2  0.2  0.196078  0.156876  0.250758\n 0.2  0.2  0.215685  0.156876  0.172675\n 0.2  0.2  0.196078  0.156876  0.153047\n 0.2  0.2  0.196079  0.372496  0.270474","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Using sn function, one can compute the cumulative wealth during the investment period:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(model.b, rel_price)\n6-element Vector{Float64}:\n 1.0\n 0.987982263196868\n 0.9854808683947185\n 0.9870411234122491\n 0.9763511652573162\n 0.9698166561732083","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"The result indicates that the algorithm has lost ~3% of the initial wealth during the investment period. Further analysis of the algorithm can be done by using the ann_std, apy, ann_sharpe, mdd, and calmar functions. See Performance evaluation section for more information.","category":"page"},{"location":"PM/#ClusLog","page":"Pattern-Matching","title":"ClusLog","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"ClusLog contains some variant of models proposed by Khedmati and Azin [15], namely, KMNLOG and KMDLOG. The main idea behind these algorithms is to cluster the historical time windows based on their inter-correlation. Then, the algorithm uses a day after the found time windows as the potential day to occur with the same pattern for tomorrow. In order to perform the portfolio selection, the algorithm uses the semi-log optimal approach in order to maximize the expected return of the portfolio. See cluslog.","category":"page"},{"location":"PM/#Run-ClusLog","page":"Pattern-Matching","title":"Run ClusLog","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"In order to use this function, you have to install the Clustering.jl package and import it on your own. The reason behind this design is that I do not intend to add extra dependencies to this package for the sake of just an algorithm. The Clustering.jl package can be installed by running the following command in the Julia REPL:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"julia> using Pkg\n\njulia> pkg\"add Clustering@0.15.2\"\n\n# Or\n\njulia> pkg.add(name=\"Clustering\", version=\"0.15.2\")","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"After intalling the package, you can use the cluslog function after importing the Clustering.jl package. Let's run ClusLog on the same data as CORN-U, CORN-K, etc.:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"julia> using OnlinePortfolioSelection, Clustering\n\njulia> horizon, max_window_size, clustering_model, max_n_clusters, max_n_clustering, optm_boundries = 2, 3, KMNLOG, 3, 7, (0.0, 1.0);\n\njulia> prices = prices |> permutedims;\n\njulia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\n# run the algorithm on the last 2 days\njulia> model = cluslog(rel_price, horizon, max_window_size, clustering_model, max_n_clusters, max_n_clustering, optm_boundries);\n[ Info: Analysis for trading day 1 is done.\n[ Info: Analysis for trading day 2 is done.\n\njulia> model.b\n5×2 Matrix{Float64}:\n 0.963883    0.00479629\n 0.00337321  0.973796\n 0.00657932  0.00360691\n 0.00183594  0.00164263\n 0.0243289   0.0161582","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"Using sn function, one can compute the cumulative wealth during the investment period:","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"julia> sn(model.b, rel_price)\n3-element Vector{Float64}:\n 1.0\n 0.9932798769652941\n 0.9817775041346212","category":"page"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"The result indicates that the algorithm has lost ~1.8% of the initial wealth during the investment period. Further analysis of the algorithm can be done by using the ann_std, apy, ann_sharpe, mdd, and calmar functions. See Performance evaluation section for more information.","category":"page"},{"location":"PM/#References","page":"Pattern-Matching","title":"References","text":"","category":"section"},{"location":"PM/","page":"Pattern-Matching","title":"Pattern-Matching","text":"B. Li, S. C. Hoi and V. Gopalkrishnan. CORN: Correlation-Driven Nonparametric Learning Approach for Portfolio Selection. ACM Trans. Intell. Syst. Technol. 2 (2011).\n\n\n\nS. Sooklal, T. L. van Zyl and A. Paskaramoorthy. DRICORN-K: A Dynamic RIsk CORrelation-driven Non-parametric Algorithm for Online Portfolio Selection. In: Artificial Intelligence Research, edited by A. Gerber (Springer International Publishing, Cham, 2020); pp. 183–196.\n\n\n\nL. Györfi, G. Lugosi and F. Udina. NONPARAMETRIC KERNEL-BASED SEQUENTIAL INVESTMENT STRATEGIES. Mathematical Finance 16, 337–357 (2006).\n\n\n\nM. Khedmati and P. Azin. An online portfolio selection algorithm using clustering approaches and considering transaction costs. Expert Systems with Applications 159, 113546 (2020).\n\n\n\n","category":"page"},{"location":"funcs/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"funcs/","page":"Functions","title":"Functions","text":"Modules = [OnlinePortfolioSelection]\nPrivate = false\nOrder   = [:function]","category":"page"},{"location":"funcs/#OnlinePortfolioSelection.ann_sharpe-Union{Tuple{T}, Tuple{T, T, T}} where T<:AbstractFloat","page":"Functions","title":"OnlinePortfolioSelection.ann_sharpe","text":"ann_sharpe(APY::T, Rf::T, sigma_prtf::T) where T<:AbstractFloat\n\nCalculate the Annualized Sharpe Ratio of investment. Also, see sn, mer, ann_std, apy, mdd, calmar, and OPSMetrics.\n\nArguments\n\nAPY::T: the APY of investment.\nRf::T: the risk-free rate of return.\nsigma_prtf::T: the standard deviation of the portfolio sigma_p.\n\nReturns\n\n::AbstractFloat: the Annualized Sharpe Ratio of investment.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.ann_std-Tuple{AbstractVector{<:AbstractFloat}}","page":"Functions","title":"OnlinePortfolioSelection.ann_std","text":"ann_std(cum_ret::AbstractVector{AbstractFloat}; dpy)\n\nCalculate the Annualized Standard Deviation (σₚ) of portfolio. Also, see sn, mer, apy, ann_sharpe, mdd, calmar, and OPSMetrics.\n\nArguments\n\ncum_ret::AbstractVector{AbstractFloat}: the cumulative return of investment during the investment period.\n\nKeyword Arguments\n\ndpy: the number of days in a year.\n\nReturns\n\n::AbstractFloat: the Annualized Standard Deviation (σₚ) of portfolio.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.anticor-Union{Tuple{T}, Tuple{Matrix{T}, Int64}} where T<:Real","page":"Functions","title":"OnlinePortfolioSelection.anticor","text":"anticor(adj_close::Matrix{T}, window::Int) where {T<:Real}\n\nRun the Anticor algorithm on adj_close with window sizes window.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nArguments\n\nadj_close::Matrix{T}: matrix of adjusted close prices\nwindow::Int: size of the window\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): An OPSAlgorithm object.\n\nExample\n\njulia> using OnlinePortfolioSelection\n\njulia> adj_close = [\n       1. 2.\n       4. 9.\n       7. 8.\n       10. 11.\n       13. 7.\n       8. 17.\n       19. 20.\n       22. 23.\n       25. 8.\n       2. 12.\n       5. 12.\n       5. 0.\n       0. 2.\n       1. 1.\n       ];\n\njulia> adj_close = permutedims(adj_close);\n\njulia> m_anticor = anticor(adj_close, 3);\n\njulia> m_anticor.b\n2×14 Matrix{Float64}:\n 0.5  0.5  0.5  0.5  …  0.0  0.0  0.0  1.0\n 0.5  0.5  0.5  0.5     1.0  1.0  1.0  0.0\n\njulia> sum(m_anticor.b, dims=1) .|> isapprox(1., atol=1e-8) |> all\ntrue\n\nReferences\n\nCan We Learn to Beat the Best Stock\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.apy-Union{Tuple{S}, Tuple{AbstractFloat, S}} where S<:Int64","page":"Functions","title":"OnlinePortfolioSelection.apy","text":"apy(Sn::AbstractFloat, n_periods::S; dpy::S=252) where S<:Int\n\nCalculate the Annual Percentage Yield (APY) of investment. Also, see sn, mer, ann_std, ann_sharpe, mdd, calmar, and OPSMetrics.\n\nArguments\n\nSn::AbstractFloat: the cumulative return of investment.\nn_periods::S: the number investment periods.\ndpy::S=252: the number of days in a year.\n\nReturns\n\n::AbstractFloat: the APY of investment.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.bk-Union{Tuple{S}, Tuple{T}, Tuple{Matrix{T}, S, S, Any}} where {T<:Float64, S<:Int64}","page":"Functions","title":"OnlinePortfolioSelection.bk","text":"bk(rel_price::Matrix{T}, K::S, L::S, c) where {T<:Float64, S<:Int}\n\nRun Bᴷ algorithm.\n\nArguments\n\nrel_price::Matrix{T}: Relative prices of assets.\nK::S: Number of experts.\nL::S: Number of time windows.\nc::T: The similarity threshold.\n\nwarning: Beware!\nrel_price should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): An object of type OPSAlgorithm.\n\nExample\n\njulia> using OnlinePortfolioSelection\n\njulia> daily_relative_prices = rand(10, 100);\n\njulia> model = bk(daily_relative_prices, 10, 10, 0.5);\n\njulia> model.alg\n\"Bᵏ\"\n\njulia> sum(model.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\nReference\n\nNONPARAMETRIC KERNEL-BASED SEQUENTIAL INVESTMENT STRATEGIES\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.bs-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Float64","page":"Functions","title":"OnlinePortfolioSelection.bs","text":"bs(adj_close::Matrix{T}; last_n::Int=0) where {T<:Float64}\n\nRun the Best So Far algorithm on the given data.\n\nArguments\n\nadj_close::Matrix{T}: A matrix of adjusted closing prices of assets.\n\nKeyword Arguments\n\nlast_n::Int: The number of periods to look back for the performance of each asset. If last_n is 0, then the performance is calculated from the first period to the previous period.\n\nwarning: Beware!\nThe adj_close matrix should be in the order of assets x periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): An instance of OPSAlgorithm.\n\nExample\n\njulia> using OnlinePortfolioSelection\n\njulia> adj_close = rand(5, 10);\n\njulia> model = bs(adj_close, last_n=2);\n\njulia> model.b\n5×10 Matrix{Float64}:\n 0.2  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0\n 0.2  0.0  0.0  1.0  0.0  1.0  0.0  0.0  0.0  0.0\n 0.2  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.2  1.0  1.0  0.0  0.0  0.0  1.0  0.0  1.0  1.0\n 0.2  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0\n\njulia> sum(model.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\nReferences\n\nKERNEL-BASED SEMI-LOG-OPTIMAL EMPIRICAL PORTFOLIO SELECTION STRATEGIES\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.caeg-Tuple{AbstractMatrix, AbstractVector}","page":"Functions","title":"OnlinePortfolioSelection.caeg","text":"caeg(rel_pr::AbstractMatrix, ηs::AbstractVector)\n\nRun CAEG algorithm.\n\nArguments\n\nrel_pr::AbstractMatrix: Historical relative prices. The paper's authors used \"the ratio of closing price to last closing price\".\nηs::AbstractVector: Learning rates.\n\nwarning: Beware!\nrel_pr should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm: An OPSAlgorithm object.\n\nExamples\n\njulia> using OnlinePortfolioSelection, YFinance\n\njulia> tickers = [\"AAPL\", \"MSFT\", \"GOOG\"];\n\njulia> startdt, enddt = \"2020-1-1\", \"2020-1-10\";\n\njulia> open_querry = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"open\"] for ticker ∈ tickers];\n\njulia> open_ = stack(open_querry) |> permutedims;\n\njulia> close_querry = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"adjclose\"] for ticker ∈ tickers];\n\njulia> close_ = stack(close_querry) |> permutedims;\n\njulia> rel_pr = close_./open_;\n\njulia> learning_rates = [0.02, 0.05];\n\njulia> model = caeg(rel_pr, learning_rates);\n\njulia> model.b\n3×6 Matrix{Float64}:\n 0.333333  0.333322  0.333286  0.333271  0.333287  0.333368\n 0.333333  0.333295  0.333271  0.333171  0.333123  0.333076\n 0.333333  0.333383  0.333443  0.333558  0.33359   0.333557\n\nReferences\n\nAggregating exponential gradient expert advice for online portfolio selection\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.calmar-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractFloat","page":"Functions","title":"OnlinePortfolioSelection.calmar","text":"calmar(APY::T, MDD::T) where T<:AbstractFloat\n\nCalculate the Calmar Ratio of investment. Also, see sn, mer, ann_std, apy, ann_sharpe, mdd, and OPSMetrics.\n\nArguments\n\nAPY::T: the APY of investment.\nMDD::T: the MDD of investment.\n\nReturns\n\n::AbstractFloat: the Calmar Ratio of investment.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.cluslog","page":"Functions","title":"OnlinePortfolioSelection.cluslog","text":"cluslog(\n  rel_pr::AbstractMatrix{<:AbstractFloat},\n  horizon::Int,\n  TW::Int,\n  clus_mod::Type{<:ClusLogVariant},\n  nclusters::Int,\n  nclustering::Int,\n  boundries::NTuple{2, AbstractFloat};\n  progress::Bool=true\n)\n\nRun KMNLOG, KMDLOG, etc., algorithms on the given data.\n\nnote: Important note\nIn order to use this function, you have to install the Clustering.jl package first, and then import it along with the OnlinePortfolioSelection.jl package:julia> using Pkg; Pkg.add(name=\"Clustering\", version=\"0.15.2\")\njulia> using OnlinePortfolioSelection, Clustering\n\nArguments\n\nrel_pr::AbstractMatrix{<:AbstractFloat}: Relative prices of assets. Each column represents the price of an asset at a given time.\nhorizon::Int: Number of trading days.\nTW::Int: Maximum time window length to be examined.\nclus_mod::Type{<:ClusLogVariant}: Clustering model to be used. Currently, only KMNLOG and KMDLOG are supported.\nnclusters::Int: The maximum number of clusters to be examined.\nnclustering::Int: The number of times clustering algorithm is run for optimal number of clusters.\nboundries::NTuple{2, AbstractFloat}: The lower and upper boundries for the weights of assets in the portfolio.\n\nKeyword Arguments\n\nprogress::Bool=true: Whether to log the progress or not.\n\nwarning: Beware!\nrel_pr should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm: An OPSAlgorithm object.\n\nExample\n\nTwo clustering model is available as of now: KMNLOG, and KMDLOG. The first example utilizes KMNLOG:\n\njulia> using OnlinePortfolioSelection, Clustering\n\njulia> adj_close = [\n         1.5464 1.5852 1.6532 1.7245 1.5251 1.4185 1.2156 1.3231 1.3585 1.4563 1.4456\n         1.2411 1.2854 1.3456 1.4123 1.5212 1.5015 1.4913 1.5212 1.5015 1.4913 1.5015\n         1.3212 1.3315 1.3213 1.3153 1.3031 1.2913 1.2950 1.2953 1.3315 1.3213 1.3315\n       ]\n\njulia> rel_pr = adj_close[:, 2:end]./adj_close[:, 1:end-1]\n\njulia> horizon = 3; TW = 3; nclusters_ = 3; nclustering = 10; lb, ub = 0.0, 1.;\n\njulia> model = cluslog(rel_pr, horizon, TW, KMNLOG, nclusters_, nclustering, (lb, ub));\n\njulia> model.b\n3×3 Matrix{Float64}:\n0.00264911  0.00317815  0.148012\n0.973581    0.971728    0.848037\n0.02377     0.0250939   0.00395028\n\njulia> sum(model.b , dims=1) .|> isapprox(1.) |> all\ntrue\n\nThe same approach works for KMDLOG as well:\n\njulia> using OnlinePortfolioSelection, Clustering\n\njulia> model = cluslog(rel_pr, horizon, TW, KMDLOG, nclusters_, nclustering, (lb, ub));\n\njulia> model.b\n3×3 Matrix{Float64}:\n4.59938e-7  4.96421e-7  4.89426e-7\n0.999998    0.999997    0.999997\n2.02964e-6  2.02787e-6  2.02964e-6\n\njulia> sum(model.b , dims=1) .|> isapprox(1.) |> all\ntrue\n\nSee also KMNLOG, and KMDLOG.\n\nReference\n\nAn online portfolio selection algorithm using clustering approaches and considering transaction costs\n\n\n\n\n\n","category":"function"},{"location":"funcs/#OnlinePortfolioSelection.cornk-Union{Tuple{T}, Tuple{Matrix{Float64}, Vararg{T, 4}}} where T<:Int64","page":"Functions","title":"OnlinePortfolioSelection.cornk","text":"cornk(\n  adj_close::Matrix{Float64},\n  horizon::T,\n  k::T,\n  w::T,\n  p::T;\n  init_budg=1,\n  progress::Bool=false\n) where T<:Int\n\nRun CORN-K algorithm.\n\nArguments\n\nadj_close::Matrix{Float64}: Adjusted close prices of assets.\nhorizon::T: The number of periods to invest.\nk::T: The number of top experts to be selected.\nw::T: maximum length of time window to be examined.\np::T: maximum number of correlation coefficient thresholds.\n\nKeyword Arguments\n\ninit_budg=1: The initial budget for investment.\nprogress::Bool=false: Whether to show the progress bar.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): An object of type OPSAlgorithm.\n\nExamples\n\njulia> using OnlinePortfolioSelection\n\njulia> adj_close = rand(5, 100);\n\njulia> model = cornk(adj_close, 10, 3, 5, 3);\n\njulia> model.alg\n\"CORN-K\"\n\njulia> sum(model.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\nSee cornu, and dricornk.\n\nReference\n\nCORN: Correlation-driven nonparametric learning approach for portfolio selection\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.cornu-Union{Tuple{M}, Tuple{T}, Tuple{Matrix{T}, M, M}} where {T<:Float64, M<:Int64}","page":"Functions","title":"OnlinePortfolioSelection.cornu","text":"cornu(\n  adj_close::Matrix{T},\n  horizon::M,\n  w::M;\n  rho::T=0.2,\n  init_budg=1,\n  progress::Bool=false\n) where {T<:Float64, M<:Int}\n\nRun CORN-U algorithm.\n\nArguments\n\nadj_close::Matrix{T}: Adjusted close prices of assets.\nhorizon::M: The number of periods to invest.\nw::M: maximum length of time window to be examined.\n\nKeyword Arguments\n\nrho::T=0.2: The correlation coefficient threshold.\ninit_budg=1: The initial budget for investment.\nprogress::Bool=false: Whether to show the progress bar.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): An object of type OPSAlgorithm.\n\nExamples\n\njulia> using OnlinePortfolioSelection\n\njulia> adj_close = rand(5, 100);\n\njulia> model = cornu(adj_close, 10, 5, 0.5);\n\njulia> model.alg\n\"CORN-U\"\n\njulia> sum(model.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\nSee cornk, and dricornk.\n\nReference\n\nCORN: Correlation-driven nonparametric learning approach for portfolio selection\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.crp-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Float64","page":"Functions","title":"OnlinePortfolioSelection.crp","text":"crp(adj_close::Matrix{T}) where T<:Float64\n\nRun Constant Rebalanced Portfolio (CRP) algorithm.\n\nArguments\n\nadj_close::Matrix{Float64}: adjusted close prices\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): OPSAlgorithm object\n\nExample\n\njulia> using OnlinePortfolioSelection\n\njulia> typeof(adj_close), size(adj_close)\n(Matrix{Float64}, (3, 10))\n\njulia> m_crp = crp(adj_close);\n\njulia> m_crp.b\n3×10 Matrix{Float64}:\n 0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333\n 0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333\n 0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333  0.333333\n\njulia> sum(m_crp.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\nReferences\n\nUniversal Portfolios\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.cwmr","page":"Functions","title":"OnlinePortfolioSelection.cwmr","text":"cwmr(\n  rel_pr::AbstractMatrix,\n  ϕ::AbstractFloat,\n  ϵ::AbstractFloat,\n  variant::Type{<:CWMRVariant},\n  ptfdis::Type{<:PtfDisVariant}\n)\n\ncwmr(\n  rel_pr::AbstractMatrix,\n  ϕ::AbstractVector,\n  ϵ::AbstractVector,\n  variant::Type{<:CWMRVariant},\n  ptfdis::Type{<:PtfDisVariant};\n  adt_ptf::Union{Nothing, AbstractVector{<:AbstractMatrix}}=nothing\n)\n\nRun the Confidence Weighted Mean Reversion (CWMR) algorithm.\n\nnote: Important note\nIn order to use this function, you have to install the Distributions.jl package first, and then import it along with the OnlinePortfolioSelection.jl package:julia> using Pkg; Pkg.add(\"Distributions\")\njulia> using Distributions, OnlinePortfolioSelection\n\nMethods\n\ncwmr(rel_pr::AbstractMatrix, ϕ::AbstractFloat, ϵ::AbstractFloat, variant::Type{<:CWMRVariant}, ptfdis::Type{<:PtfDisVariant})\ncwmr(rel_pr::AbstractMatrix, ϕ::AbstractVector, ϵ::AbstractVector, variant::Type{<:CWMRVariant}, ptfdis::Type{<:PtfDisVariant}; adt_ptf::Union{Nothing, AbstractVector{<:AbstractMatrix}}=nothing)\n\nMethod 1\n\nThrough this method, we can run the following variants of the CWMR algorithm: CWMR-Var, CWMR-Stdev, CWMR-Var-s and CWMR-Stdev-s.\n\nArguments\n\nrel_pr::AbstractMatrix: Relative prices of the assets.\nϕ::AbstractFloat: Learning rate.\nϵ::AbstractFloat: Expert's weight. It should be ∈ [0, 1].\nvariant::Type{<:CWMRVariant}: Variant of the algorithm. It can be CWMRD or CWMRS.\nptfdis::Type{<:PtfDisVariant}: Portfolio distribution. It can be Var or Stdev.\n\nwarning: Beware!\nrel_pr should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm: An OPSAlgorithm object that contains the result of running the algorithm.\n\nExample\n\nLet's run all the variants of the first method, such as CWMR-Var, CWMR-Stdev, CWMR-Var-s and CWMR-Stdev-s:\n\njulia> using OnlinePortfolioSelection, YFinance, Distributions\n\njulia> tickers = [\"AAPL\", \"MSFT\", \"AMZN\"];\n\njulia> startdt, enddt = \"2019-01-01\", \"2019-01-10\";\n\njulia> querry = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"adjclose\"] for ticker=tickers];\n\njulia> prices = stack(querry) |> permutedims;\n\njulia> rel_pr = prices[:, 2:end]./prices[:, 1:end-1];\n\njulia> variant, ptf_distrib = CWMRS, Var;\n\njulia> model = cwmr(rel_pr, 0.5, 0.1, variant, ptf_distrib);\n\njulia> model.b\n3×5 Matrix{Float64}:\n 0.344307  1.0         1.0         0.965464   0.0\n 0.274593  2.76907e-8  0.0         0.0186898  1.0\n 0.3811    2.73722e-8  2.23057e-9  0.0158464  2.21487e-7\n\nMethod 2\n\nThrough this method, we can run the following variants of the CWMR algorithm: CWMR-Var-Mix, CWMR-Stdev-Mix, CWMR-Var-s-Mix and CWMR-Stdev-s-Mix.\n\nArguments\n\nrel_pr::AbstractMatrix: Relative prices of the assets.\nϕ::AbstractVector: A vector of learning rates.\nϵ::AbstractVector: A vector of expert's weights. Each element should be ∈ [0, 1].\nvariant::Type{<:CWMRVariant}: Variant of the algorithm. It can be CWMRD or CWMRS.\nptfdis::Type{<:PtfDisVariant}: Portfolio distribution. It can be Var or Stdev.\n\nwarning: Beware!\nrel_pr should be a matrix of size n_assets × n_periods.\n\nKeyword Arguments\n\nadt_ptf::Union{Nothing, AbstractVector{<:AbstractMatrix}}=nothing: A vector of additional expert's portfolios.\n\nwarning: Beware!\nadt_ptf can be nothing or a vector of matrices of size n_assets × n_periods. As noted in the paper, the additional expert's portfolios should be chosen from the set of universal strategies, such as 'UP', 'EG', 'ONS', etc. See eg, and up for more details.\n\nReturns\n\n::OPSAlgorithm: An OPSAlgorithm object that contains the result of running the algorithm.\n\nExample\n\nLet's run all the variants of the second method, such as CWMR-Var-Mix, CWMR-Stdev-Mix, CWMR-Var-s-Mix and CWMR-Stdev-s-Mix:\n\njulia> variant, ptf_distrib = CWMRS, Var;\n\njulia> model = cwmr(rel_pr, [0.5, 0.5], [0.1, 0.1], variant, ptf_distrib);\n\njulia> model.b\n3×5 Matrix{Float64}:\n 0.329642  0.853456   0.863553   0.819096  0.0671245\n 0.338512  0.0667117  0.0694979  0.102701  0.842985\n 0.331846  0.0798325  0.0669491  0.078203  0.0898904\n\nNow, let's pass two different 'EG' portfolios as additional expert's portfolios:\n\njulia> variant, ptf_distrib = CWMRS, Var;\n\njulia> eg1 = eg(rel_pr, eta=0.1).b;\n\njulia> eg2 = eg(rel_pr, eta=0.2).b;\n\njulia> model = cwmr(rel_pr, [0.5, 0.5], [0.1, 0.1], variant, ptf_distrib, adt_ptf=[eg1, eg2]);\n\njulia> model.b\n3×5 Matrix{Float64}:\n 0.318927  0.768507  0.721524  0.753618  0.135071\n 0.338759  0.111292  0.16003   0.133229  0.741106\n 0.342314  0.120201  0.118446  0.113154  0.123823\n\nSee Confidence Weighted Mean Reversion (CWMR) for more informaton and examples.\n\nReferences\n\nConfidence Weighted Mean Reversion Strategy for Online Portfolio Selection\n\n\n\n\n\n","category":"function"},{"location":"funcs/#OnlinePortfolioSelection.cwogd-Tuple{AbstractMatrix, AbstractFloat, Any}","page":"Functions","title":"OnlinePortfolioSelection.cwogd","text":"cwogd(\n  rel_pr::AbstractMatrix,\n  γ::AbstractFloat,\n  H;\n  bj::AbstractMatrix=diagm(ones(size(rel_pr, 1)))\n)\n\nRun the CW-OGD algorithm.\n\nPositional Arguments\n\nrel_pr::AbstractMatrix: Relative price matrix where it represents proportion of the closing price to the opening price of each asset in each day.\nγ::AbstractFloat: Regular term coefficient of the basic expert's loss function.\nH::AbstractFloat: Constant for calculating step sizes.\n\nKeyword Arguments\n\nbj::AbstractMatrix=diagm(ones(size(rel_pr, 1))): Matrix of experts opinions. Each column of this matrix must have just one positive element == 1. and others are zero. Also, sum of each column must be equal to 1. and number of rows must be equal to number of rows of rel_pr.\n\nwarning: Beware!\nrel_pr should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm: An object of OPSAlgorithm type.\n\nExample\n\njulia> using OnlinePortfolioSelection, YFinance\n\njulia> tickers = [\"AAPL\", \"MSFT\", \"GOOG\"];\n\njulia> startdt, enddt = \"2019-01-01\", \"2019-01-10\";\n\njulia> querry_open_price = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"open\"] for ticker in tickers];\n\njulia> open_pr = reduce(hcat, querry_open_price) |> permutedims;\n\njulia> querry_close_pr = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"adjclose\"] for ticker in tickers];\n\njulia> close_pr = reduce(hcat, querry_close_pr) |> permutedims;\n\njulia> rel_pr = close_pr ./ open_pr\n3×6 Matrix{Float64}:\n 1.01956  0.987568  1.02581  0.994822  1.00796   1.01335\n 1.01577  0.973027  1.02216  1.00413   0.997671  1.00395\n 1.0288   0.976042  1.03692  0.997097  1.00016   0.993538\n\njulia> gamma = 0.1; H = 0.5;\n\njulia> model = cwogd(rel_pr, gamma, H);\n\njulia> model.b\n3×5 Matrix{Float64}:\n 0.333333  0.351048  0.346241  0.338507  0.350524\n 0.333333  0.321382  0.309454  0.320351  0.311853\n 0.333333  0.32757   0.344305  0.341142  0.337623\n\njulia> sum(model.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\nOr using a custom matrix of experts opinions:\n\njulia> b1 = [\n          0.0 1.0 0.0\n          1.0 0.0 0.0\n          0.0 0.0 1.0\n        ]\n\njulia> model = cwogd(rel_pr, gamma, H, bj=b1);\n\njulia> model.b\n3×6 Matrix{Float64}:\n 0.333333  0.329802  0.347517  0.34271   0.334976  0.346992\n 0.333333  0.322351  0.3104    0.298472  0.309369  0.300871\n 0.333333  0.347847  0.342083  0.358819  0.355655  0.352137\n\njulia> sum(model.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\nReferences\n\n[1] Combining expert weights for online portfolio selection based on the gradient descent algorithm.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.dricornk-Union{Tuple{M}, Tuple{T}, Tuple{Matrix{T}, Vector{T}, Vararg{M, 4}}} where {T<:Float64, M<:Int64}","page":"Functions","title":"OnlinePortfolioSelection.dricornk","text":"dricornk(\n  adj_close::Matrix{T},\n  adj_close_market::Vector{T},\n  horizon::M,\n  k::M,\n  w::M,\n  p::M;\n  lambda::T=1e-3,\n  init_budg=1,\n  progress::Bool=false\n) where {T<:Float64, M<:Int}\n\nRun the DRICORNK algorithm.\n\nArguments\n\nadj_close::Matrix{T}: A matrix of adjusted close prices of the assets.\nadj_close_market::Vector{T}: A vector of adjusted close prices of the market in the same period.\nhorizon::M: The investment horizon.\nk::M: The number of experts.\nw::M: maximum length of time window to be examined.\np::M: maximum number of correlation coefficient thresholds.\n\nKeyword Arguments\n\nlambda::T=1e-3: The regularization parameter.\ninit_budg=1: The initial budget for investment.\nprogress::Bool=false: Whether to show the progress bar.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): An object of type OPSAlgorithm.\n\nExample\n\njulia> using OnlinePortfolioSelection\n\njulia> stocks_adj, market_adj = rand(10, 100), rand(100);\n\njulia> m_dricornk = dricornk(stocks_adj, market_adj, 5, 2, 4, 3);\n\njulia> sum(m_dricornk.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\nSee cornk, and cornu.\n\nReference\n\nDRICORN-K: A Dynamic RIsk CORrelation-driven Non-parametric Algorithm for Online Portfolio Selection\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.eg-Tuple{AbstractMatrix}","page":"Functions","title":"OnlinePortfolioSelection.eg","text":"eg(rel_pr::AbstractMatrix; eta::AbstractFloat=0.05)\n\nExponential Gradient (EG) algorithm.\n\nCalculate the Exponential Gradient (EG) weights and budgets using the given historical prices and parameters and return an EG object.\n\nArguments\n\nrel_pr::AbstractMatrix: Historical relative prices.\n\nKeyword Arguments\n\neta::AbstractFloat=0.05: Learning rate.\n\nwarning: Beware!\nrel_pr should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): OPSAlgorithm object.\n\nExamples\n\njulia> using OnlinePortfolioSelection\n\njulia> typeof(rel_pr), size(rel_pr)\n(Matrix{Float64}, (3, 10))\n\njulia> m_eg = eg(rel_pr);\n\njulia> m_eg.b\n3×10 Matrix{Float64}:\n 0.333333  0.334092  0.325014  0.331234  0.314832  0.324674  0.326467  0.357498  0.353961  0.340167\n 0.333333  0.345278  0.347718  0.337116  0.359324  0.363286  0.36466   0.348263  0.345386  0.355034\n 0.333333  0.32063   0.327267  0.331649  0.325843  0.31204   0.308873  0.294239  0.300652  0.304799\n\njulia> sum(m_eg.b, dims=1) .|> isapprox(1.0) |> all\ntrue\n\nReferences\n\nOn-Line Portfolio Selection Using Multiplicative Updates\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.load-Union{Tuple{S}, Tuple{T}, Tuple{AbstractMatrix{T}, T, S, S, T}} where {T<:Float64, S<:Int64}","page":"Functions","title":"OnlinePortfolioSelection.load","text":"load(adj_close::AbstractMatrix{T}, α::T, ω::S, horizon::S, η::T, ϵ::T=1.5) where {T<:Float64, S<:Int}\n\nRun LOAD algorithm.\n\nArguments\n\nadj_close::AbstractMatrix{T}: Adjusted close price data.\nα::T: Decay factor. (0 < α < 1)\nω::S: Window size. (ω > 0)\nhorizon::S: Investment horizon. (n_periods > horizon > 0)\nη::T: Threshold value. (η > 0)\nϵ::T=1.5: Expected return threshold value.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm: An object of type OPSAlgorithm containing the weights of each asset for each period.\nSₜ::Vector{Float64}: Cumulative wealth for each period.\n\nExample\n\n# Get data\njulia> using YFinance\njulia> startdt, enddt = \"2022-04-01\", \"2023-04-27\";\njulia> querry = [\n          get_prices(ticker, startdt=startdt, enddt=enddt)[\"adjclose\"] for ticker in tickers\n       ];\njulia> prices = reduce(hcat, querry);\njulia> prices = permutedims(prices);\n\njulia> using OnlinePortfolioSelection\n\njulia> model, s = load(prices, 0.5, 30, 5, 0.1);\n\njulia> model.b\n5×5 Matrix{Float64}:\n 0.2  2.85298e-8  0.0        0.0       0.0\n 0.2  0.455053    0.637299   0.694061  0.653211\n 0.2  0.215388    0.0581291  0.0       0.0\n 0.2  0.329559    0.304572   0.305939  0.346789\n 0.2  6.06128e-9  0.0        0.0       0.0\n\njulia> sum(model.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\njulia> s\n6-element Vector{Float64}:\n 1.0\n 0.9879822754225864\n 0.9853561439014098\n 0.9836737048568326\n 0.971437501096619\n 0.9660091217094392\n\nReferences\n\nA local adaptive learning system for online portfolio selection\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.mdd-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:AbstractFloat","page":"Functions","title":"OnlinePortfolioSelection.mdd","text":"mdd(Sn::AbstractVector{T}) where T<:AbstractFloat\n\nCalculate the Maximum Drawdown (MDD) of investment. Also, see sn, mer, ann_std, apy, ann_sharpe, calmar, and OPSMetrics.\n\nArguments\n\nSn::AbstractVector{T}: the cumulative return of investment during the investment period.\n\nReturns\n\n::AbstractFloat: the MDD of investment.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.mer-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, T}} where T<:AbstractFloat","page":"Functions","title":"OnlinePortfolioSelection.mer","text":"mer(\n  weights::AbstractMatrix{T},\n  rel_pr::AbstractMatrix{T},\n  𝘷::T=0.\n) where T<:AbstractFloat\n\nCalculate the investments's Mean excess return (MER). Also, see sn, ann_std, apy, ann_sharpe, mdd, calmar, and OPSMetrics.\n\nArguments\n\nweights::AbstractMatrix{T}: the weights of the portfolio.\nrel_pr::AbstractMatrix{T}: the relative price of the stocks.\n𝘷::T=0.: the transaction cost rate.\n\nwarning: Warning\nThe size of weights and rel_pr must be (n_stocks, n_periods).\n\nnote: Note\nIf size(rel_pr, 2) is greater than size(weights, 2), then the last size(weights, 2) columns of rel_pr will be used.\n\nReturns\n\nMER::AbstractFloat: the investments's Mean excess return (MER).\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.mrvol-Union{Tuple{S}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, S, S, S, T, T}} where {T<:AbstractFloat, S<:Integer}","page":"Functions","title":"OnlinePortfolioSelection.mrvol","text":"mrvol(\n  rel_pr::AbstractMatrix{T},\n  rel_vol::AbstractMatrix{T},\n  horizon::S,\n  Wₘᵢₙ::S,\n  Wₘₐₓ::S,\n  λ::T,\n  η::T\n) where {T<:AbstractFloat, S<:Integer}\n\nRun MRvol algorithm.\n\nArguments\n\nrel_pr::AbstractMatrix{T}: Relative price matrix where it represents proportion of the closing price to the opening price of each asset in each day.\nrel_vol::AbstractMatrix{T}: Relative volume matrix where 𝘷ᵢⱼ represents the tᵗʰ trading volume of asset 𝑖 divided by the (t - 1)ᵗʰ trading volume of asset 𝑖.\nhorizon::S: Investment horizon. The last horizon days of the data will be used to run the algorithm.\nWₘᵢₙ::S: Minimum window size.\nWₘₐₓ::S: Maximum window size.\nλ::T: Trade-off parameter in the loss function.\nη::T: Learning rate.\n\nwarning: Beware!\nrel_pr and rel_vol should be matrixes of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm: An OPSAlgorithm object.\n\nExample\n\njulia> using OnlinePortfolioSelection, YFinance\n\njulia> tickers = [\"AAPL\", \"MSFT\", \"GOOG\"];\n\njulia> startdt, enddt = \"2019-01-01\", \"2020-01-01\";\n\njulia> querry_open_price = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"open\"] for ticker in tickers];\n\njulia> open_pr = reduce(hcat, querry_open_price) |> permutedims;\n\njulia> querry_close_pr = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"adjclose\"] for ticker in tickers];\n\njulia> close_pr = reduce(hcat, querry_close_pr) |> permutedims;\n\njulia> querry_vol = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"vol\"] for ticker in tickers];\n\njulia> vol = reduce(hcat, querry_vol) |> permutedims;\n\njulia> rel_pr = (close_pr ./ open_pr)[:, 2:end];\n\njulia> rel_vol = vol[:, 2:end] ./ vol[:, 1:end-1];\n\njulia> size(rel_pr) == size(rel_vol)\ntrue\n\njulia> horizon = 100; Wₘᵢₙ = 4; Wₘₐₓ = 10; λ = 0.05; η = 0.01;\n\njulia> r = mrvol(rel_pr, rel_vol, horizon, Wₘᵢₙ, Wₘₐₓ, λ, η);\n\njulia> r.b\n3×100 Matrix{Float64}:\n 0.333333  0.0204062  0.0444759  …  0.38213   0.467793\n 0.333333  0.359864   0.194139      0.213264  0.281519\n 0.333333  0.61973    0.761385      0.404606  0.250689\n\nReferences\n\nOnline portfolio selection of integrating expert strategies based on mean reversion and trading volume.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.olmar-Tuple{AbstractMatrix, Int64, Int64, Int64}","page":"Functions","title":"OnlinePortfolioSelection.olmar","text":"olmar(rel_pr::AbstractMatrix, horizon::Int, ω::Int, ϵ::Int)\nolmar(rel_pr::AbstractMatrix, horizon::Int, ω::AbstractVector{<:Int}, ϵ::Int)\n\nMethod 1\n\nRun the Online Moving Average Reversion algorithm (OLMAR).\n\nArguments\n\nrel_pr::AbstractMatrix: Matrix of relative prices.\nhorizon::Int: Investment horizon.\nω::Int: Window size.\nϵ::Int: Reversion threshold.\n\nwarning: Beware!\nrel_pr should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm: An OPSAlgorithm object.\n\nExample\n\njulia> using OnlinePortfolioSelection, YFinance\n\njulia> tickers = [\"AAPL\", \"MSFT\", \"AMZN\", \"GOOG\", \"META\"];\n\njulia> startdt, enddt = \"2019-01-01\", \"2020-01-01\"\n\njulia> querry = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"adjclose\"] for ticker in tickers];\n\njulia> prices = stack(querry) |> permutedims;\n\njulia> rel_pr = prices[:, 2:end]./prices[:, 1:end-1];\n\njulia> horizon = 5;\njulia> windows = 3;\njulia> epsilon = 4;\n\njulia> m_olmar = olmar(rel_pr, horizon, windows, epsilon);\n\njulia> m_olmar.b\n5×5 Matrix{Float64}:\n 0.2  1.0         0.484825  1.97835e-8  0.0\n 0.2  1.95724e-8  0.515175  0.0         0.0\n 0.2  0.0         0.0       1.0         1.0\n 0.2  0.0         0.0       0.0         0.0\n 0.2  0.0         0.0       0.0         1.9851e-8\n\njulia> all(sum(m_olmar.b, dims=1) .≈ 1.0)\ntrue\n\nMethod 2\n\nRun BAH(OLMAR) algorithm.\n\nArguments\n\nrel_pr::AbstractMatrix: Matrix of relative prices.\nhorizon::Int: Investment horizon.\nω::AbstractVector{<:Int}: Window sizes.\nϵ::Int: Reversion threshold.\n\nwarning: Beware!\nrel_pr should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm: An OPSAlgorithm object.\n\nExample\n\njulia> using OnlinePortfolioSelection, YFinance\n\njulia> tickers = [\"AAPL\", \"MSFT\", \"AMZN\", \"GOOG\", \"META\"];\n\njulia> startdt, enddt = \"2019-01-01\", \"2020-01-01\"\n\njulia> querry = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"adjclose\"] for ticker in tickers];\n\njulia> prices = stack(querry) |> permutedims;\n\njulia> rel_pr = prices[:, 2:end]./prices[:, 1:end-1];\n\njulia> horizon = 5;\njulia> windows = [3, 5, 7];\njulia> epsilon = 4;\n\njulia> model = olmar(rel_pr, horizon, windows, epsilon);\n\njulia> model.b\n5×5 Matrix{Float64}:\n 0.2  0.2  0.333333    0.162297  1.33072e-8\n 0.2  0.2  1.31177e-8  0.555158  0.0\n 0.2  0.2  6.57906e-9  0.0       0.667358\n 0.2  0.2  0.0         0.0       0.332642\n 0.2  0.2  0.666667    0.282545  0.0\n\nReferences\n\nOn-Line Portfolio Selection with Moving Average Reversion\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.opsmethods-Tuple{}","page":"Functions","title":"OnlinePortfolioSelection.opsmethods","text":"opsmethods()\n\nPrint the available methods in the package.\n\nExample\n\njulia> using OnlinePortfolioSelection\n\njulia> opsmethods()\n\n      ===== OnlinePortfolioSelection.jl =====\n            Currently available methods\n       =====================================\n\n        up: Universal Portfolio - Call `up`\n        eg: Exponential Gradient - Call `eg`\n     cornu: CORN-U - Call `cornu`\n          ⋮\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.pamr-Tuple{AbstractMatrix, AbstractFloat, OnlinePortfolioSelection.PAMRModel}","page":"Functions","title":"OnlinePortfolioSelection.pamr","text":"pamr(rel_pr::AbstractMatrix, ϵ::AbstractFloat, C::AbstractFloat, model::PAMRModel)\n\nRun the PAMR algorithm on the matrix of relative prices rel_pr.\n\nArguments\n\nrel_pr::AbstractMatrix: matrix of relative prices.\nϵ::AbstractFloat: Sensitivity parameter.\nC::AbstractFloat: Aggressiveness parameter.\nmodel::PAMRModel: PAMR model to use. All three variants, namely, PAMR(), PAMR1(), and PAMR2() are supported.\n\nwarning: Beware!\nrel_price should be a matrix of size n_assets × n_periods.\n\nOutput\n\n::OPSAlgorithm: An object of type OPSAlgorithm.\n\nExample\n\njulia> using OnlinePortfolioSelection, YFinance\n\njulia> tickers = [\"AAPL\", \"MSFT\", \"AMZN\", \"META\", \"GOOG\"]\n\njulia> startdt, enddt = \"2019-01-01\", \"2020-01-01\"\n\njulia> querry = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"adjclose\"] for ticker in tickers]\n\njulia> prices = stack(querry) |> permutedims\n\njulia> rel_pr =  prices[:, 2:end]./prices[:, 1:end-1]\n\njulia> model = PAMR()\n\njulia> eps = 0.01\n\njulia> result = pamr(rel_pr, eps, model)\n\njulia> result.b\n5×251 Matrix{Float64}:\n 0.2  0.224672  0.22704   0.230855  0.229743  …  0.0966823  0.0966057  0.0900667\n 0.2  0.196884  0.197561  0.199825  0.203945     0.172787   0.171734   0.171626\n 0.2  0.191777  0.190879  0.178504  0.178478     0.290126   0.289638   0.291135\n 0.2  0.193456  0.193855  0.196363  0.189322     0.182514   0.181609   0.185527\n 0.2  0.193211  0.190665  0.194453  0.198513     0.25789    0.260414   0.261645\n\njulia> sum(result.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\nIn the same way, you can use PAMR1() and PAMR2():\n\njulia> model = PAMR1(C=0.02)\n\njulia> eps = 0.01\n\njulia> result = pamr(rel_pr, eps, model)\n\njulia> result.b\n5×251 Matrix{Float64}:\n 0.2  0.200892  0.200978  0.201116  …  0.196264  0.19626   0.196257  0.19602\n 0.2  0.199887  0.199912  0.199994     0.198835  0.199017  0.198979  0.198975\n 0.2  0.199703  0.19967   0.199223     0.203659  0.203261  0.203243  0.203297\n 0.2  0.199763  0.199778  0.199868     0.199246  0.199351  0.199319  0.19946\n 0.2  0.199754  0.199662  0.199799     0.201997  0.20211   0.202202  0.202246\n\njulia> model = PAMR2(C=1.)\n\njulia> eps = 0.01\n\njulia> result = pamr(rel_pr, eps, model)\n\njulia> result.b\n5×251 Matrix{Float64}:\n 0.2  0.219093  0.220963  0.223948  …  0.119093  0.119013  0.118953  0.11385\n 0.2  0.197589  0.198123  0.199895     0.175224  0.179199  0.178376  0.178291\n 0.2  0.193636  0.192928  0.183242     0.279176  0.27052   0.270138  0.271307\n 0.2  0.194936  0.19525   0.197214     0.183626  0.185922  0.185215  0.188272\n 0.2  0.194746  0.192736  0.195701     0.242882  0.245346  0.247319  0.248279\n\nReferences\n\nPAMR: Passive aggressive mean reversion strategy for portfolio selection\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.ppt","page":"Functions","title":"OnlinePortfolioSelection.ppt","text":"ppt(\n  prices::AbstractMatrix,\n  w::Int,\n  ϵ::Int,\n  horizon::Int,\n  b̂ₜ::AbstractVector=ones(size(prices, 1))/size(prices, 1)\n)\n\nRun the Price Peak Tracking (PPT) algorithm.\n\nArguments\n\nprices::AbstractMatrix: Matrix of prices.\nw::Int: Window size.\nϵ::Int: Constraint parameter.\nhorizon::Int: Number of days to run the algorithm.\nb̂ₜ::AbstractVector=ones(size(prices, 1))/size(prices, 1): Initial weights.\n\nwarning: Beware!\nprices should be a matrix of size n_assets × n_periods.\n\nOutput\n\n::OPSAlgorithm: An object of type OPSAlgorithm.\n\nExample\n\njulia> using OnlinePortfolioSelection, YFinance\n\njulia> tickers = [\"AAPL\", \"AMZN\", \"GOOG\", \"MSFT\"];\n\njulia> querry = [get_prices(ticker, startdt=\"2019-01-01\", enddt=\"2020-01-01\")[\"adjclose\"] for ticker in tickers];\n\njulia> prices = stack(querry) |> permutedims;\n\njulia> model = ppt(prices, 10, 100, 100);\n\njulia> sum(model, dims=1) .|> isapprox(1.) |> all\ntrue\n\nReferences\n\nA Peak Price Tracking-Based Learning System for Portfolio Selection\n\n\n\n\n\n","category":"function"},{"location":"funcs/#OnlinePortfolioSelection.rprt-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Float64","page":"Functions","title":"OnlinePortfolioSelection.rprt","text":"rprt(\n  adj_close::Matrix{T};\n  w::Int64=5,\n  theta::T=0.8,\n  epsilon=50\n) where T<:Float64\n\nRun RPRT algorithm.\n\nArguments\n\nadj_close::Matrix{T}: Adjusted close prices of assets.\n\nKeyword Arguments\n\nw::Int64=5: maximum length of time window to be examined.\ntheta::T=0.8: The threshold for the relative price.\nepsilon=50: The threshold for the condition of the portfolio.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): An object of type OPSAlgorithm.\n\nExamples\n\njulia> using OnlinePortfolioSelection\n\njulia> typeof(adj_close), size(adj_close)\n(Matrix{Float64}, (3, 7))\n\njulia> m_rprt = rprt(adj_close);\n\njulia> m_rprt.b\n3×7 Matrix{Float64}:\n 0.333333  0.333333  0.0  0.0  0.0  1.0  0.0\n 0.333333  0.333333  1.0  1.0  1.0  0.0  1.0\n 0.333333  0.333333  0.0  0.0  0.0  0.0  0.0\n\njulia> sum(m_rprt.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\nReference\n\nReweighted Price Relative Tracking System for Automatic Portfolio Optimization\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.sn-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}} where T<:AbstractFloat","page":"Functions","title":"OnlinePortfolioSelection.sn","text":"sn(weights::AbstractMatrix{T}, rel_pr::AbstractMatrix{T}; init_inv::T=1.) where T<:AbstractFloat\n\nCalculate the cumulative return of the portfolio during a period of time. Also, see mer, ann_std, apy, ann_sharpe, mdd, calmar, and OPSMetrics.\n\nThe formula for calculating the cumulative return of the portfolio is as follows:\n\nS_n = S_0prodlimits_t = 1^T leftlangle b_tx_t rightrangle \n\nwhere S_0 is the initial budget, n is the investment horizon, b_t is the vector of weights of the period t, and x_t is the relative price of the t-th period.\n\nArguments\n\nweights::AbstractMatrix{T}: the weights of the portfolio.\nrel_pr::AbstractMatrix{T}: the relative price of the stocks.\n\nKeyword Arguments\n\ninit_inv::T=1: the initial investment.\n\nwarning: Beware!\nThe size of weights and rel_pr must be (n_stocks, n_periods).\n\nnote: Note\nIf size(rel_pr, 2) is greater than size(weights, 2), then the last size(weights, 2) columns of rel_pr will be used.\n\nReturns\n\nall_sn::Vector{T}: the cumulative return of investment during the investment period.\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.uniform-Tuple{Int64, Int64}","page":"Functions","title":"OnlinePortfolioSelection.uniform","text":"uniform(n_assets::Int, horizon::Int)\n\nConstruct uniform portfolios.\n\nArguments\n\nn_assets::Int: The number of assets.\nhorizon::Int: The number of investment periods.\n\nReturns\n\n::OPSAlgorithm: An object of OPSAlgorithm type.\n\nExample\n\njulia> using OnlinePortfolioSelection\n\njulia> model = uniform(3, 10)\n\njulia> sum(model.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\n\n\n\n\n","category":"method"},{"location":"funcs/#OnlinePortfolioSelection.up-Tuple{Matrix{Float64}}","page":"Functions","title":"OnlinePortfolioSelection.up","text":"up(adj_close::Matrix{Float64}; eval_points::Int=10^4)\n\nUniversal Portfolio (UP) algorithm.\n\nCalculate the Universal Portfolio (UP) weights and budgets using the given historical prices and parameters.\n\nArguments\n\nadj_close::Matrix{Float64}: Historical adjusted close prices.\n\nKeyword Arguments\n\neval_points::Int=10^4: Number of evaluation points.\n\nwarning: Beware!\nadj_close should be a matrix of size n_assets × n_periods.\n\nReturns\n\n::OPSAlgorithm(n_assets, b, alg): OPSAlgorithm object.\n\nExamples\n\njulia> using OnlinePortfolioSelection\n\njulia> typeof(adj_close), size(adj_close)\n(Matrix{Float64}, (3, 30))\n\njulia> m_up = up(adj_close);\n\njulia> m_up.b\n3×30 Matrix{Float64}:\n 0.333333  0.331149  0.33204   0.331716  …  0.326788  0.325788  0.325829  0.326222\n 0.333333  0.336058  0.335239  0.336304     0.343405  0.342161  0.342283  0.340693\n 0.333333  0.332793  0.33272   0.331981     0.329807  0.332051  0.331888  0.333086\n\njulia> sum(m_up.b, dims=1) .|> isapprox(1.) |> all\ntrue\n\nReferences\n\nUniversal Portfolios\n\n\n\n\n\n","category":"method"},{"location":"FW/#Follow-the-Winner-(FW)","page":"Follow the Winner","title":"Follow the Winner (FW)","text":"","category":"section"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"The Follow the Winner (FW) strategies operate on the principle that assets that have shown superior performance in the past are likely to continue excelling in the future. In this package, the following FW strategies have been implemented:","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Exponential Gradient (EG)\nPrice Peak Tracking (PPT)","category":"page"},{"location":"FW/#Exponential-Gradient","page":"Follow the Winner","title":"Exponential Gradient","text":"","category":"section"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Exponential Gradient (EG) is a FW strategy introduced by Helmbold et al. [10]. The authors assert that EG can nearly attain the same wealth as the best constant rebalanced portfolio (BCRP), discerned retrospectively from the actual market outcomes. This algorithm is notably straightforward to implement.","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"See eg.","category":"page"},{"location":"FW/#Run-EG","page":"Follow the Winner","title":"Run EG","text":"","category":"section"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Let's run the algorithm on the real market data. The data is collected as noted in the \"Fetch-Data\" section.","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"juila> using OnlinePortfolioSelection\n\njulia> size(prices)\n(17, 5)\n\n# OnlinePortfolioSelection suppose that the data is in the form of a matrix\n# where each row is the price vector of the assets at a specific time period.\njulia> prices = prices |> permutedims;\n\njulia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\n# Let's run the algorithm on the last 5 days of the data.\njulia> m_eg = eg(rel_price[:, end-4:end], eta=0.02);\n\njuila> m_eg.b\n5×5 Matrix{Float64}:\n 0.2  0.199997  0.199998  0.200013  0.200025\n 0.2  0.199926  0.199974  0.199997  0.20001\n 0.2  0.20005   0.20004   0.200024  0.200076\n 0.2  0.200011  0.19995   0.199862  0.1998\n 0.2  0.200016  0.200039  0.200105  0.200089","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"One can calculate the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"julia> sn(m_eg.b, rel_price)\n6-element Vector{Float64}:\n 1.0\n 0.9879822592665679\n 0.985479797067587\n 0.9871244111946488\n 0.9773536585545797\n 0.9716460557458115","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"The outcome suggests that if we had invested during the given period, we would have incurred a loss of approximately 2.8% of our wealth. It's important to note that sn automatically considers the last 5 relative prices in this case. Let's proceed to investigate the algorithm's performance using key metrics.","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"julia> results = OPSMetrics(m_eg.b, rel_price)\n\n            Cumulative Return: 0.9716460557458115\n        Mean Excessive Return: 0.022895930308319247\n  Annualized Percentage Yield: -0.7653568719687657\nAnnualized Standard Deviation: 0.08718280263716766\n      Annualized Sharpe Ratio: -9.008162713433503\n             Maximum Drawdown: 0.028353944254188468\n                 Calmar Ratio: -26.992959607575816\n\njulia> results.\nAPY         Ann_Sharpe  Ann_Std     Calmar      MDD         Sn\n\njulia> results.MDD\n0.028353944254188468","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"It is worth mentioning that each metric can be accessed individually by writing results. and pressing the Tab key. Note that one can individually investigate the performance of the algorithm regarding each metric. See sn, ann_std, apy, ann_sharpe, mdd, and calmar. See Performance evaluation section for more information.","category":"page"},{"location":"FW/#Price-Peak-Tracking-(PPT)","page":"Follow the Winner","title":"Price Peak Tracking (PPT)","text":"","category":"section"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"The Price Peak Tracking (PPT) algorithm [11] is a novel linear learning system for online portfolio selection, based on the idea of tracking control. The algorithm uses a transform function that aggressively tracks the increasing power of different assets, and allocates more investment to the better performing ones. The PPT objective can be solved by a fast backpropagation algorithm, which is suitable for large-scale and time-limited applications, such as high-frequency trading. The algorithm has been shown to outperform other state-of-the-art systems in computational time, cumulative wealth, and risk-adjusted metrics (See ppt).","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"Let's run the algorithm on the real market data.","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"julia> using OnlinePortfolioSelection, YFinance\n\njulia> tickers = [\"AAPL\", \"AMZN\", \"GOOG\", \"MSFT\"];\n\njulia> querry = [get_prices(ticker, startdt=\"2019-01-01\", enddt=\"2020-01-01\")[\"adjclose\"] for ticker in tickers];\n\njulia> prices = stack(querry) |> permutedims;\n\njulia> model = ppt(prices, 10, 100, 100);\n\njulia> model.b\n4×100 Matrix{Float64}:\n 0.25  1.0  0.999912    0.999861    …  0.0         0.0       \n 0.25  0.0  2.92288e-5  4.63411e-5     1.00237e-8  9.72784e-9\n 0.25  0.0  2.92288e-5  4.63411e-5     1.0         1.0\n 0.25  0.0  2.92288e-5  4.63411e-5     0.0         0.0","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"One can calculate the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(model.b, rel_price)\n101-element Vector{Float64}:\n 1.0\n 0.9888797685444782\n 0.9863705003355839\n ⋮\n 1.250897464327529\n 1.2363240910685966\n 1.2371383272398555","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"The outcome suggests that if we had invested during the given period, we would have incurred a loss of approximately 2.8% of our wealth. It's important to note that sn automatically considers the last 5 relative prices in this case. Let's proceed to investigate the algorithm's performance using key metrics.","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"julia> results = OPSMetrics(model.b, rel_price)\n\n            Cumulative Return: 1.2371383272398555\n        Mean Excessive Return: -0.15974968844419762\n  Annualized Percentage Yield: 0.709598073342651\nAnnualized Standard Deviation: 0.1837958159802144\n      Annualized Sharpe Ratio: 3.751979171369636\n             Maximum Drawdown: 0.04210405543971303\n                 Calmar Ratio: 16.853437654211092\n\njulia> results.MER\n-0.15974968844419762","category":"page"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"It is worth mentioning that each metric can be accessed individually by writing results. and pressing the Tab key. Note that one can individually investigate the performance of the algorithm regarding each metric. See sn, ann_std, apy, ann_sharpe, mdd, and calmar. See Performance evaluation section for more information.","category":"page"},{"location":"FW/#References","page":"Follow the Winner","title":"References","text":"","category":"section"},{"location":"FW/","page":"Follow the Winner","title":"Follow the Winner","text":"D. P. Helmbold, R. E. Schapire, Y. Singer and M. K. Warmuth. On-Line Portfolio Selection Using Multiplicative Updates. Mathematical Finance 8, 325–347 (1998).\n\n\n\nZ.-R. Lai, D.-Q. Dai, C.-X. Ren and K.-K. Huang. A Peak Price Tracking-Based Learning System for Portfolio Selection. IEEE Transactions on Neural Networks and Learning Systems 29, 2823–2832 (2018).\n\n\n\n","category":"page"},{"location":"refs/#References","page":"References","title":"References","text":"","category":"section"},{"location":"refs/","page":"References","title":"References","text":"B. Li and S. C. Hoi. Online Portfolio Selection: A Survey (2013).\n\n\n\nT. M. Cover. Universal Portfolios. Mathematical Finance 1, 1–29 (1991).\n\n\n\nL. GYÖRFI, A. URBÁN and I. VAJDA. KERNEL-BASED SEMI-LOG-OPTIMAL EMPIRICAL PORTFOLIO SELECTION STRATEGIES. International Journal of Theoretical and Applied Finance 10, 505–516 (2007).\n\n\n\nA. Borodin, R. El-Yaniv and V. Gogan. Can we learn to beat the best stock. Advances in Neural Information Processing Systems 16 (2003).\n\n\n\nZ.-R. Lai, P.-Y. Yang, L. Fang and X. Wu. Reweighted Price Relative Tracking System for Automatic Portfolio Optimization. IEEE Transactions on Systems, Man, and Cybernetics: Systems 50, 4349–4361 (2020).\n\n\n\nB. Li and S. C. Hoi. On-Line Portfolio Selection with Moving Average Reversion (2012), arXiv:1206.4626 [cs.CE].\n\n\n\nB. Li, S. C. Hoi, D. Sahoo and Z.-Y. Liu. Moving average reversion strategy for on-line portfolio selection. Artificial Intelligence 222, 104–123 (2015).\n\n\n\nB. Li, P. Zhao, S. C. Hoi and V. Gopalkrishnan. PAMR: Passive aggressive mean reversion strategy for portfolio selection. Machine Learning 87, 221–258 (2012).\n\n\n\nB. Li, S. C. Hoi, P. Zhao and V. Gopalkrishnan. Confidence Weighted Mean Reversion Strategy for Online Portfolio Selection. ACM Trans. Knowl. Discov. Data 7 (2013).\n\n\n\nD. P. Helmbold, R. E. Schapire, Y. Singer and M. K. Warmuth. On-Line Portfolio Selection Using Multiplicative Updates. Mathematical Finance 8, 325–347 (1998).\n\n\n\nZ.-R. Lai, D.-Q. Dai, C.-X. Ren and K.-K. Huang. A Peak Price Tracking-Based Learning System for Portfolio Selection. IEEE Transactions on Neural Networks and Learning Systems 29, 2823–2832 (2018).\n\n\n\nB. Li, S. C. Hoi and V. Gopalkrishnan. CORN: Correlation-Driven Nonparametric Learning Approach for Portfolio Selection. ACM Trans. Intell. Syst. Technol. 2 (2011).\n\n\n\nS. Sooklal, T. L. van Zyl and A. Paskaramoorthy. DRICORN-K: A Dynamic RIsk CORrelation-driven Non-parametric Algorithm for Online Portfolio Selection. In: Artificial Intelligence Research, edited by A. Gerber (Springer International Publishing, Cham, 2020); pp. 183–196.\n\n\n\nL. Györfi, G. Lugosi and F. Udina. NONPARAMETRIC KERNEL-BASED SEQUENTIAL INVESTMENT STRATEGIES. Mathematical Finance 16, 337–357 (2006).\n\n\n\nM. Khedmati and P. Azin. An online portfolio selection algorithm using clustering approaches and considering transaction costs. Expert Systems with Applications 159, 113546 (2020).\n\n\n\nY. Zhang, H. Lin, X. Yang and W. Long. Combining expert weights for online portfolio selection based on the gradient descent algorithm. Knowledge-Based Systems 234, 107533 (2021).\n\n\n\nJ. H. Xingyu Yang and Y. Zhang. Aggregating exponential gradient expert advice for online portfolio selection. Journal of the Operational Research Society 73, 587–597 (2022).\n\n\n\nH. Guan and Z. An. A local adaptive learning system for online portfolio selection. Knowledge-Based Systems 186, 104958 (2019).\n\n\n\nH. Lin, Y. Zhang and X. Yang. Online portfolio selection of integrating expert strategies based on mean reversion and trading volume. Expert Systems with Applications 238, 121472 (2024).\n\n\n\nW. Xi, Z. Li, X. Song and H. Ning. Online portfolio selection with predictive instantaneous risk assessment. Pattern Recognition 144, 109872 (2023).\n\n\n\n","category":"page"},{"location":"Combined/#Introduction","page":"Combined Strategies","title":"Introduction","text":"","category":"section"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"Nowadays researchers are trying to take advantage of each strategy and propose new methods that combine them. I plan to implement some of these methods in this package. A list of the methods that I've implemented so far is as follows:","category":"page"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"LOcal ADaptive learning system (LOAD)\nMRvol","category":"page"},{"location":"Combined/#LOcal-ADaptive-learning-system-(LOAD)","page":"Combined Strategies","title":"LOcal ADaptive learning system (LOAD)","text":"","category":"section"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"Guan and An [18] proposed a new OPS method, named LOcal ADaptive learning system (LOAD), which is a combination of the Follow the Winner (FW) and Follow the Loser principles. They tried to find the stocks that have a positive trend in the most recent time window by fitting a linear regression on the price data of the stocks against time. They used momentum principle to predict the next price of assets in this case. On the other hand, for the stocks that does not have a satisfactory trend in the most recent time window, they used the mean reversion principle to predict the next price of assets. They claim that through this fusion, the overall system can be more adaptive and effective than systems based on single strategies. After predicting the next prices, the next relative prices are predicted and used in the portfolio optimization.","category":"page"},{"location":"Combined/#Run-LOAD","page":"Combined Strategies","title":"Run LOAD","text":"","category":"section"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"Note: This package is meant to be used by researchers NOT FOR MARKET PRACTITIONERS. Let's run the algorithm on the real market data.","category":"page"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"julia> using OnlinePortfolioSelection, YFinance\n\njulia> tickers = [\"AAPL\", \"MSFT\", \"AMZN\"];\n\njulia> startdt, enddt = \"2022-04-01\", \"2023-04-27\";\n\njulia> prices = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"adjclose\"] for ticker in tickers];\n\njulia> prices = reduce(hcat, prices);\n\njulia> prices = prices |> permutedims;\n\njulia> d_fac, window, horizon, eta = 0.5, 10, 5, 0.1;\n\njulia> model = load(prices, d_fac, window, horizon, eta);\n\n# Get the portfolio weights\njulia> model.b\n3×5 Matrix{Float64}:\n 0.333333  2.65043e-10  1.65697e-8  0.669392  0.329286\n 0.333333  1.0          1.0         0.330608  0.670714\n 0.333333  0.0          0.0         0.0       0.0 ","category":"page"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"The result indicates that if we had invested in the given period, we would have gained ~1.2% profit. Now, let's investiagte the performance of the algorithm according to some of the prominent metrics:","category":"page"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"juli> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> metrics = OPSMetrics(model.b, rel_price)\n            Cumulative Return: 1.0121073197606183\n                          APY: 0.8340827024050514\nAnnualized Standard Deviation: 0.40329283437815505\n      Annualized Sharpe Ratio: 2.0185895533212266\n             Maximum Drawdown: 0.034767207138433065\n                 Calmar Ratio: 23.990500562325092\n\njulia> metrics.Sn\n6-element Vector{Float64}:\n 1.0\n 0.9937811173943497\n 0.9925654837139548\n 0.9787063658040356\n 0.9652327928615669\n 1.0121073197606183","category":"page"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"It is worth mentioning that each metric can be accessed individually by writing results. and pressing the Tab key. Note that one can individually investigate the performance of the algorithm regarding each metric. See sn, ann_std, apy, ann_sharpe, mdd, and calmar. See Performance evaluation section for more information.","category":"page"},{"location":"Combined/#MRvol","page":"Combined Strategies","title":"MRvol","text":"","category":"section"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"Combination of meta-learning algorithms with other strategies are also investogated. For example, Lin et al. [19] proposed a new OPS method, named MRvol, which is a combination of the Follow the Loser (FL) and Meta-Learning (ML) strategies. First, they try to select the stocks that have the relative price bellow than 1 as the first filter, and then search for the stock that have the most relative volume value among the filtered stocks as the second filter. Then, they apply a meta-algorithm to integrate expert opinions (i.e., expert strategies), which are obtained based on mean reversion and trading volume. Thirdly, they determine the window size of the expert strategy as W and establish an expert strategy. When the expert constructs a stock portfolio, he/she identifies an investment target asset for each period, so there are W investment target assets. As they said, in order to reduce investment risk and increase diversification of investment, this paper considers using moving window data of different sizes to construct a pool of expert strategies, which is also called a pool of expert opinions, and then applies meta-algorithm in machine learning technique to integrate expert opinions to propose an investment strategy.","category":"page"},{"location":"Combined/#Run-MRvol","page":"Combined Strategies","title":"Run MRvol","text":"","category":"section"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"Let's run the algorithm on the real market data.","category":"page"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"julia> using OnlinePortfolioSelection, YFinance\n\njulia> tickers = [\"AAPL\", \"MSFT\", \"GOOG\"];\n\njulia> startdt, enddt = \"2019-01-01\", \"2020-01-01\";\n\njulia> querry_open_price = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"open\"] for ticker in tickers];\n\njulia> open_pr = reduce(hcat, querry_open_price) |> permutedims;\n\njulia> querry_close_pr = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"adjclose\"] for ticker in tickers];\n\njulia> close_pr = reduce(hcat, querry_close_pr) |> permutedims;\n\njulia> querry_vol = [get_prices(ticker, startdt=startdt, enddt=enddt)[\"vol\"] for ticker in tickers];\n\njulia> vol = reduce(hcat, querry_vol) |> permutedims;\n\njulia> rel_pr = (close_pr ./ open_pr)[:, 2:end];\n\njulia> rel_vol = vol[:, 2:end] ./ vol[:, 1:end-1];\n\njulia> size(rel_pr) == size(rel_vol)\ntrue\n\njulia> horizon = 100; Wₘᵢₙ = 4; Wₘₐₓ = 10; λ = 0.05; η = 0.01;\n\njulia> r = mrvol(rel_pr, rel_vol, horizon, Wₘᵢₙ, Wₘₐₓ, λ, η);\n\njulia> r.b\n3×100 Matrix{Float64}:\n 0.333333  0.0204062  0.0444759   …   0.38213   0.467793      \n 0.333333  0.359864   0.194139        0.213264  0.281519\n 0.333333  0.61973    0.761385        0.404606  0.250689\n\njulia> sum(r.b, dims=1) .|> isapprox(1.0) |> all\ntrue","category":"page"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"Now, let's investiagte the performance of the algorithm according to some of the prominent metrics:","category":"page"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"julia> metrics = OPSMetrics(r.b, rel_pr)\n            Cumulative Return: 1.0277067897356449\n                          APY: 0.07129838196490379\nAnnualized Standard Deviation: 0.1224831726093685\n      Annualized Sharpe Ratio: 0.41881983354977265\n             Maximum Drawdown: 0.0692690958483587\n                 Calmar Ratio: 1.0292956922808336\n\njulia> metrics.Sn\n101-element Vector{Float64}:\n 1.0\n 0.9945454662509302\n 0.9889386321026037\n 1.0108661401532446\n ⋮\n 1.0219508111711197\n 1.0185657113697373\n 1.0277067897356449","category":"page"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"The result of metrics.Sn indicates that if we had invested in the given period, we would have gained ~2.8% profit. It is worth mentioning that each metric can be accessed individually by writing results. and pressing the Tab key. Note that one can individually investigate the performance of the algorithm regarding each metric. See sn, ann_std, apy, ann_sharpe, mdd, and calmar. See Performance evaluation section for more information.","category":"page"},{"location":"Combined/#References","page":"Combined Strategies","title":"References","text":"","category":"section"},{"location":"Combined/","page":"Combined Strategies","title":"Combined Strategies","text":"H. Guan and Z. An. A local adaptive learning system for online portfolio selection. Knowledge-Based Systems 186, 104958 (2019).\n\n\n\nH. Lin, Y. Zhang and X. Yang. Online portfolio selection of integrating expert strategies based on mean reversion and trading volume. Expert Systems with Applications 238, 121472 (2024).\n\n\n\n","category":"page"},{"location":"python/#Use-OnlinePortfolioSelection.jl-in-Python","page":"Use In Python","title":"Use OnlinePortfolioSelection.jl in Python","text":"","category":"section"},{"location":"python/","page":"Use In Python","title":"Use In Python","text":"Generally, Julia packages can be used in a Python environment with ease by employing wrapper packages that facilitate the translation of Julia functionalities into Python. A notable package in this domain is PyJulia. Comprehensive installation guidelines can be found in the PyJulia documentation. To leverage Julia packages in Python, previously discussed methods have covered importing Julia code into Python (1, 2). In this section, I'll demonstrate how to utilize OnlinePortfolioSelection.jl in Python. For resolution of potential issues during package importation, please refer to this discussion.","category":"page"},{"location":"python/","page":"Use In Python","title":"Use In Python","text":"Begin by installing PyJulia via pip install julia. Ensure that the Julia path is added to the system environment variable PATH, enabling the usage of julia from the command line. Typically, the Julia path is found in \\.julia\\juliaup\\julia-<VERSION>\\bin or C:\\Users\\your-user-name\\AppData\\Local\\Programs\\Julia\\Julia-<VERSION>\\bin.\nLaunch Python.\nExecute the subsequent commands in Python.","category":"page"},{"location":"python/","page":"Use In Python","title":"Use In Python","text":">>> from julia import Pkg\n>>> Pkg.add(\"OnlinePortfolioSelection\")\n>>> from julia import OnlinePortfolioSelection as OPS","category":"page"},{"location":"python/#Run-[MRvol](@ref)-Algorithm","page":"Use In Python","title":"Run MRvol Algorithm","text":"","category":"section"},{"location":"python/","page":"Use In Python","title":"Use In Python","text":"In this instance, I'm demonstrating the execution of the MRvol algorithm.","category":"page"},{"location":"python/","page":"Use In Python","title":"Use In Python","text":"# Generate a random relatvive price matrix. The rows are the assets, and the columns represent the time.\n>>> import numpy as np\n>>> rel_pr = np.random.rand(3, 100)\n>>> rel_vol = np.random.rand(3, 100)\n>>> horizon, Wmin, Wmax, lambdaa, eta = (10, 4, 10, 0.05, 0.01)\n>>> model = OPS.mrvol(rel_pr, rel_vol, horizon, Wmin, Wmax, lambdaa, eta)\n>>> type(model)\n<class 'PyCall.jlwrap'>\n>>> model.b\narray([[0.33333333, 0.36104291, 0.3814967 , 0.26303273, 0.16525094,\n        0.23471654, 0.28741473, 0.34746891, 0.41769629, 0.34582386],\n      [0.33333333, 0.35745995, 0.24895616, 0.30306051, 0.36527706,\n        0.2817696 , 0.36959982, 0.43371551, 0.48357232, 0.51374896],\n      [0.33333333, 0.28149714, 0.36954713, 0.43390676, 0.469472  ,\n        0.48351386, 0.34298546, 0.21881558, 0.09873139, 0.14042718]])\n>>> type(model.b)\n<class 'numpy.ndarray'>\n>>> model.b.sum(axis=0)\narray([1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])\n>>> model.alg\n'MRvol'\n>>> model.n_assets\n3","category":"page"},{"location":"python/","page":"Use In Python","title":"Use In Python","text":"As demonstrated, the mrvol function returns a PyCall.jlwrap object. Access the portfolio weights through model.b, automatically converted into a numpy.ndarray. Similarly, other attributes of the model object can be accessed. To inspect the attributes of the model object further, refer to the documentation for the returned object via the mrvol function. Now, proceed to calculate the algorithm's performance based on notable metrics:","category":"page"},{"location":"python/","page":"Use In Python","title":"Use In Python","text":">>> metrics = OPS.OPSMetrics(model.b, rel_pr)\n>>> metrics\n\n<PyCall.jlwrap             Cumulative Return: 0.0003879435247256176\n                          APY: -1.0\nAnnualized Standard Deviation: 2.7595804965778328\n      Annualized Sharpe Ratio: -0.36962139762362656\n             Maximum Drawdown: 0.9996120564752744\n                 Calmar Ratio: -1.0003880940833123\n\n>>> metrics.Sn\narray([1.00000000e+00, 5.75525607e-01, 1.45701657e-01, 7.12853019e-02,\n       4.30702987e-02, 2.03865521e-02, 1.53802433e-02, 7.10270166e-03,\n       1.97878448e-03, 8.65966074e-04, 3.87943525e-04])","category":"page"},{"location":"python/","page":"Use In Python","title":"Use In Python","text":"As observed, the OPSMetrics function returns a PyCall.jlwrap object. The cumulative wealth of portfolios is accessable through metrics.Sn, automatically converted into a numpy.ndarray. Other attributes of the metrics object can be accessed similarly. To further explore the attributes of the metrics object, review the documentation for the returned object using the OPSMetrics function. Additionally, documentation for each function can be accessed through Python. For instance, you can retrieve the documentation for the mrvol function by executing the following commands:","category":"page"},{"location":"python/","page":"Use In Python","title":"Use In Python","text":">>> from julia import Main as jl\n>>> jl.Docs.doc(OPS.mrvol)\n<PyCall.jlwrap mrvol(       rel*pr::AbstractMatrix{T},       rel*vol::AbstractMatrix{T},       horizon::S,       Wₘᵢₙ::S,       Wₘₐₓ::S,       λ::T,       η::T     ) where {T<:AbstractFloat, S<:Integer}\n\nRun MRvol algorithm.\n\n# Arguments\n\n  * `rel_pr::AbstractMatrix{T}`: Relative price matrix where it represents proportion of the closing price to the opening price of each asset in each day.\n  * `rel_vol::AbstractMatrix{T}`: Relative volume matrix where 𝘷ᵢⱼ represents the tᵗʰ trading volume of asset 𝑖 divided by the (t - 1)ᵗʰ trading volume of asset 𝑖.\n  * `horizon::S`: Investment horizon. The last `horizon` days of the data will be used to run the algorithm.\n  * `Wₘᵢₙ::S`: Minimum window size.\n  * `Wₘₐₓ::S`: Maximum window size.\n  * `λ::T`: Trade-off parameter in the loss function.\n  * `η::T`: Learning rate.\n\n# Returns\n\n  * `OPSAlgorithm`: An [`OPSAlgorithm`](@ref) object.\n\n# Example\n\n...","category":"page"},{"location":"python/#Run-[ClusLog](@ref)-Algorithm","page":"Use In Python","title":"Run ClusLog Algorithm","text":"","category":"section"},{"location":"python/","page":"Use In Python","title":"Use In Python","text":"Another example can be using cluslog function to perform 'KMNLOG' or 'KMDLOG' model (see ClusLog, KMNLOG, and KMDLOG for more details):","category":"page"},{"location":"python/","page":"Use In Python","title":"Use In Python","text":"# before running the following code, please read the\n# instruction to install Julia package in Python that is\n# described in the beginning of this page.\n>>> from julia import Main as jl\n>>> from julia import OnlinePortfolioSelection as OPS\n# In order to use `cluslog` algorithm, you need to install `Clustering` package in Julia.\n>>> from julia import Pkg\n>>> Pkg.add(name=\"Clustering\", version=\"0.15.2\")\n>>> from julia import Clustering\n\n>>> import numpy as np\n>>> rel_pr = np.random.rand(3, 150)\n>>> horizon, max_tw_len, clustering_model = 50, 10, OPS.KMNLOG\n>>> max_n_clus, max_n_clustering, asset_bounderies = 10, 10, (0., 1.)\n>>> model = OPS.cluslog(rel_pr, horizon, max_tw_len, clustering_model, max_n_clus, max_n_clustering, asset_bounderies)\n█████████████████████████████████████┫ 100.0% |50/50\n# The weights of the portfolios are stored in `model.b`.\n>>> model.b.sum(axis=0)\narray([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,\n       1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,\n       1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])","category":"page"},{"location":"benchmark/#Benchmark-Strategies","page":"Benchmark","title":"Benchmark Strategies","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"In the domain of online portfolio selection, certain strategies are considered benchmark strategies. One of the simplest is the Buy and Hold (BH) strategy, often referred to as the market strategy. BH involves an equal investment in m assets at the beginning, maintaining these allocations throughout the subsequent periods, leading to passive weight adjustments based on the assets' price variations. An optimized version, the Best-Stock (BS) strategy, allocates all capital to the best-performing asset over the periods. These benchmark portfolio selection models are straightforward, lacking the use of sophisticated statistical or machine learning techniques to uncover data patterns. Consequently, they serve as baselines for evaluating the performance of newly developed models. Another benchmark strategy, the Constant Rebalanced Portfolio (CRP), maintains a fixed weight for each asset over a specified period. The currently implemented strategies in this package include:","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Constant Rebalanced Portfolio (CRP)\nBest Stock (BS)\nUniform Portfolio (1/N)\nUP","category":"page"},{"location":"benchmark/#CRP","page":"Benchmark","title":"CRP","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Let's run the algorithm [2] on the real market data. Assume the data (named as prices) is collected as noted in the Fetch Data section.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"juila> using OnlinePortfolioSelection\n\njulia> size(prices)\n(17, 5)\n\n# OnlinePortfolioSelection suppose that the data is in the form of a matrix\n# where each row is the price vector of the assets at a specific time period.\njulia> prices = prices |> permutedims;\n\n# Let's run the algorithm on the last 5 days of the data.\njulia> m_crp = crp(prices[:, end-4:end]);\n\njuila> m_crp.b\n5×5 Matrix{Float64}:\n 0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"One can calculate the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(m_crp.b, rel_price)\n6-element Vector{Float64}:\n 1.0\n 0.9879822623031318\n 0.9854808899164217\n 0.9871240426268018\n 0.977351149446221\n 0.9716459683279461","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"The outcome demonstrates that if we had invested during the specified period, we would have incurred a loss of approximately 2.8% of our capital. It's important to note that sn automatically considers the last 5 relative prices in this instance. Let's further analyze the algorithm's performance based on some significant metrics:","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"julia> results = OPSMetrics(m_crp.b, rel_price)\n\n            Cumulative Return: 0.972\n                          APY: -0.765\nAnnualized Standard Deviation: 0.087\n      Annualized Sharpe Ratio: -9.008\n             Maximum Drawdown: 0.028\n                 Calmar Ratio: -26.993\n\njulia> results.\nAPY         Ann_Sharpe  Ann_Std     Calmar      MDD         Sn\n\njulia> results.MDD\n0.02835403167205386","category":"page"},{"location":"benchmark/#BS","page":"Benchmark","title":"BS","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"The model [3] is a variant of the BAH strategy that retroactively acquires the best stock. Within this package, users can select the number of days to retrospectively examine (using the last_n keyword argument) and identify the best stock. If last_n is either not provided or set to 0, the algorithm will consider the entire dataset up to the present day for each period to identify the best stock. Conversely, if last_n is specified, the algorithm will only consider the performance of each stock within the last last_n days and then select the best-performing one. To implement the algorithm on real market data, let's assume the data is collected as detailed in the Fetch Data section.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"juila> using OnlinePortfolioSelection\n\njulia> size(prices)\n(17, 5)\n\n# OnlinePortfolioSelection suppose that the data is in the form of a matrix\n# where each row is the price vector of the assets at a specific time period.\njulia> prices = prices |> permutedims;\n\n# Let's run the algorithm on the last 10 days of the data.\njulia> m_bs = bs(prices[:, end-9:end]);\n\njuila> m_bs.b\n5×10 Matrix{Float64}:\n 0.2  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.2  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.2  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.2  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.2  1.0  0.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"After running the algorithm, one can calculate the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(m_bs.b, rel_price)\n11-element Vector{Float64}:\n 1.0\n 1.0067934076484562\n 1.009228482491198\n 1.0188656476194202\n 1.0387633347003844\n 1.0354766468359777\n 1.027215571086806\n 1.0305022589512125\n 1.0499557074411052\n 1.0350324760158582\n 1.0255278032954953","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"The outcome suggests that if we had invested during the specified period, we would have gained approximately 2.6% of our capital. Notably, sn automatically considers the last 10 relative prices in this scenario.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"It's important to highlight that this package offers functions designed to assess the algorithm's performance. For additional insights, refer to the Performance evaluation section.","category":"page"},{"location":"benchmark/#/N","page":"Benchmark","title":"1/N","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"This model invests equally in all assets. Let's run the algorithm:","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"juila> using OnlinePortfolioSelection\n\njulia> size(prices)\n(17, 5)\n\n# OnlinePortfolioSelection suppose that the data is in the form of a matrix\n# where each row is the price vector of the assets at a specific time period.\njulia> prices = prices |> permutedims;\n\n# Let's run the algorithm on the last 10 days of the data.\njulia> m_uni = uniform(5, 10);\n\njuila> m_uni.b\n5×10 Matrix{Float64}:\n 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"After running the algorithm, one can calculate the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(m_uni.b, rel_price)\n11-element Vector{Float64}:\n 1.0\n 1.006793403065235\n 1.0044027643134168\n 1.0040238271404696\n 1.0051064998568846\n 0.9884495565932121\n 0.9765706200501145\n 0.9740981677925922\n 0.9757223268076264\n 0.9660623342882886\n 0.960423009921307","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"The result reveals that if investment had been made during the specified period, a loss of approximately 3.9% of the capital would have been incurred. It's noteworthy that sn automatically accounts for the last 10 relative prices in this context.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Additionally, this package offers functions for assessing the algorithm's performance. For further details, refer to the Performance evaluation section.","category":"page"},{"location":"benchmark/#Universal-Portfolio","page":"Benchmark","title":"Universal Portfolio","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Universal Portfolio (UP) is a Follow the Winner (FW) strategy introduced by Cover [2]. This algorithm is designed to optimize the cumulative return of a portfolio over the investment horizon. UP's approach is centered on daily stock market performance and the distribution of wealth invested in individual stocks.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"See up.","category":"page"},{"location":"benchmark/#Run-UP","page":"Benchmark","title":"Run UP","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Note: This package is meant to be used by researchers NOT FOR MARKET PRACTITIONERS. Let's run the algorithm on the real market data. The data is collected as noted in the Fetch Data section.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"juila> using OnlinePortfolioSelection\n\njulia> size(prices)\n(17, 5)\n\n# OnlinePortfolioSelection suppose that the data is in the form of a matrix\n# where each row is the price vector of the assets at a specific time period.\njulia> prices = prices |> permutedims;\n\n# Let's run the algorithm on the last 5 days of the data.\njulia> m_up = up(prices[:, end-4:end], eval_points=100);\n\njuila> m_up.b\n5×5 Matrix{Float64}:\n 0.2  0.216518  0.216638  0.21681   0.216542\n 0.2  0.203395  0.203615  0.203754  0.203528\n 0.2  0.191899  0.191793  0.192316  0.192473\n 0.2  0.193023  0.192302  0.191687  0.19208\n 0.2  0.195164  0.195652  0.195433  0.195377","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"One can calculate the cumulative wealth during the investment period by using the sn function:","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"julia> rel_price = prices[:, 2:end] ./ prices[:, 1:end-1];\n\njulia> sn(m_up.b, rel_price)\n6-element Vector{Float64}:\n 1.0\n 0.9879822623031318\n 0.9856240412854884\n 0.9874863498385578\n 0.9778277061434468\n 0.9718529924971879","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"The outcome shows that if we had invested during that period, we would have incurred a loss of approximately 2.8% in wealth. It's important to note that sn automatically considers the last 5 relative prices in this context. Let's now examine the algorithm's performance using various significant metrics.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"julia> results = OPSMetrics(m_up.b, rel_price)\n\n            Cumulative Return: 0.972\n                          APY: -0.763\nAnnualized Standard Deviation: 0.088\n      Annualized Sharpe Ratio: -8.857\n             Maximum Drawdown: 0.028\n                 Calmar Ratio: -27.101\n\njulia> results.\nAPY         Ann_Sharpe  Ann_Std     Calmar      MDD         Sn\n\njulia> results.MDD\n0.02814700750281207","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"It is worth mentioning that each metric can be accessed individually by writing results. and pressing Tab key. Note that one can individually investigate the performance of the algorithm regarding each metric. See sn, ann_std, apy, ann_sharpe, mdd, and calmar. See Performance evaluation section for more information.","category":"page"},{"location":"benchmark/#References","page":"Benchmark","title":"References","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"T. M. Cover. Universal Portfolios. Mathematical Finance 1, 1–29 (1991).\n\n\n\nL. GYÖRFI, A. URBÁN and I. VAJDA. KERNEL-BASED SEMI-LOG-OPTIMAL EMPIRICAL PORTFOLIO SELECTION STRATEGIES. International Journal of Theoretical and Applied Finance 10, 505–516 (2007).\n\n\n\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = quote\n    using OnlinePortfolioSelection\nend","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Online Portfolio Selection (OPS) strategies represent trading algorithms that sequentially allocate capital among a pool of assets with the aim of maximizing investment returns. This forms a fundamental issue in computational finance, extensively explored across various research domains, including finance, statistics, artificial intelligence, machine learning, and data mining. Framed within an online machine learning context, OPS is defined as a sequential decision problem, providing a range of advanced approaches to tackle this challenge. These approaches categorize into benchmarks, “Follow-the-Winner” and “Follow-the-Loser” strategies, “Pattern-Matching” based methodologies, and \"Meta-Learning\" Algorithms [1]. This package offers an efficient implementation of OPS algorithms in Julia, ensuring complete type stability. All algorithms yield an OPSAlgorithm object, permitting inquiries into portfolio weights, asset count, and algorithm names. Presently, eighteen algorithms are incorporated, with ongoing plans for further additions. The existing algorithms are as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nIn the following table, the abbreviations PM, ML, FL, and FW stand for Pattern-Matching, Meta-Learning, Follow the Loser, and Follow the Winner, respectively.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Row № Algorithm Strategy Year Row № Algorithm Strategy Year\n1 CORN PM 2011 11 Bᴷ PM 2006\n2 DRICORN-K PM 2020 12 LOAD Combined 2019\n3 CRP Market 1991 13 MRvol Combined 2023\n4 UP Market 1991 14 CW-OGD ML 2021\n5 EG FW 1998 15 ClusLog PM 2020\n6 BS Market 2007 16 PAMR FL 2012\n7 RPRT FL 2020 17 PPT FW 2018\n8 Anticor FL 2003 18 CWMR FL 2013\n9 1/N Market - 19 CAEG ML 2020\n10 OLMAR FL 2012 20   ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The available methods can be viewed by calling the opsmethods function.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The latest stable version of the package can be installed by running the following command in the Julia REPL after pressing ]:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add OnlinePortfolioSelection","category":"page"},{"location":"","page":"Home","title":"Home","text":"or","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"OnlinePortfolioSelection\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or even","category":"page"},{"location":"","page":"Home","title":"Home","text":"juila> using Pkg; pkg\"add OnlinePortfolioSelection\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"The dev version can be installed usint the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; pkg\"dev OnlinePortfolioSelection\"\n\n# or\n\npkg> add https://github.com/shayandavoodii/OnlinePortfolioSelection.jl.git","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be imported by running the following command in the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using OnlinePortfolioSelection","category":"page"},{"location":"","page":"Home","title":"Home","text":"Multiple strategies can be applied to a given dataset for analysis and comparison of results. The following code snippet demonstrates how to execute these strategies on a provided dataset and compare their outcomes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"juila> using CSV, DataFrames\n\n# read adjusted close prices\njulia> pr = CSV.read(\"data\\\\sp500.csv\", DataFrame) |> Matrix |> permutedims;\n\njulia> pr = pr[2:end, :];\n\njulia> market_pr = pr[1, :];\n\njulia> size(pr)\n(24, 1276)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The dataset encompasses adjusted close prices of 24 stocks in the S&P 500 across 1276 trading days. Suppose we aim to apply the strategies to the most recent 50 days of the dataset using default arguments:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> m_corn_u = cornu(pr, 50, 3);\n\njulia> m_corn_k = cornk(pr, 50, 3, 2, 2);\n\njuila> m_drcorn_k = dricornk(pr, market_pr, 50, 5, 5, 5);","category":"page"},{"location":"","page":"Home","title":"Home","text":"Next, let's visualize the daily cumulative budgets' trends for each algorithm. To do this, we'll need to compute them by utilizing the attained portfolio weights and relative prices within the same time period.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# calculate the relative prices\njulia> rel_pr = pr[:, 2:end] ./ pr[:, 1:end-1];\n\njulia> models = [m_corn_u, m_corn_k, m_drcorn_k];\n\n# calculate the cumulative budgets\njulia> budgets = [sn(model.b, rel_pr[:, end-49:end]) for model in models];\n\njulia> using Plots\n\njulia> plot(\n            budgets, \n            label = [\"CORN-U\" \"CORN-K\" \"DRICORN-K\"], \n            xlabel = \"Day\", ylabel = \"Cumulative return\", legend = :bottomleft,\n       )","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"assets/cumulative_budgets.png\" width=\"100%\">","category":"page"},{"location":"","page":"Home","title":"Home","text":"The plot illustrates that the cumulative return of CORN-K consistently outperforms the other algorithms. It's important to note that the initial investment for all algorithms is standardized to 1, although this can be adjusted by setting the keyword argument init_budg for each algorithm. Now, let's delve into the performance analysis of the algorithms using prominent performance metrics:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> all_metrics = OPSMetrics.([m_corn_u.b, m_corn_k.b, m_drcorn_k.b], Ref(rel_pr));","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now, one can embed the metrics in a DataFrame and compare the performance of the algorithms with respect to each other:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using DataFrames\n\njulia> nmodels = length(all_metrics);\n\njulia> comp_algs = DataFrame(\n           Algorithm = [\"CORN-U\", \"CORN-K\", \"DRICORN-K\"],\n           APY = [all_metrics[i].APY for i = 1:nmodels],\n           Ann_Sharpe = [all_metrics[i].Ann_Sharpe for i = 1:nmodels],\n           Ann_Std = [all_metrics[i].Ann_Std for i = 1:nmodels],\n           Calmar = [all_metrics[i].Calmar for i = 1:nmodels],\n           MDD = [all_metrics[i].MDD for i = 1:nmodels],\n       )\n3×6 DataFrame\n Row │ Algorithm  APY        Ann_Sharpe  Ann_Std   Calmar    MDD       \n     │ String     Float64    Float64     Float64   Float64   Float64   \n─────┼─────────────────────────────────────────────────────────────────\n   1 │ CORN-U     -0.126009   -0.505762  0.288691  -1.25383  0.100499\n   2 │ CORN-K      0.826495    2.48378   0.324705  17.688    0.0467263\n   3 │ DRICORN-K  -0.248393   -1.20933   0.221934  -2.54505  0.0975985","category":"page"},{"location":"","page":"Home","title":"Home","text":"The comparison analysis, via comp_algs, highlights that CORN-K outperforms the other algorithms in terms of annualized percentage yield (APY), annualized Sharpe ratio, Calmar ratio, and maximum drawdown (MDD). However, it's essential to note that the annualized standard deviation of CORN-K surpasses that of the other algorithms within this dataset. These individual metrics can be computed separately by using corresponding functions such as sn, apy, ann_sharpe, ann_std, calmar, and mdd. For further insights and details, please refer to the Performance evaluation.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"B. Li and S. C. Hoi. Online Portfolio Selection: A Survey (2013).\n\n\n\n","category":"page"},{"location":"types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"Modules = [OnlinePortfolioSelection]\nPrivate = false\nOrder   = [:type]","category":"page"},{"location":"types/#OnlinePortfolioSelection.KMDLOG","page":"Types","title":"OnlinePortfolioSelection.KMDLOG","text":"KMDLOG<:ClusLogVariant\n\nKMDLOG is a concrete type used to represent the KMDLOG Model. Also, see KMNLOG.\n\n\n\n\n\n","category":"type"},{"location":"types/#OnlinePortfolioSelection.KMNLOG","page":"Types","title":"OnlinePortfolioSelection.KMNLOG","text":"KMNLOG<:ClusLogVariant\n\nKMNLOG is a concrete type used to represent the KMNLOG Model. Also, see KMDLOG.\n\n\n\n\n\n","category":"type"},{"location":"types/#OnlinePortfolioSelection.OPSAlgorithm","page":"Types","title":"OnlinePortfolioSelection.OPSAlgorithm","text":"OPSAlgorithm{T<:AbstractFloat}\n\nA OPSAlgorithm object that contains the result of running the algorithm.\n\nFields\n\nn_asset::Int: Number of assets in the portfolio.\nb::Matrix{T}: Weights of the created portfolios.\nalg::String: Name of the algorithm.\n\n\n\n\n\n","category":"type"},{"location":"types/#OnlinePortfolioSelection.OPSMetrics","page":"Types","title":"OnlinePortfolioSelection.OPSMetrics","text":"OPSMetrics{T<:AbstractFloat}\n\nA struct to store the metrics of the OPS algorithm.\n\nFields\n\nSn::Vector{T}: the cumulative return of investment during the investment period.\nMER::T: the investments's Mean excess return (MER).\nAPY::T: the Annual Percentage Yield (APY) of investment.\nAnn_Std::T: the Annualized Standard Deviation (σₚ) of investment.\nAnn_Sharpe::T: the Annualized Sharpe Ratio (SR) of investment.\nMDD::T: the Maximum Drawdown (MDD) of investment.\nCalmar::T: the Calmar Ratio of investment.\n\n\n\n\n\n","category":"type"},{"location":"types/#OnlinePortfolioSelection.OPSMetrics-Union{Tuple{S}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}} where {T<:AbstractFloat, S<:Int64}","page":"Types","title":"OnlinePortfolioSelection.OPSMetrics","text":"OPSMetrics(\n  weights::AbstractMatrix{T},\n  rel_pr::AbstractMatrix{T};\n  init_inv::T=1.,\n  Rf::T=0.02\n  dpy::S=252,\n  v::T=0.\n  dpy::S=252\n) where {T<:AbstractFloat, S<:Int}\n\nCalculate the metrics of an OPS algorithm. Also, see sn, mer, ann_std, apy, ann_sharpe, mdd, and calmar.\n\nArguments\n\nweights::AbstractMatrix{T}: the weights of the portfolio.\nrel_pr::AbstractMatrix{T}: the relative price of the stocks.\n\nKeyword Arguments\n\ninit_inv::T=1: the initial investment.\nRf::T=0.02: the risk-free rate of return.\ndpy::S=252: the number of days in a year.\nv::T=0.: the transaction cost rate.\n\nwarning: Warning\nThe size of weights and rel_pr must be (n_stocks, n_periods).\n\nnote: Note\nIf size(rel_pr, 2) is greater than size(weights, 2), then the last size(weights, 2) columns of rel_pr will be used.\n\nReturns\n\n::OPSMetrics: An OPSMetrics object.\n\n\n\n\n\n","category":"method"},{"location":"types/#OnlinePortfolioSelection.PAMR","page":"Types","title":"OnlinePortfolioSelection.PAMR","text":"PAMR<: PAMRModel\n\nCreate a PAMR object. Also, see PAMR1, and PAMR2.\n\nExample\n\nmodel = PAMR()\n\n\n\n\n\n","category":"type"},{"location":"types/#OnlinePortfolioSelection.PAMR1","page":"Types","title":"OnlinePortfolioSelection.PAMR1","text":"PAMR1{T<:AbstractFloat}<: PAMRModel\n\nCreate a PAMR1 object. Also, see PAMR, and PAMR2.\n\nKeyword Arguments\n\nC::AbstractFloat=1.: Aggressiveness parameter.\n\nExample\n\nmodel = PAMR1(C=0.02)\n\n\n\n\n\n","category":"type"},{"location":"types/#OnlinePortfolioSelection.PAMR2","page":"Types","title":"OnlinePortfolioSelection.PAMR2","text":"PAMR2{T<:AbstractFloat}<: PAMRModel\n\nCreate a PAMR2 object. Also, see PAMR, and PAMR1.\n\nKeyword Arguments\n\nC::AbstractFloat=1.: Aggressiveness parameter.\n\nExample\n\nmodel = PAMR2(C=0.02)\n\n\n\n\n\n","category":"type"}]
}
